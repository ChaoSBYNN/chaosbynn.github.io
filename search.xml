<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSRF 与 CORS</title>
    <url>/2024/07/06/CSRF-%E4%B8%8E-CORS/</url>
    <content><![CDATA[<p><code>CSRF(Cross-Site Request Forgery)</code>和<code>CORS(Cross-Origin Resource Sharing)</code>都是与Web安全和跨域资源共享相关的概念，但它们解决的问题和应对的场景有所不同。</p>
<ol>
<li><p>CSRF(跨站请求伪造)：CSRF是一种攻击方式，攻击者通过伪造用户已认证的请求，使用户在不知情的情况下执行恶意操作。攻击者通常利用用户的身份验证凭据，以用户的身份执行未经授权的操作，可能导致数据泄露、账户劫持等问题。为了防止CSRF攻击，常见的做法是在请求中包含一个随机生成的令牌(CSRF令牌)，并在服务器端进行验证，确保请求是来自合法的来源。</p>
</li>
<li><p>CORS(跨域资源共享)：CORS是一种机制，允许Web应用程序从不同的源头(域、协议、端口)请求资源，而不受浏览器的同源策略限制。同源策略是浏览器的安全策略，它限制了一个源头的文档或脚本如何与其他源头的资源进行交互。通过CORS，服务器可以指定哪些源头(域)有权限访问资源，从而确保跨域请求的安全性。</p>
</li>
</ol>
<p>区别总结如下：</p>
<ul>
<li>CSRF是一种攻击方式，而CORS是一种机制。</li>
<li>CSRF关注的是恶意请求的安全性，而CORS关注的是跨域资源共享的安全性。</li>
<li>CSRF攻击利用用户身份进行未经授权的操作，而CORS允许合法的跨域请求。</li>
</ul>
<p>在Web应用程序中，为了保护用户和资源的安全性，我们需要同时考虑防止CSRF攻击和使用CORS机制来进行跨域资源共享。</p>
<p>希望对你有所帮助！如果还有其他问题，请随时提问。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Could not retrieve mirrorlist http://mirrorlist.centos.org</title>
    <url>/2024/07/02/Could-not-retrieve-mirrorlist-http-mirrorlist-centos-org/</url>
    <content><![CDATA[<blockquote>
<p>Could not retrieve mirrorlist <a class="link"   href="http://mirrorlist.centos.org/" >http://mirrorlist.centos.org<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h2 id="替换-yum-软件源为阿里云镜像源"><a href="#替换-yum-软件源为阿里云镜像源" class="headerlink" title="替换 yum 软件源为阿里云镜像源"></a>替换 yum 软件源为阿里云镜像源</h2><h3 id="备份当前的-yum-软件源文件"><a href="#备份当前的-yum-软件源文件" class="headerlink" title="备份当前的 yum 软件源文件"></a>备份当前的 yum 软件源文件</h3><p>在进行修改之前，首先备份原始的 yum 软件源配置文件。打开终端，输入以下命令备份：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure></div>

<h3 id="编辑-yum-软件源配置文件"><a href="#编辑-yum-软件源配置文件" class="headerlink" title="编辑 yum 软件源配置文件"></a>编辑 yum 软件源配置文件</h3><p>使用文本编辑器(如 <code>vim</code> 或 <code>nano</code>)打开 <code>/etc/yum.repos.d/CentOS-Base.repo</code> 文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure></div>

<h3 id="注释掉原有的镜像源配置"><a href="#注释掉原有的镜像源配置" class="headerlink" title="注释掉原有的镜像源配置"></a>注释掉原有的镜像源配置</h3><p>在打开的文件中，找到 <code>[base]</code>、<code>[updates]</code>、<code>[extras]</code> 和 <code>[centosplus]</code> 等节，将它们的 <code>baseurl</code> 行注释掉(在行首添加 <code>#</code>符号)，同时保留 <code>mirrorlist</code> 行(如果有)。</p>
<p>例如:</p>
<div class="code-container" data-rel="Ini"><figure class="iseeu highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[base]</span></span><br><span class="line"><span class="comment">#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/</span></span><br><span class="line"><span class="attr">mirrorlist</span>=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;arch=<span class="variable">$basearch</span>&amp;repo=os</span><br><span class="line"></span><br><span class="line"><span class="section">[updates]</span></span><br><span class="line"><span class="comment">#baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/</span></span><br><span class="line"><span class="attr">mirrorlist</span>=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;arch=<span class="variable">$basearch</span>&amp;repo=updates</span><br><span class="line"></span><br><span class="line"><span class="section">[extras]</span></span><br><span class="line"><span class="comment">#baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/</span></span><br><span class="line"><span class="attr">mirrorlist</span>=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;arch=<span class="variable">$basearch</span>&amp;repo=extras</span><br><span class="line"></span><br><span class="line"><span class="section">[centosplus]</span></span><br><span class="line"><span class="comment">#baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/</span></span><br><span class="line"><span class="attr">mirrorlist</span>=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;arch=<span class="variable">$basearch</span>&amp;repo=centosplus</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="添加阿里云镜像源配置"><a href="#添加阿里云镜像源配置" class="headerlink" title="添加阿里云镜像源配置"></a>添加阿里云镜像源配置</h3><div class="code-container" data-rel="Ini"><figure class="iseeu highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[base]</span></span><br><span class="line"><span class="attr">name</span>=CentOS-<span class="variable">$releasever</span> - Base - mirrors.aliyun.com</span><br><span class="line"><span class="attr">baseurl</span>=http://mirrors.aliyun.com/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="section">[updates]</span></span><br><span class="line"><span class="attr">name</span>=CentOS-<span class="variable">$releasever</span> - Updates - mirrors.aliyun.com</span><br><span class="line"><span class="attr">baseurl</span>=http://mirrors.aliyun.com/centos/<span class="variable">$releasever</span>/updates/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="section">[extras]</span></span><br><span class="line"><span class="attr">name</span>=CentOS-<span class="variable">$releasever</span> - Extras - mirrors.aliyun.com</span><br><span class="line"><span class="attr">baseurl</span>=http://mirrors.aliyun.com/centos/<span class="variable">$releasever</span>/extras/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="section">[centosplus]</span></span><br><span class="line"><span class="attr">name</span>=CentOS-<span class="variable">$releasever</span> - Plus - mirrors.aliyun.com</span><br><span class="line"><span class="attr">baseurl</span>=http://mirrors.aliyun.com/centos/<span class="variable">$releasever</span>/centosplus/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>将 <code>$releasever</code> 替换为您当前系统的 CentOS 版本号,如 <code>7</code> 或 <code>8</code>。</li>
<li>请确保 <code>gpgkey</code> 链接正确，以便验证下载的软件包。</li>
</ul>
<h3 id="保存并退出编辑器"><a href="#保存并退出编辑器" class="headerlink" title="保存并退出编辑器"></a>保存并退出编辑器</h3><p>在编辑完成后，保存文件并退出编辑器。</p>
<h3 id="清理-yum-缓存"><a href="#清理-yum-缓存" class="headerlink" title="清理 yum 缓存"></a>清理 yum 缓存</h3><p>为了确保使用新的镜像源配置，清理当前的 yum 缓存</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure></div>

<h3 id="恢复原始配置-可选"><a href="#恢复原始配置-可选" class="headerlink" title="恢复原始配置(可选)"></a>恢复原始配置(可选)</h3><p>如果需要恢复到原始的 CentOS 官方源，可以将之前备份的 <code>/etc/yum.repos.d/CentOS-Base.repo.bak</code> 文件复制回去，并清理 yum 缓存再次测试。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Do have faith in what you are doing All for a better world</title>
    <url>/2017/02/22/Do-have-faith-in-what-you-are-doing-All-for-a-better-world/</url>
    <content><![CDATA[<blockquote>
<p>转载<br><a class="link"   href="http://www.nowamagic.net/librarys/veda/detail/2502" >http://www.nowamagic.net/librarys/veda/detail/2502<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> Do have faith in what you are doing.</p>
</blockquote>
<p>先不要往下看，试试品尝上面这句话的含义。</p>
<p>引用 Facebook Mark Zuckerberg 的一句话：</p>
<blockquote>
<p>“You have to have passion for what you are doing. If you don’t completely love or believe in what you are doing, the natural thing will be to give up when you face the challenges that will inevitably come. More than anything you have to really have faith in what you are doing.”</p>
</blockquote>
<p>简单翻译如下：</p>
<blockquote>
<p>你必须对你所做的事情很有激情。如果你没有完全喜欢或信任你所做的事情，当你面对挑战的时候，自然而然就会放弃，经不起变革。一定要相信你现在做的事情，对你做的事情保持信仰，这比任何事情都重要。</p>
</blockquote>
<p>我认为，Mark Zuckerberg 确实已做到了改变世界。从校园里走出来的 Facebook，风靡全球。</p>
<p>乔布斯在斯坦福大学的演讲中也谈到：</p>
<blockquote>
<p>你必须找到你所爱的。无论是工作还是爱人。工作将占据你生命中大部分时间，你只有相信自己所做的是伟大的工作, 才能怡然自得。而有伟大成就的唯一途径就是爱你所做的。— Steve Jobs</p>
</blockquote>
<p>乔布斯改变世界了吗？有目共睹。</p>
<p>Do have faith in what you are doing. 或许就是他们成功的共同秘诀。</p>
<h3 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h3><p>我们都知道要做自己喜欢的，但自己真正喜欢什么，却未必清楚。也很少有时间问问自己：这辈子究竟要做些什么？怎么做才无愧此生？生活就像一个没有设置break的while True循环，一旦开始就停不下来了。上班要忙上班的事，周末要聚会，看电影，玩游戏，逛街，把上班时的痛苦补回来，然后在不情愿中迎接下一个周一。这是自己想要的生活吗？</p>
<p>我们先来看看一个问题：如何找到自己所爱的？</p>
<p>真正让自己热血沸腾的是我们可以一直做自己最爱的事，但却没有循序渐进的教程可以帮助我们找到自己所爱的。以往的经验能起一点作用，但无法形成一套体系。</p>
<p>为了找到自己的热情，可以问自己：如果有一百万美元，你想做什么？</p>
<p>典型的回答是：会把这些钱存入银行，然后每年光利息就可以生活了。然后会搬到夏威夷，买一个别墅，品尝所有的美味，看看书，搞点体育运动，等等。</p>
<p>这样的回答有帮助吗？可能吧。比如，你知道了自己原来是个大懒鬼，但这并没有回答背后的问题：如何能做自己喜欢的事，还能挣到钱？</p>
<p>人们从事着自己讨厌的工作，感觉像掉入了陷阱，因为他们无法离开，他们靠着这唯一的收入来维持目前的生活状态，以此来逃避现实，漂流在严酷、漫无目的的生活中，简而言之：活在平静的绝望中。</p>
<p>平静的绝望，这是个深渊。很多人就在这个深渊里，耗费掉自己的一辈子。</p>
<p>你或许会问：他们为什么不辞职，追求自己喜欢的呢？</p>
<p>主要原因有两个：</p>
<ol>
<li>他们不知道自己最喜欢的事</li>
<li>恐惧。他们要维持目前的生活，有账单要付，家人要照顾，怕没有稳定的收入来源，怕别人异样的目光或说三道四，等等。</li>
</ol>
<p>搞定原因1，接下来的就会迎刃而解。</p>
<p>无论你信不信，想要找到自己的激情所在已经是一个很大的进步了。很多人，他们一生都在回避或者根本没想过这个问题。当他们听到这个问题时，会很熟练地忽视之。</p>
<p>如何找到自己所爱的？这是一个很重要的问题，而你必须找到答案。</p>
<p>对，必须要。</p>
<p>你必须自己决定目的地，不然生活就会替你做决定。如果知道了目的地，剩下的就很简单了。你会发现，一旦你找到了自己所爱的，所有的不确定、负担都会从你的肩上滑落，你会很清楚地看到自己的旅程，一趟充满欢喜的旅程。</p>
<h3 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h3><p>为什么找到自己所爱的那么难？</p>
<p>答案是：</p>
<p>这一点都不难。</p>
<p>那为什么这么多人都被这个问题所困扰呢？</p>
<p><strong>因为他们从未真正地问过自己。</strong></p>
<p>我觉得很有意思的一件事是，人们好像总是要让自己做点什么，停不下来。比如：出去玩、聚会、逛街等等。不要误解，做这些事没有任何问题。但我怀疑大部分人都有这样的心态：我必须每时每分都做点什么，因为我做不了自己。只是想让自己在别人面前看起来风光一点。但事实上，要让自己充实起来，应该多花一点时间在自己身上。</p>
<p>人们以为必须环游世界，尝试新事物等等才能找到自己的所爱。不，你只要坐下来，然后决定。答案已经在你心里。你只要把它挖出来，别耽搁。</p>
<p>说实话，你有没有曾经独自一人坐下来，抛开手机，离开电脑，关上电视、聊天工具，关上自己最爱听的歌，关闭游戏，停止检查邮件、回复电话、浏览杂志等等其他一切分心的事，扪心自问：自己到底喜欢什么？</p>
<p>你害怕问题的答案，因为答案是：我不知道。</p>
<p>这也是为什么你必须找到答案的原因。承认自己不知道，这是ok的，比那些自动跳过的好多了。下面让我们一步一步地来找到答案。</p>
<h3 id="其三"><a href="#其三" class="headerlink" title="其三"></a>其三</h3><p><strong>1. 只要你愿意，就一定会找到答案</strong></p>
<p>你一定会找到，无庸置疑。</p>
<p>带着这样的心态，你就一定会找到。会花多长时间？不重要。你终将会找到。</p>
<p>这样做，你会自动开启反放弃机制，因为你知道你一定会找到答案。</p>
<p>比如，如果你知道你要去纽约，你就会找到去那里的方法，你会搭车、火车或飞机，然后到达。</p>
<p>如果没有钱，你可以借，或者找份工作省钱，或者找一份空姐&#x2F;空哥的工作，这样就可以免费去那。花多长时间不重要，要做些什么也不重要，因为你知道你要去纽约。</p>
<p>你这个决定之后所有的行动都会围绕着『去纽约』而展开。</p>
<p>再读一遍最后这句：</p>
<p>你这个决定之后所有的行动都会围绕着『去纽约』而展开。</p>
<p>找到你所爱的 ＝ 决定去纽约。</p>
<p><strong>2. 列一个技能清单和兴趣列表</strong></p>
<p>再强调一遍：写下来。不要以为你可以在头脑中完成。</p>
<p>我这说的技能是任何技能。可以是无形的。比如编程，网页制作，聊天，倾听，说服别人，打字，调情，分析，演讲，让事情易于理解，吹口哨等等。不要害羞，列出所有自己的技能。</p>
<p>在另一列，列出自己的兴趣，同样，也不要害羞。列出所有你能想到的兴趣。蜘蛛、鞋子、头发、化妆品、篮球、网球、幻想、保姆、散步、PS、Fireworks、帮助别人、搞笑、钓鱼、空手道、瓶起子等等，什么都行。是的，我提到了瓶起子。你的兴趣也可以包含自己擅长的方面。计算机、经济学、生物学、篮球、足球、魔术等等。</p>
<p>为了帮助你写下更多的兴趣爱好，想想之前的那份工作你最感兴趣的是什么，不感兴趣的又是什么。</p>
<p>问自己以下这些问题有助于发现自己追求的技能和兴趣：</p>
<ul>
<li>如果你去一个书店，那个书架上的书对你的引力最大？问问朋友他们眼中你的技能和兴趣。你会惊叹于他们的洞察力。</li>
<li>你把大多数的时间都花在了哪些事上？做这些事你期望得到怎样的结果？像小孩子一样想像自己的成就。都有哪些技能和兴趣对你的成就有帮助？</li>
<li>你做了什么别人会感谢你？</li>
<li>你的老师或家人有没有说过你有什么诀窍？</li>
<li>为什么我一再强调技能和兴趣？</li>
</ul>
<p>技能：你必须依赖你的强项。不要告诉我你什么也没有。每个人都有技能。你只是没有坐下来细想，并且写下来。</p>
<p>兴趣：很简单，你必须爱你所做的。</p>
<p>专注于你能想到的兴趣和技能，并且写下来。</p>
<p>你会发现你的技能好像受了引力作用一样偏向一种或两种技能，兴趣也一样。好，下面让我们进入步骤3。</p>
<p><strong>3. 问正确的问题来找到自己的最爱</strong></p>
<p>找一个真正属于自己的时间和空间，没有任何分心的东西，通过问正确的问题来找到自己的最爱。</p>
<p>我发现一个很有趣的现象，人们总是为税务、烹饪、电影、阅读留出时间，但是涉及到自己的将来时，却从来不会腾出时间。</p>
<p>现在，假如你已经安排了私人时间，没有杂事干扰，然后呢？你必须问自己一个清晰的问题，清晰是关键，问题越清晰，回答越简单。</p>
<p>比如，我问，12x12等于多少？答案很明了：144。</p>
<p>如果我问两个偶数和另外两个偶数的乘积？这就很难回答了。</p>
<p><strong>清晰的问题引出清晰的答案</strong></p>
<p>另外一个关键点是：写下来。我知道你听过一万次了，不过这是有原因的。把东西写下来有助于你在各项之间建立联系，这在脑海里是很难完成的。</p>
<p>如果你在之前的阶段没有写下技能和兴趣，那么停下，马上写下来。放在大脑里是不会有帮助的。</p>
<p>现在利用独处的时间问自己一个清晰的问题，这个问题会是：“我最喜欢做什么？”吗？</p>
<p>这个问题有点广泛了，再缩小一点，问自己：</p>
<p><strong>在每天的生活中，我最喜欢做什么，可以同时结合我的技能和兴趣，并给人们的生活带来重大价值？</strong></p>
<p>看到区别了吗？问题越具体，越清晰，回答起来就越方便。我为什么加了价值这一项？因为这会帮助你找到挣钱的方法。</p>
<p>“通过技能和兴趣带来重大价值”，可以自动过滤那些普遍的答案，如：“看电视”，或“玩游戏”，这些答案往往会带来消极因素，因为看不到挣钱的方法。</p>
<p>顺带一句，很多人会误解这句话的核心，把重点放在了挣钱上。钱只是通过产品或服务为人们的生活带去方便的一个副产品。</p>
<p>当你知道你可以为别人的生活带来方便时，你就会知道如何挣钱。打开Word或纸张，在最前面写下这个问题。</p>
<p>在每天的生活中，我最喜欢做什么，可以同时结合我的技能和兴趣，并给人们的生活带来重大价值？</p>
<p>再强调一遍，重点是写下你自己的答案。</p>
<p>看看之前列的两列清单，写下答案，有多少，写多少。不必完美，也不一定要有什么意义。因为迟早你会把这些关连起来。下面这个故事可以帮助阐述我的意思。</p>
<blockquote>
<p>有一个小镇，以滑雪而出名，吸引了一大批游客前来，这对于促进经济有很大的作用。但是，下雪时，雪会沉积在电缆上，直到把电缆压跨，导致部分能源过载。慢慢的游客们都不来了，于是小镇举行了一个会议，讨论如何解决雪压跨电缆的问题。很久都没有好的解决方案。</p>
</blockquote>
<p>突然有人在会议室的后面大声喊道“我们可以在电缆上放几盆蜂蜜，让熊爬上电缆，拿到蜂蜜，熊的这一系列动作会把电缆上的雪抖落”</p>
<p>在座的都笑了，有人接这个话茬“那我们怎么再在这些盆里放蜂蜜呢？”“可以用直升飞机”，另一个人说。</p>
<p>于是答案就出来了，让直升飞机在电缆上飞，通过螺旋桨的风力把雪吹落。</p>
<p>我想说的是，无论答案有多可笑，都不用害怕，因为它们常常能帮你找到最终的结果。这是过程的一部分。</p>
<p>所以无论多滑稽，写下来。写下所有的答案。直到你有了20个答案，然后回顾它们。你会发现，你写下的答案会帮助你找到新的答案。</p>
<p>你会惊叹写下的所有东西，以及各个富有创意的想法。</p>
<p><strong>现在又要集中注意力了</strong></p>
<p>你肯定听过通过放大镜来聚焦阳光的事。但我还是想说，如果你打算一次处理多件事，那么哪件事都完不成。即使在最热的天，如果你不停移动放大镜，并不会聚焦多大的能量，什么也烧不着。只是无端地浪费自己的精力。</p>
<p>通过管理你的精力，时间，思考等等，在攻克一个目标时，你会惊叹目标完成的深度和效率。就像你在一个东西上放了一个放大镜，而你的欲望，精力，时间，思考，想像就是太阳光。</p>
<p>专注很重要，这里我想再举个例子。想像自己是一只猎豹，正在追逐两只羚羊。如果想同时追逐两个的话，那么什么也抓不到，只能饿死。先拿下一只，这可能需要时间去追击去撕咬，但当你真的吃掉了它，你又充满电了。你可以收集信息：羚羊都往哪个方向跑了，可能在哪块停留，等等。这有助于你今后捕获更多的羚羊，这就形成了良性循环。简而言之：专注于一个目标。</p>
<p>所以检查你刚刚的列表，选择一个最感兴趣的。你可能会发现，你可以把多个想法集中到一个。最好选择一个不仅能给自己带来极大的满足感，还能够帮助别人的想法。</p>
<h3 id="其四"><a href="#其四" class="headerlink" title="其四"></a>其四</h3><p>如何知道自己已经找到了最爱？</p>
<p>做这件事让你觉得爽吗？如果发自肺腑地觉得很爽，那就对了。如果你的朋友跟你谈论这个话题，你愿意跟他没完没了地谈论吗？</p>
<p>你必须毫无保留地喜欢这件事。如果你感到一丁点的怀疑，那这就不是你的激情所在。你必须急切地渴望克服任何困难来追逐你的激情。</p>
<p>一旦你找到了这件事，你的任务就完成了。至于如何通过它来挣钱，在你写下答案时，可能已经找到方法了。如果想找到更多挣钱的方法，只需重复之前的步骤。</p>
<ol>
<li>Step 1: 毫无疑问，你一定会找到答案</li>
<li>Step 2: 分两列，列一个技能清单和兴趣列表，并且写下来，你会发现其实有很多挣钱的方法</li>
</ol>
<p>挣钱的方法只能靠你自己了，不过对你来说应该不难。现在你知道了自己的最爱以及如何挣钱，该是行动的时候了。</p>
<p>很多人看到这里，没有任何行动，所以他们的生活也没有发生任何变化。</p>
<p><strong>Faith</strong></p>
<p>Faith，直译就是“信仰，信念”。</p>
<p>以我自己为例吧。当我对一个技术或知识不懂的时候，我会决定，是否要把它拿下。如果决定要拿下，我就会做一个专题，把资料都整理好，发布到 “现代魔法学院”上去。“现代魔法学院” 是我现在在做的一个个人项目。比如我正在研究 “编程范式”， 发现 “函数式编程” 我没有掌握透，我就专门开辟一个 “函数式编程” 的 chapter，为了实践函数式编程，我会学习一门函数式编程语言，比如 Python。这时候，就开辟了一个新天地，比如用 Python 做 Web 开发，Django 框架的学习等等……每一个知识点，我都会整理成一个 chapter，然后 chapter 又归类到 part 中。如此，连成一个整体性的知识体系。</p>
<p>为什么每一篇都要发布在学院里？自己懂了不就行了，为啥要花这么多时间和精力再重复一次？因为我相信，我现在遇到的问题，以后一定有人会遇到。我现在整理好，发布到学院，一定会给后来者提供极大的方便，还有极系统的知识体系。这就是我的 Faith，还有我所做的“简明现代魔法”的 Faith。</p>
<p>Do have faith in what you are doing.</p>
<p>All for a better world.</p>
]]></content>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch(ES) 与 ClickHouse</title>
    <url>/2024/07/09/Elasticsearch-ES-%E4%B8%8E-ClickHouse/</url>
    <content><![CDATA[<blockquote>
<p>Elasticsearch（ES）与 ClickHouse 都是优秀的数据存储和查询工具，但它们在适用场景和重点方面有所不同。具体来说，选择哪个工具更适合做业务数据查询取决于你的具体需求和业务情况。</p>
</blockquote>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p><strong>适用场景：</strong></p>
<ol>
<li><p><strong>全文搜索和复杂查询：</strong> Elasticsearch 最初设计用于文本搜索，它支持复杂的全文搜索查询，包括文本分析、词条查询、短语查询等。</p>
</li>
<li><p><strong>实时数据分析和监控：</strong> Elasticsearch 能够处理实时更新的数据，并且提供了强大的实时数据分析和聚合能力，适合于日志分析、实时指标监控等场景。</p>
</li>
<li><p><strong>高可用性和扩展性：</strong> Elasticsearch 具备高可用性和水平扩展的能力，可以构建分布式集群处理大规模数据。</p>
</li>
<li><p><strong>复杂数据结构支持：</strong> 支持复杂的数据结构和嵌套文档，能够存储和查询复杂的业务对象。</p>
</li>
<li><p><strong>搜索结果排序和分数计算：</strong> Elasticsearch 能够根据文档的相关性得分进行搜索结果排序，适合需要精细控制搜索结果的场景。</p>
</li>
</ol>
<h3 id="ClickHouse"><a href="#ClickHouse" class="headerlink" title="ClickHouse"></a>ClickHouse</h3><p><strong>适用场景：</strong></p>
<ol>
<li><p><strong>大规模数据分析和聚合：</strong> ClickHouse 是一个专门用于数据分析和聚合的列式存储数据库，特别擅长处理大量的数据集。</p>
</li>
<li><p><strong>高性能的聚合查询：</strong> ClickHouse 提供了非常高效的聚合查询能力，支持快速的汇总和统计操作，适合于大数据量的统计分析。</p>
</li>
<li><p><strong>低延迟的复杂查询：</strong> ClickHouse 能够在处理大数据量时保持低延迟，特别适合需要在大数据集上执行复杂查询的场景。</p>
</li>
<li><p><strong>存储效率和压缩：</strong> ClickHouse 使用列式存储，能够提供高效的存储和数据压缩，节约存储空间和提高查询性能。</p>
</li>
<li><p><strong>数据仓库和数据湖支持：</strong> ClickHouse 可以作为数据仓库或者数据湖的一部分，支持高效的数据仓库查询和数据湖分析。</p>
</li>
</ol>
<h3 id="选择哪个工具？"><a href="#选择哪个工具？" class="headerlink" title="选择哪个工具？"></a>选择哪个工具？</h3><ul>
<li><p><strong>如果你的主要需求是进行复杂的全文搜索、实时数据分析和监控，或者需要处理复杂的数据结构，那么 Elasticsearch 更适合。</strong></p>
</li>
<li><p><strong>如果你的主要需求是大规模的数据分析、高性能的聚合查询和低延迟的复杂查询，特别是在数据量非常大的情况下，那么 ClickHouse 更适合。</strong></p>
</li>
</ul>
<h3 id="综合考虑"><a href="#综合考虑" class="headerlink" title="综合考虑"></a>综合考虑</h3><p>在一些场景中，Elasticsearch 和 ClickHouse 可以结合使用，利用它们各自的优势来解决不同层面的数据需求。例如，可以使用 Elasticsearch 进行实时数据的搜索和分析，同时将历史数据存储在 ClickHouse 中，用于大规模的数据分析和复杂的查询操作。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Data</category>
      </categories>
      <tags>
        <tag>Data</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Tips</title>
    <url>/2024/07/03/Git-Tips/</url>
    <content><![CDATA[<h2 id="workflow-工作流"><a href="#workflow-工作流" class="headerlink" title="workflow 工作流"></a>workflow 工作流</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/git-workflow.png"
                      alt="workflow"
                ><figcaption>workflow</figcaption></figure></p>
<h2 id="cheat-sheets-速查表"><a href="#cheat-sheets-速查表" class="headerlink" title="cheat sheets 速查表"></a>cheat sheets 速查表</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/git_cheat_sheets.jpg"
                      alt="cheat_sheets"
                ><figcaption>cheat_sheets</figcaption></figure></p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git flow</title>
    <url>/2017/04/15/Git-flow/</url>
    <content><![CDATA[<h3 id="Production-Master-分支-：-合并读取"><a href="#Production-Master-分支-：-合并读取" class="headerlink" title="Production|Master 分支 ： 合并读取"></a>Production|Master 分支 ： 合并读取</h3><p>这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改</p>
<h3 id="Develop-分支-：-开发"><a href="#Develop-分支-：-开发" class="headerlink" title="Develop 分支 ： 开发"></a>Develop 分支 ： 开发</h3><p>这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支</p>
<h3 id="Feature-分支-：-相互独立"><a href="#Feature-分支-：-相互独立" class="headerlink" title="Feature 分支 ： 相互独立"></a>Feature 分支 ： 相互独立</h3><p>这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release</p>
<h3 id="Release分支-：-需求冻结"><a href="#Release分支-：-需求冻结" class="headerlink" title="Release分支 ： 需求冻结"></a>Release分支 ： 需求冻结</h3><p>当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支</p>
<h3 id="Hotfix分支-：-紧急修复"><a href="#Hotfix分支-：-紧急修复" class="headerlink" title="Hotfix分支 ： 紧急修复"></a>Hotfix分支 ： 紧急修复</h3><p>当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_04_15_0.png"
                     
                ></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 查看从某一日期开始变更的文件</title>
    <url>/2024/07/12/Git-%E6%9F%A5%E7%9C%8B%E4%BB%8E%E6%9F%90%E4%B8%80%E6%97%A5%E6%9C%9F%E5%BC%80%E5%A7%8B%E5%8F%98%E6%9B%B4%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>要查看从某一日期开始变更的文件，可以使用 <code>git</code> 命令来列出这些变更。以下是一些常用的 <code>git</code> 命令和方法，用于查看自特定日期以来的文件变更记录。</p>
<h2 id="1-列出从某一日期开始的所有提交记录"><a href="#1-列出从某一日期开始的所有提交记录" class="headerlink" title="1. 列出从某一日期开始的所有提交记录"></a>1. <strong>列出从某一日期开始的所有提交记录</strong></h2><p>首先，你可以使用 <code>git log</code> 命令来列出从某一日期开始的所有提交记录。这些提交记录会包含文件的变更信息。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;YYYY-MM-DD&quot;</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --name-only</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>--since=&quot;YYYY-MM-DD&quot;</code>: 设定起始日期。</li>
<li><code>--pretty=format:&quot;%h %s&quot;</code>: 以提交的简短哈希和提交信息的形式输出日志。</li>
<li><code>--name-only</code>: 仅显示文件名，不显示详细的内容变更。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2024-01-01&quot;</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --name-only</span><br></pre></td></tr></table></figure></div>

<p>这会列出从 2024 年 1 月 1 日以来的所有提交记录，并显示涉及的文件。</p>
<h2 id="2-列出从某一日期开始的文件变更记录"><a href="#2-列出从某一日期开始的文件变更记录" class="headerlink" title="2. 列出从某一日期开始的文件变更记录"></a>2. <strong>列出从某一日期开始的文件变更记录</strong></h2><p>如果你想要查看从某一日期开始每个文件的变更情况，可以使用以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;YYYY-MM-DD&quot;</span> --name-only --pretty=format:<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>--pretty=format:&quot;&quot;</code>: 只显示文件名，不显示提交信息。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2024-01-01&quot;</span> --name-only --pretty=format:<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="3-查看从某一日期开始的每个文件的详细变更信息"><a href="#3-查看从某一日期开始的每个文件的详细变更信息" class="headerlink" title="3. 查看从某一日期开始的每个文件的详细变更信息"></a>3. <strong>查看从某一日期开始的每个文件的详细变更信息</strong></h2><p>如果你想要查看从某一日期开始的每个文件的详细变更信息，可以使用以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;YYYY-MM-DD&quot;</span> --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>--stat</code>: 显示每次提交中修改的文件以及更改的行数。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2024-01-01&quot;</span> --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure></div>

<h2 id="4-查看从某一日期开始的每个文件的变更内容"><a href="#4-查看从某一日期开始的每个文件的变更内容" class="headerlink" title="4. 查看从某一日期开始的每个文件的变更内容"></a>4. <strong>查看从某一日期开始的每个文件的变更内容</strong></h2><p>如果你需要查看从某一日期开始的每个文件的实际变更内容，可以使用以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;YYYY-MM-DD&quot;</span> -p</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>-p</code>: 显示每个提交的差异。</li>
</ul>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2024-01-01&quot;</span> -p</span><br></pre></td></tr></table></figure></div>

<h2 id="5-查看从某一日期开始的所有变更文件及其详细信息"><a href="#5-查看从某一日期开始的所有变更文件及其详细信息" class="headerlink" title="5. 查看从某一日期开始的所有变更文件及其详细信息"></a>5. <strong>查看从某一日期开始的所有变更文件及其详细信息</strong></h2><p>结合 <code>grep</code> 命令，可以筛选出从某一日期开始的文件并查看详细的变更信息：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;YYYY-MM-DD&quot;</span> --name-only | grep -v <span class="string">&#x27;^$&#x27;</span> | xargs -I &#123;&#125; git <span class="built_in">log</span> --since=<span class="string">&quot;YYYY-MM-DD&quot;</span> --oneline -- &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>grep -v &#39;^$&#39;</code>: 去除空行。</li>
<li><code>xargs -I &#123;&#125; git log --since=&quot;YYYY-MM-DD&quot; --oneline -- &#123;&#125;</code>: 对每个文件显示从该日期开始的提交记录。</li>
</ul>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2024-01-01&quot;</span> --name-only | grep -v <span class="string">&#x27;^$&#x27;</span> | xargs -I &#123;&#125; git <span class="built_in">log</span> --since=<span class="string">&quot;2024-01-01&quot;</span> --oneline -- &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="6-列出某一日期之后每个文件的所有变更记录"><a href="#6-列出某一日期之后每个文件的所有变更记录" class="headerlink" title="6. 列出某一日期之后每个文件的所有变更记录"></a>6. <strong>列出某一日期之后每个文件的所有变更记录</strong></h2><p>你可以使用 <code>git diff</code> 命令来比较某一日期之前和之后的所有变更记录：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --name-only $(git rev-list -n 1 --before=<span class="string">&quot;YYYY-MM-DD&quot;</span> master) HEAD</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>$(git rev-list -n 1 --before=&quot;YYYY-MM-DD&quot; master)</code>: 获取指定日期之前的最后一次提交的哈希值。</li>
<li><code>HEAD</code>: 当前最新提交的哈希值。</li>
</ul>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --name-only $(git rev-list -n 1 --before=<span class="string">&quot;2024-01-01&quot;</span> master) HEAD</span><br></pre></td></tr></table></figure></div>

<h2 id="7-查看从某一日期开始的所有文件变更记录（包含每个提交的文件变更内容）"><a href="#7-查看从某一日期开始的所有文件变更记录（包含每个提交的文件变更内容）" class="headerlink" title="7. 查看从某一日期开始的所有文件变更记录（包含每个提交的文件变更内容）"></a>7. <strong>查看从某一日期开始的所有文件变更记录（包含每个提交的文件变更内容）</strong></h2><p>你还可以结合 <code>grep</code> 和 <code>awk</code> 命令来提取从某一日期开始的文件变更记录及其详细内容：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;YYYY-MM-DD&quot;</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --name-only | awk <span class="string">&#x27;NF&#123;print $0&#125;&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2024-01-01&quot;</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --name-only | awk <span class="string">&#x27;NF&#123;print $0&#125;&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a class="link"   href="https://git-scm.com/docs/git-log" >Git log Documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://git-scm.com/docs/git-diff" >Git Diff Documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://git-scm.com/docs/git-rev-list" >Git Rev-list Documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://git-scm.com/docs/git-log#git-log--stat" >Git Log –stat Option<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>通过这些命令，你可以根据需求查看从特定日期开始的文件变更记录，并对其进行深入分析。如果有其他具体需求，可以进一步定制这些命令来满足你的要求。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GitBash设置ll命令</title>
    <url>/2024/06/22/GitBash%E8%AE%BE%E7%BD%AEll%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="GIT-配置-ll命令"><a href="#GIT-配置-ll命令" class="headerlink" title="GIT 配置 ll命令"></a>GIT 配置 ll命令</h1><h2 id="Windows-下"><a href="#Windows-下" class="headerlink" title="Windows 下"></a>Windows 下</h2><h3 id="1-用户目录下"><a href="#1-用户目录下" class="headerlink" title="1 用户目录下"></a>1 用户目录下</h3><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">vi .bashrc</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">alias ll=&#x27;ls -l&#x27;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></div>

<h2 id="Linux-下"><a href="#Linux-下" class="headerlink" title="Linux 下"></a>Linux 下</h2><h3 id="1-编辑-source"><a href="#1-编辑-source" class="headerlink" title="1 编辑 ~&#x2F;.source"></a>1 编辑 ~&#x2F;.source</h3><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">vi ~/.source</span><br><span class="line">alias ll=&#x27;ls -l&#x27;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-生效"><a href="#2-生效" class="headerlink" title="2 生效"></a>2 生效</h3><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GitBash设置时间戳</title>
    <url>/2024/06/24/GitBash%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4%E6%88%B3/</url>
    <content><![CDATA[<blockquote>
<p>平时工作中，可能会同时处理几件事情，其中有一件要用到 <code>terminal</code>，有时候需要在 <code>terminal</code> 连续执行多次同个命令，但有时候你地工作被打断，等再回来看 <code>terminal</code> 的时候，就不确定工作被打断之前是否执行了命令，因为命令执行没有时间戳<br>比如下图，完全看不出来什么时候执行的命令行：</p>
</blockquote>
<h2 id="在命令行执行后面打印"><a href="#在命令行执行后面打印" class="headerlink" title="在命令行执行后面打印"></a>在命令行执行后面打印</h2><p>我的方案是在每行命令行执行结束后，打印一下当前的时间戳。具体方法：</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>用编辑器打开 <code>git-prompt.sh</code> 文件，文件目录在 <code>git</code> 安装目录下（比如我的是 <code>D:\APP\Git\etc\profile.d\git-prompt.sh</code>）。这个文件用于定义打印“命令提示符”。</p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>找到 <code>PS1=&quot;$PS1&quot;&#39;\u@\h &#39; # user@host&lt;space&gt;</code> 这行（图中第 20 行），<br>在这行的上面的第 16 行前面加上时间戳的配置即可。<br>我加了下面的几行，重点是 <code>PS1=&quot;$PS1&quot;&#39;\t&#39;</code> 这个，一定要加上，用于获取当前时间，<br>其他几行是个性化颜色修饰，可有可无。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">PS1=<span class="string">&quot;<span class="variable">$PS1</span>&quot;</span><span class="string">&#x27;\[\033[45m\]&#x27;</span>	<span class="comment"># change to Magenta</span></span><br><span class="line">PS1=<span class="string">&quot;<span class="variable">$PS1</span>&quot;</span><span class="string">&#x27;&gt;&gt;&gt;&#x27;</span>			    <span class="comment"># time</span></span><br><span class="line">PS1=<span class="string">&quot;<span class="variable">$PS1</span>&quot;</span><span class="string">&#x27; \t&#x27;</span>			    <span class="comment"># time</span></span><br><span class="line">PS1=<span class="string">&quot;<span class="variable">$PS1</span>&quot;</span><span class="string">&#x27;\[\033[0m\]&#x27;</span>		<span class="comment"># reset style</span></span><br><span class="line">PS1=<span class="string">&quot;<span class="variable">$PS1</span>&quot;</span><span class="string">&#x27;\n&#x27;</span>			    <span class="comment"># new line</span></span><br></pre></td></tr></table></figure></div>

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/git/git1.png"
                      alt="配置"
                ><figcaption>配置</figcaption></figure></p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/git/git2.png"
                      alt="效果图"
                ><figcaption>效果图</figcaption></figure></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="ANSI-颜色编码"><a href="#ANSI-颜色编码" class="headerlink" title="ANSI 颜色编码"></a>ANSI 颜色编码</h3><ul>
<li>ANSI 颜色编码可参考 <a class="link"   href="https://en.wikipedia.org/wiki/ANSI_escape_code" >ANSI escape code - Wikipedia<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>ANSI 控制码<br>  ANSI 控制码以Esc 作为控制码的开始标志。 Esc的ANS十进制码是 27 ， 八进制码是33， 使用\33 表示。主要的控制码有：</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">\033[0m 关闭所有属性</span><br><span class="line">\033[1m 设置高亮度</span><br><span class="line">\033[4m 下划线</span><br><span class="line">\033[5m 闪烁 ， 测试在在linux 显示效果是底色。</span><br><span class="line">\033[7m 反显</span><br><span class="line">\033[8m 消隐</span><br><span class="line">\033[nA 光标上移n行</span><br><span class="line">\033[nB 光标下移n行</span><br><span class="line">\033[nC 光标右移n行</span><br><span class="line">\033[nD 光标左移n行</span><br><span class="line">\033[y;xH 设置光标位置</span><br><span class="line">\033[2J 清屏</span><br><span class="line">\033[K 清除从光标到行尾的内容</span><br><span class="line">\033[s 保存光标位置</span><br><span class="line">\033[u 恢复光标位置</span><br><span class="line">\033[?25l 隐藏光标</span><br><span class="line">\033[?25h 显示光标</span><br><span class="line">\033[30m ~ \033[37m 设置前景色</span><br><span class="line">\033[40m ~ \033[47m 设置背景色</span><br></pre></td></tr></table></figure></div>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/536955408" >如何设置 Git Bash 终端命令行执行后打印当前时间<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/weixin_69553582/article/details/125700943" >在终端输出彩色字体<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 配置多端多个账号</title>
    <url>/2024/06/26/Git-%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%AB%AF%E5%A4%9A%E4%B8%AA%E8%B4%A6%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="清空默认的全局-user-name-和-user-email"><a href="#清空默认的全局-user-name-和-user-email" class="headerlink" title="清空默认的全局 user.name 和 user.email"></a>清空默认的全局 user.name 和 user.email</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --global --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure></div>

<p>查看git配置</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure></div>

<h2 id="配置多个git的用户名和邮箱"><a href="#配置多个git的用户名和邮箱" class="headerlink" title="配置多个git的用户名和邮箱"></a>配置多个git的用户名和邮箱</h2><ol>
<li>单个全局配置</li>
</ol>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourusername&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail@email.com&quot;</span></span><br></pre></td></tr></table></figure></div>
<ol start="2">
<li>多个配置</li>
</ol>
<blockquote>
<p>注意: 这里<code>git config</code>命令没有带<code>—global</code>,表示这是一个局部的设置,也就是这个用户是当前项目的,而不是全局的</p>
</blockquote>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git config user.name <span class="string">&quot;yourusername&quot;</span></span><br><span class="line">git config user.email <span class="string">&quot;youremail@hotmail.com&quot;</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>删除配置</li>
</ol>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git config --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure></div>

<h2 id="生成多个密钥"><a href="#生成多个密钥" class="headerlink" title="生成多个密钥"></a>生成多个密钥</h2><ol>
<li>生成<code>gitlab</code>仓库的SSH</li>
</ol>
<p>指定文件路径,方便后面操作:<code>~/.ssh/id_rsa.gitlab</code>,<code>id_rsa.github</code>是秘钥的别名。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitlab -C <span class="string">&quot;gitlab@mail.com&quot;</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>生成<code>github</code>仓库的SSH</li>
</ol>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C <span class="string">&quot;github@mail.com&quot;</span></span><br></pre></td></tr></table></figure></div>
<ol start="3">
<li>将 <code>ssh-key</code> 分别添加到 <code>ssh-agent</code> 信任列表</li>
</ol>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-add ~/.ssh/id_rsa.gitlab</span><br><span class="line">ssh-add ~/.ssh/id_rsa.github</span><br></pre></td></tr></table></figure></div>
<p>如果看到 <code>Identitiy added: ~/.ssh/id_ras_github</code> 就表示添加成功了。</p>
<ol start="4">
<li><p>添加公钥到自己的 git 账户中</p>
</li>
<li><p>在 config 文件配置多个 ssh-key<br>在生成密钥的<code>.ssh</code> 目录下,新建一个<code>config</code>文件,然后配置不同的仓库</p>
</li>
</ol>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Default github user Self</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git <span class="comment">#默认就是git,可以不写</span></span><br><span class="line">    IdentityFile ~/.ssh/id_rsa.github</span><br><span class="line"></span><br><span class="line"><span class="comment">#Add gitlab user </span></span><br><span class="line">Host gitlab.com  <span class="comment"># 别名,最好别改</span></span><br><span class="line">    HostName gitlab.com</span><br><span class="line">    User xxx@mail.com <span class="comment">#用户名</span></span><br><span class="line">	<span class="comment">#密钥文件的地址,注意是私钥</span></span><br><span class="line">	IdentityFile ~/.ssh/id_rsa_gitlab</span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li>测试<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GitBash如何显示中文</title>
    <url>/2024/06/22/GitBash%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<h1 id="git-bash如何显示中文"><a href="#git-bash如何显示中文" class="headerlink" title="git bash如何显示中文"></a>git bash如何显示中文</h1><p>要在Git Bash中正确显示中文，您可以按照以下步骤操作：</p>
<ol>
<li>确认已经安装了支持中文的字体<br>在Git Bash中显示中文需要正确的字体支持。在Windows操作系统上，默认的字体一般已经支持中文，不需要额外操作。如果您遇到了乱码问题，可以尝试更改默认字体。</li>
<li>更改Git Bash的字符集设置<br>在Git Bash中，可以通过更改字符集设置来正确显示中文字符。以下是具体的操作步骤：<br>– 打开Git Bash。<br>– 点击窗口左上角的图标，选择<code>Options</code>。<br>– 在<code>Options</code>窗口中，选择<code>Text</code>选项卡。<br>– 在<code>Text</code>选项卡中，将<code>Character set</code>设置为<code>UTF-8</code>。<br>– 点击<code>OK</code>保存设置并关闭窗口。<br>– 重新启动Git Bash，查看中文是否显示正确。</li>
<li>设置Git Bash的locale环境变量<br>在某些情况下，Git Bash可能会忽略系统的locale设置，导致无法正确显示中文。您可以设置Git Bash的locale环境变量来解决这个问题。以下是具体的操作步骤：<br>– 打开Git Bash。<br>– 执行以下命令：  <div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">export LANG=zh_CN.UTF-8</span><br></pre></td></tr></table></figure></div>
– 重新启动Git Bash，查看中文是否显示正确。<br>请注意，对于Windows系统来说，Git Bash完全可以正常显示中文，这些步骤一般只在遇到问题时才需要进行操作。如果您按照上述方法仍然无法正确显示中文，请检查系统字体和其他设置是否正常，并确保系统区域设置中的语言设置为中文。</li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go run 或 build 运行很慢或超时</title>
    <url>/2024/07/01/Go-run-%E6%88%96-build-%E8%BF%90%E8%A1%8C%E5%BE%88%E6%85%A2%E6%88%96%E8%B6%85%E6%97%B6/</url>
    <content><![CDATA[<h2 id="Step-1-查看环境变量"><a href="#Step-1-查看环境变量" class="headerlink" title="Step 1 查看环境变量"></a>Step 1 查看环境变量</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">GOOS=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line">GOPATH=<span class="string">&#x27;/root/go&#x27;</span></span><br><span class="line">GOPRIVATE=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 这里镜像问题</span></span><br><span class="line">GOPROXY=<span class="string">&#x27;https://proxy.golang.org,direct&#x27;</span></span><br><span class="line">GOROOT=<span class="string">&#x27;/usr/local/go&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Step-2-修改镜像地址"><a href="#Step-2-修改镜像地址" class="headerlink" title="Step 2 修改镜像地址"></a>Step 2 修改镜像地址</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=http://mirrors.aliyun.com/goproxy/</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>-w</code> 标记 要求一个或多个形式为 <code>NAME=VALUE</code> 的参数, 并且覆盖默认的设置</p>
</blockquote>
]]></content>
      <categories>
        <category>Program</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 环境变量配置</title>
    <url>/2024/07/01/Go-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="获取安装包"><a href="#获取安装包" class="headerlink" title="获取安装包"></a>获取安装包</h2><p><code>https://golang.org/dl/</code> 官网获取最新安装包</p>
<h2 id="Step-1-下载"><a href="#Step-1-下载" class="headerlink" title="Step 1 下载"></a>Step 1 下载</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://go.dev/dl/go1.22.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></div>

<h2 id="Step-2-解压"><a href="#Step-2-解压" class="headerlink" title="Step 2 解压"></a>Step 2 解压</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">tar -C /usr/local -zxvf go1.22.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></div>

<h2 id="Step-3-环境变量配置"><a href="#Step-3-环境变量配置" class="headerlink" title="Step 3 环境变量配置"></a>Step 3 环境变量配置</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在/etc/profile最后一行添加</span></span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存退出后source一下（vi 的使用方法可以自己搜索一下）</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></div>

<h2 id="Step-4-验证"><a href="#Step-4-验证" class="headerlink" title="Step 4 验证"></a>Step 4 验证</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Program</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP status code</title>
    <url>/2024/07/03/HTTP-status-code/</url>
    <content><![CDATA[<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/http_status_code.jpg"
                      alt="status code"
                ><figcaption>status code</figcaption></figure></p>
]]></content>
      <categories>
        <category>Program</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea Maven 新项目永久生效</title>
    <url>/2024/06/25/Idea-Maven-%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%B0%B8%E4%B9%85%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<blockquote>
<p>不同版本Idea会有差异</p>
</blockquote>
<div class="tabs" id="tab-setup版本"><ul class="nav-tabs"><li class="tab active"><a class="#setup版本-1">新版Idea</a></li><li class="tab"><a class="#setup版本-2">旧版Idea</a></li></ul><div class="tab-content"><div class="tab-pane active" id="setup版本-1"><p>新版 <code>File</code> -&gt; <code>New Projects Setup</code> -&gt; <code>Settings for New Projects</code><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/maven/new-version-maven.png"
                      alt="New Setup"
                ><figcaption>New Setup</figcaption></figure></p></div><div class="tab-pane" id="setup版本-2"><p>旧版 <code>File</code> -&gt; <code>Other Settings</code> -&gt; <code>Settings for New Projects</code></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/maven/old-version-maven.png"
                      alt="Old Setup"
                ><figcaption>Old Setup</figcaption></figure></p></div></div></div>

<p>搜索 <code>mvn</code> 或 <code>Build, Execution, Deployment</code> -&gt; <code>Build Tools</code> -&gt; <code>Maven</code><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/maven/maven-settings.png"
                      alt="Settings"
                ><figcaption>Settings</figcaption></figure></p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Env</tag>
        <tag>Maven</tag>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title>JSSDK 微信接口与 Java 结合</title>
    <url>/2017/02/22/JSSDK-%E5%BE%AE%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%B8%8E-Java-%E7%BB%93%E5%90%88/</url>
    <content><![CDATA[<h1 id="JSSDK微信接口-Java接入-转发分享信息"><a href="#JSSDK微信接口-Java接入-转发分享信息" class="headerlink" title="JSSDK微信接口 Java接入 转发分享信息"></a>JSSDK微信接口 Java接入 转发分享信息</h1><hr>
<blockquote>
<p><a class="link"   href="http://dwz.cn/1KsMyS"  target="_blank"> [ JSSDK文档 ]<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 微信JS-SDK是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包。   </p>
<p><a class="link"   href="http://dwz.cn/3WfAJS"  target="_blank">  [获取token文档 ]<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> JS-SDK获取access_token文档<br><strong>ChaoS_Zhang</strong> , 更多信息 , 具体请参考<a class="link"   href="https://github.com/ChaoSBYNN" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.<a href="#"> [t7_chaos@163.com]</a>  .</p>
</blockquote>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><blockquote>
<p>流程图：</p>
</blockquote>
<pre class="mermaid">flowchart LR
st=>start: 开始
e=>end: 结束
op1=>operation: 获取本地存储token
op2=>operation: 通过微信公众号 
                appid与secret 
                获取新的access_token
op3=>operation: 获取jsapi_ticket
cond1=>condition: 判断最近修改日期
是否不超过7200秒？
cond2=>condition: 判断获取的
                jsapi_ticket是否正常
                [异常情况:token过期]
st->op1->cond1->op3->cond2->e
op2->op3
cond1(no)->op2
cond1(yes)->op3
cond2(no)->op2
cond2(yes)->e</pre>


<blockquote>
<p><strong>注意：</strong>临界值操作，<strong>临界值时虽然没有超过7200秒,但是token已经过期,需要重新获取</strong>。</p>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><blockquote>
<h3 id="WXTokenServiceImpl-业务逻辑"><a href="#WXTokenServiceImpl-业务逻辑" class="headerlink" title="WXTokenServiceImpl 业务逻辑"></a>WXTokenServiceImpl 业务逻辑</h3></blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Formatter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.listenlives.dao.WXTokenDao;</span><br><span class="line"><span class="keyword">import</span> com.listenlives.domain.WXToken;</span><br><span class="line"><span class="keyword">import</span> com.listenlives.information.util.HttpHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ChaoS_Zhang t7_chaos@163.com </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2016年8月12日 上午11:00:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  获取微信公众号有效期7200m access_token &lt;br/&gt;二次转发分享页面</span></span><br><span class="line"><span class="comment"> * &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> http://dwz.cn/1KsMyS 微信JS-SDK说明文档&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;static-access&quot;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WXTokenServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * toekn持久化</span></span><br><span class="line"><span class="comment">	 * updateWXToken(WXToken wxToken) 更新本地token&lt;br/&gt;</span></span><br><span class="line"><span class="comment">	 * selectWXToken() 获取本地token</span></span><br><span class="line"><span class="comment">	 * /</span></span><br><span class="line"><span class="comment">	@Resource</span></span><br><span class="line"><span class="comment">	private WXTokenDao wxTokenDao;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	public Map&lt;String, String&gt; getJSAPITicket(String url) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		Map&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		/*</span></span><br><span class="line"><span class="comment">		 * 微信接口所需返回项</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">nonce_str</span> <span class="operator">=</span> create_nonce_str();</span><br><span class="line">		<span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> create_timestamp();</span><br><span class="line">		<span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">jsapiTicket</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">assceeToken</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">WXToken</span> <span class="variable">wxToken</span> <span class="operator">=</span> wxTokenDao.selectWXToken();</span><br><span class="line"></span><br><span class="line">			assceeToken = wxToken.getAccessToken();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (compareWithExpiresIn(wxToken.getCreateTime())) &#123;</span><br><span class="line"></span><br><span class="line">				assceeToken = getNewAccessToken();</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			jsapiTicket = getNewJSAPITicket(assceeToken, <span class="number">0</span>).get(<span class="string">&quot;ticket&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 当前分享页面url </span></span><br><span class="line"><span class="comment">			 * 注意这里参数名必须全部小写,且必须有序&#x27;&#x27;&#x27;微信要求&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			signature = <span class="string">&quot;jsapi_ticket=&quot;</span> + jsapiTicket + </span><br><span class="line">								<span class="string">&quot;&amp;noncestr=&quot;</span> + nonce_str + </span><br><span class="line">								<span class="string">&quot;&amp;timestamp=&quot;</span> + timestamp + </span><br><span class="line">								<span class="string">&quot;&amp;url=&quot;</span> + url;</span><br><span class="line"></span><br><span class="line">			<span class="type">MessageDigest</span> <span class="variable">crypt</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">			crypt.reset();</span><br><span class="line">			crypt.update(signature.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">			signature = byteToHex(crypt.digest());</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		resultMap.put(<span class="string">&quot;url&quot;</span>, url);</span><br><span class="line">		resultMap.put(<span class="string">&quot;nonceStr&quot;</span>, nonce_str);</span><br><span class="line">		resultMap.put(<span class="string">&quot;timestamp&quot;</span>, timestamp);</span><br><span class="line">		resultMap.put(<span class="string">&quot;signature&quot;</span>, signature);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> resultMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>: 比较当前时间与上一次获取Token时间是否相差2小时 有效期7200秒</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> http://dwz.cn/3WfAJS 微信JSSDK access_token文档&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareWithExpiresIn</span><span class="params">(String createTime)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Date nowDate;</span><br><span class="line">		Date tokenDate;</span><br><span class="line">		<span class="type">long</span> diff;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			nowDate = df.parse(df.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">			tokenDate = df.parse(createTime);</span><br><span class="line">			</span><br><span class="line">			diff = nowDate.getTime() - tokenDate.getTime();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 微信2小时 7200m 变更token</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			flag = diff &gt; <span class="number">7200000</span>;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToHex</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] hash)</span> &#123;</span><br><span class="line">		<span class="type">Formatter</span> <span class="variable">formatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Formatter</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">byte</span> b : hash) &#123;</span><br><span class="line">			formatter.format(<span class="string">&quot;%02x&quot;</span>, b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> formatter.toString();</span><br><span class="line">		formatter.close();</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>: 生成签名的随机串</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">create_nonce_str</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>: 生成签名的时间戳</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">create_timestamp</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Long.toString(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getNewAccessToken</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Map&lt;String, String&gt; accessMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">			accessMap.put(<span class="string">&quot;grant_type&quot;</span>, <span class="string">&quot;client_credential&quot;</span>);</span><br><span class="line">			accessMap.put(<span class="string">&quot;appid&quot;</span>, $&#123;appid&#125;);</span><br><span class="line">			accessMap.put(<span class="string">&quot;secret&quot;</span>, $&#123;secret&#125;);</span><br><span class="line">			data = HttpHelper.post(accessMap, url);</span><br><span class="line">			<span class="keyword">if</span> (data != <span class="literal">null</span> &amp;&amp; data != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">				<span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>().fromObject(data);</span><br><span class="line">				<span class="type">String</span> <span class="variable">access_token</span> <span class="operator">=</span> (String) json.get(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (<span class="literal">null</span> != access_token &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(access_token)) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="type">WXToken</span> <span class="variable">wxToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WXToken</span>();</span><br><span class="line">					wxToken.setAccessToken(access_token);</span><br><span class="line">					wxTokenDao.updateWXToken(wxToken);</span><br><span class="line"></span><br><span class="line">					result = access_token;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getNewJSAPITicket</span><span class="params">(String accessToken, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 避免死循环递归flag</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (flag &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://api.weixin.qq.com/cgi-bin/ticket/getticket&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		Map&lt;String, Object&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			Map&lt;String, String&gt; accessMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">			accessMap.put(<span class="string">&quot;access_token&quot;</span>, accessToken);</span><br><span class="line">			accessMap.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;jsapi&quot;</span>);</span><br><span class="line">		</span><br><span class="line">			data = HttpHelper.post(accessMap, url);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (data != <span class="literal">null</span> &amp;&amp; data != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>().fromObject(data);</span><br><span class="line">				<span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> (String) json.get(<span class="string">&quot;ticket&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (<span class="literal">null</span> != ticket &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(ticket)) &#123;</span><br><span class="line">					resultMap.put(<span class="string">&quot;ticket&quot;</span>, ticket);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					resultMap = getNewJSAPITicket(getNewAccessToken(), flag + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resultMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<blockquote>
<h3 id="WXToken-微信公众号token实体"><a href="#WXToken-微信公众号token实体" class="headerlink" title="WXToken 微信公众号token实体"></a>WXToken 微信公众号token实体</h3></blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> ChaoS_Zhang t7_chaos@163.com </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2016年8月12日 上午10:55:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WXToken</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String accessToken;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String createTime;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getAccessToken</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> accessToken;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessToken</span><span class="params">(String accessToken)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.accessToken = accessToken;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> createTime;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(String createTime)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<hr>
]]></content>
      <tags>
        <tag>WeChat</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Thread.sleep(0)</title>
    <url>/2024/07/19/Java-Thread-sleep-0/</url>
    <content><![CDATA[<p><code>Thread.sleep(0)</code> 在 Java 中是一个非常简单的操作，但它的行为和用途可能不是非常直观。以下是对 <code>Thread.sleep(0)</code> 的详细解释、实际效果、使用场景以及其他相关技术的介绍。</p>
<h2 id="1-Thread-sleep-0-的基本介绍"><a href="#1-Thread-sleep-0-的基本介绍" class="headerlink" title="1. Thread.sleep(0) 的基本介绍"></a>1. <code>Thread.sleep(0)</code> 的基本介绍</h2><p>在 Java 中，<code>Thread.sleep(millis)</code> 是一个静态方法，用于暂停当前线程的执行。<code>millis</code> 参数表示暂停的时间长度，以毫秒为单位。</p>
<h3 id="Thread-sleep-0-的基本语法"><a href="#Thread-sleep-0-的基本语法" class="headerlink" title="Thread.sleep(0) 的基本语法"></a><code>Thread.sleep(0)</code> 的基本语法</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure></div>

<h2 id="2-Thread-sleep-0-的实际效果"><a href="#2-Thread-sleep-0-的实际效果" class="headerlink" title="2. Thread.sleep(0) 的实际效果"></a>2. <code>Thread.sleep(0)</code> 的实际效果</h2><p>调用 <code>Thread.sleep(0)</code> 会将当前线程挂起 0 毫秒。虽然这看起来什么也没做，但实际上它有几个重要的效果：</p>
<h3 id="2-1-切换到其他线程"><a href="#2-1-切换到其他线程" class="headerlink" title="2.1 切换到其他线程"></a>2.1 切换到其他线程</h3><p>当 <code>Thread.sleep(0)</code> 被调用时，当前线程会将 CPU 的控制权交还给线程调度器。这意味着：</p>
<ul>
<li>当前线程会让位于就绪队列中的其他线程有机会运行。</li>
<li>它可以帮助提高线程之间的公平性，使得其他线程有机会获得 CPU 时间。</li>
</ul>
<h3 id="2-2-触发线程调度"><a href="#2-2-触发线程调度" class="headerlink" title="2.2 触发线程调度"></a>2.2 触发线程调度</h3><p><code>Thread.sleep(0)</code> 可以被视为一种显式的方式来触发线程调度，从而实现对线程调度行为的微调。</p>
<h3 id="2-3-Thread-sleep-0-的实际时间延迟"><a href="#2-3-Thread-sleep-0-的实际时间延迟" class="headerlink" title="2.3 Thread.sleep(0) 的实际时间延迟"></a>2.3 <code>Thread.sleep(0)</code> 的实际时间延迟</h3><p>虽然调用 <code>Thread.sleep(0)</code> 意味着挂起时间为 0 毫秒，但由于操作系统的调度机制和线程的状态，实际的时间延迟可能不为 0。</p>
<h3 id="2-4-与-yield-方法的比较"><a href="#2-4-与-yield-方法的比较" class="headerlink" title="2.4 与 yield() 方法的比较"></a>2.4 与 <code>yield()</code> 方法的比较</h3><p><code>Thread.sleep(0)</code> 和 <code>Thread.yield()</code> 具有类似的效果，都会让当前线程让出 CPU 时间。但它们之间有一些微妙的差别：</p>
<ul>
<li><code>Thread.yield()</code>：只是建议线程调度器让出 CPU 时间，可能会忽略这个建议。</li>
<li><code>Thread.sleep(0)</code>：明确地请求将线程挂起，虽然挂起时间为 0，但仍会让出 CPU 时间。</li>
</ul>
<h2 id="3-Thread-sleep-0-的使用场景"><a href="#3-Thread-sleep-0-的使用场景" class="headerlink" title="3. Thread.sleep(0) 的使用场景"></a>3. <code>Thread.sleep(0)</code> 的使用场景</h2><p>虽然 <code>Thread.sleep(0)</code> 不是一个常用的工具，但在某些场景下，它可以提供帮助：</p>
<h3 id="3-1-实现公平性"><a href="#3-1-实现公平性" class="headerlink" title="3.1 实现公平性"></a>3.1 <strong>实现公平性</strong></h3><p>在多线程环境中，<code>Thread.sleep(0)</code> 可以用来实现线程的公平性，确保所有线程都有机会运行。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairThreadExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">0</span>); <span class="comment">// 让其他线程有机会执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2-帮助调试"><a href="#3-2-帮助调试" class="headerlink" title="3.2 帮助调试"></a>3.2 <strong>帮助调试</strong></h3><p>在调试程序时，<code>Thread.sleep(0)</code> 可以用来观察线程调度的行为，以了解多线程环境中的状态和性能。</p>
<h3 id="3-3-实现自旋锁"><a href="#3-3-实现自旋锁" class="headerlink" title="3.3 实现自旋锁"></a>3.3 <strong>实现自旋锁</strong></h3><p>在某些高级编程技术中，<code>Thread.sleep(0)</code> 可能用于实现自旋锁和其他线程调度技术。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (locked) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">0</span>); <span class="comment">// 提供时间片给其他线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        locked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="4-Thread-sleep-0-的限制和注意事项"><a href="#4-Thread-sleep-0-的限制和注意事项" class="headerlink" title="4. Thread.sleep(0) 的限制和注意事项"></a>4. <code>Thread.sleep(0)</code> 的限制和注意事项</h2><h3 id="4-1-线程调度的可靠性"><a href="#4-1-线程调度的可靠性" class="headerlink" title="4.1 线程调度的可靠性"></a>4.1 <strong>线程调度的可靠性</strong></h3><p><code>Thread.sleep(0)</code> 只是对线程调度的建议，线程调度器可能会忽略这个建议。</p>
<h3 id="4-2-使用-sleep-代替-yield"><a href="#4-2-使用-sleep-代替-yield" class="headerlink" title="4.2 使用 sleep() 代替 yield()"></a>4.2 <strong>使用 <code>sleep()</code> 代替 <code>yield()</code></strong></h3><p>尽管 <code>Thread.sleep(0)</code> 和 <code>Thread.yield()</code> 可以用来让线程调度，<code>Thread.yield()</code> 更为语义明确，并且被设计为让当前线程让出 CPU 时间。</p>
<h3 id="4-3-对性能的影响"><a href="#4-3-对性能的影响" class="headerlink" title="4.3 对性能的影响"></a>4.3 <strong>对性能的影响</strong></h3><p>过度使用 <code>Thread.sleep(0)</code> 可能对性能产生负面影响，因为它会增加线程上下文切换的频率。</p>
<h2 id="5-相关技术和替代方法"><a href="#5-相关技术和替代方法" class="headerlink" title="5. 相关技术和替代方法"></a>5. 相关技术和替代方法</h2><h3 id="5-1-Thread-yield"><a href="#5-1-Thread-yield" class="headerlink" title="5.1 Thread.yield()"></a>5.1 <code>Thread.yield()</code></h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Thread.<span class="keyword">yield</span>();</span><br></pre></td></tr></table></figure></div>

<p><code>Thread.yield()</code> 是一个让当前线程让出 CPU 时间的推荐方式，但它是一个“建议”，调度器可能会忽略这个建议。</p>
<h3 id="5-2-Thread-sleep-millis"><a href="#5-2-Thread-sleep-millis" class="headerlink" title="5.2 Thread.sleep(millis)"></a>5.2 <code>Thread.sleep(millis)</code></h3><p>对于需要实际挂起线程的场景，使用 <code>Thread.sleep(millis)</code> 会更合适。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>); <span class="comment">// 挂起线程 1 秒</span></span><br></pre></td></tr></table></figure></div>

<h3 id="5-3-LockSupport-parkNanos"><a href="#5-3-LockSupport-parkNanos" class="headerlink" title="5.3 LockSupport.parkNanos()"></a>5.3 <code>LockSupport.parkNanos()</code></h3><p><code>LockSupport.parkNanos(0)</code> 可以用来提供更精细的线程调度控制。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">LockSupport.parkNanos(<span class="number">0</span>); <span class="comment">// 挂起线程 0 纳秒</span></span><br></pre></td></tr></table></figure></div>

<h3 id="5-4-Executors-框架"><a href="#5-4-Executors-框架" class="headerlink" title="5.4 Executors 框架"></a>5.4 <code>Executors</code> 框架</h3><p>对于复杂的线程管理，考虑使用 <code>Executors</code> 框架来管理线程池和任务队列。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 任务代码</span></span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure></div>

<h2 id="6-参考文档"><a href="#6-参考文档" class="headerlink" title="6. 参考文档"></a>6. 参考文档</h2><table>
<thead>
<tr>
<th>资源</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td><a class="link"   href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#sleep-long-" >Java Thread.sleep() 方法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
<td>官方文档</td>
</tr>
<tr>
<td><a class="link"   href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#yield--" >Java Thread.yield() 方法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
<td>官方文档</td>
</tr>
<tr>
<td><a class="link"   href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html#parkNanos-long-" >Java LockSupport.parkNanos() 方法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
<td>官方文档</td>
</tr>
<tr>
<td><a class="link"   href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html" >Java Executors 框架<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
<td>官方文档</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java ThreadPoolTaskExecutor 线程池</title>
    <url>/2025/12/26/Java-ThreadPoolTaskExecutor-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><blockquote>
<p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</blockquote>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><ul>
<li>方式一 : 通过 <code>ThreadPoolExecutor</code> 构造函数实现</li>
<li>方式二 : 通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来实现</li>
</ul>
<h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><blockquote>
<p>线程池的构造函数有7个参数，分别是<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>keepAliveTime</code>、<code>unit</code>、<code>workQueue</code>、<code>threadFactory</code>、<code>handler</code>。</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// java.util.concurrent.ThreadPoolExecutor 类</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                             <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                             TimeUnit unit,</span></span><br><span class="line"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                             ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                             RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 实现</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolExecutor <span class="title function_">getLessonAnalysisPool</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (lessonAnalysisPool == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (ThreadPoolExecutorUtil.class) &#123;</span><br><span class="line">               <span class="keyword">if</span> (lessonAnalysisPool == <span class="literal">null</span>) &#123;</span><br><span class="line">                   lessonAnalysisPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">                           TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>),</span><br><span class="line">                           r -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;lesson-analysis-pool-%d&quot;</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> lessonAnalysisPool;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><code>corePoolSize</code> 线程池核心线程大小 : 线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。</li>
<li><code>maximumPoolSize</code> 线程池最大线程数量 : 当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。</li>
<li><code>keepAliveTime</code> 空闲线程存活时间 : 一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定</li>
<li><code>unit</code> 空闲线程存活时间单位 : keepAliveTime的计量单位</li>
<li><code>workQueue</code> 工作队列 : 新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：<ol>
<li><code>ArrayBlockingQueue</code> : 基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</li>
<li><code>LinkedBlockingQuene</code> : 基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</li>
<li><code>SynchronousQuene</code> : 一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</li>
<li><code>PriorityBlockingQueue</code> : 具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</li>
</ol>
</li>
<li><code>threadFactory</code> 线程工厂 : 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>
<li><code>handler</code> 拒绝策略 : 当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：<ol>
<li><code>CallerRunsPolicy</code> : 该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that runs the rejected task</span></span><br><span class="line"><span class="comment"> * directly in the calling thread of the &#123;<span class="doctag">@code</span> execute&#125; method,</span></span><br><span class="line"><span class="comment"> * unless the executor has been shut down, in which case the task</span></span><br><span class="line"><span class="comment"> * is discarded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CallerRunsPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes task r in the caller&#x27;s thread, unless the executor</span></span><br><span class="line"><span class="comment">     * has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><code>AbortPolicy</code> : 该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that throws a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> RejectedExecutionException&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbortPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                             <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><code>DiscardPolicy</code> : 该策略下，直接丢弃任务，什么都不做。<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that silently discards the</span></span><br><span class="line"><span class="comment"> * rejected task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DiscardPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Does nothing, which has the effect of discarding task r.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><code>DiscardOldestPolicy</code> : 该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class="line"><span class="comment"> * request and then retries &#123;<span class="doctag">@code</span> execute&#125;, unless the executor</span></span><br><span class="line"><span class="comment"> * is shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DiscardOldestPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Obtains and ignores the next task that the executor</span></span><br><span class="line"><span class="comment">     * would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">     * and then retries execution of task r, unless the executor</span></span><br><span class="line"><span class="comment">     * is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ol>
<hr>
<ul>
<li><code>FixedThreadPool</code> : 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><code>SingleThreadExecutor</code> : 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><code>CachedThreadPool</code> : 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<blockquote>
<p>避免使用Executors 类的 newFixedThreadPool 和 newCachedThreadPool ，因为可能会有 OOM 的风险。</p>
</blockquote>
<p>Executors 返回线程池对象的弊端如下:</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li>
<li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
        <tag>Executor</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 创建对象方式</title>
    <url>/2024/07/18/Java-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在 Java 中，创建对象有多种方式。以下是详细的介绍，涵盖了所有主要的对象创建方式及其适用场景。</p>
<h2 id="1-使用-new-关键字"><a href="#1-使用-new-关键字" class="headerlink" title="1. 使用 new 关键字"></a>1. 使用 <em>new</em> 关键字</h2><h3 id="直接创建对象"><a href="#直接创建对象" class="headerlink" title="直接创建对象"></a>直接创建对象</h3><p>最常见的创建对象方式是使用 <code>new</code> 关键字来调用类的构造函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure></div>

<h3 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a>带参数的构造函数</h3><p>可以在创建对象时传递参数给构造函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="多重构造函数"><a href="#多重构造函数" class="headerlink" title="多重构造函数"></a>多重构造函数</h3><p>一个类可以有多个构造函数，这些构造函数可以有不同的参数列表。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-使用-clone-方法"><a href="#2-使用-clone-方法" class="headerlink" title="2. 使用 clone() 方法"></a>2. 使用 <em>clone()</em> 方法</h2><h3 id="clone-克隆对象"><a href="#clone-克隆对象" class="headerlink" title="clone() 克隆对象"></a><code>clone()</code> 克隆对象</h3><p><code>clone()</code> 方法是 <code>Object</code> 类提供的一个方法，可以用来复制现有的对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">originalPerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">clonedPerson</span> <span class="operator">=</span> (Person) originalPerson.clone();</span><br></pre></td></tr></table></figure></div>

<h3 id="实现-Cloneable-接口"><a href="#实现-Cloneable-接口" class="headerlink" title="实现 Cloneable 接口"></a>实现 <code>Cloneable</code> 接口</h3><p>要使用 <code>clone()</code> 方法，需要实现 <code>Cloneable</code> 接口并重写 <code>clone()</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-使用反射机制"><a href="#3-使用反射机制" class="headerlink" title="3. 使用反射机制"></a>3. 使用反射机制</h2><h3 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h3><p>反射可以动态地创建对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) clazz.getConstructor().newInstance();</span><br></pre></td></tr></table></figure></div>

<h3 id="使用构造函数反射"><a href="#使用构造函数反射" class="headerlink" title="使用构造函数反射"></a>使用构造函数反射</h3><p>可以通过反射调用带参数的构造函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="4-使用工厂方法模式"><a href="#4-使用工厂方法模式" class="headerlink" title="4. 使用工厂方法模式"></a>4. 使用工厂方法模式</h2><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>工厂方法是一种设计模式，通过工厂类来创建对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">createPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用工厂方法创建对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> PersonFactory.createPerson(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="5-使用建造者模式"><a href="#5-使用建造者模式" class="headerlink" title="5. 使用建造者模式"></a>5. 使用建造者模式</h2><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式允许一步步地构建复杂对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = builder.name;</span><br><span class="line">        <span class="built_in">this</span>.age = builder.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Person <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用建造者模式创建对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Builder().setName(<span class="string">&quot;John&quot;</span>).setAge(<span class="number">30</span>).build();</span><br></pre></td></tr></table></figure></div>

<h2 id="6-使用-java-util-Optional-创建对象"><a href="#6-使用-java-util-Optional-创建对象" class="headerlink" title="6. 使用 java.util.Optional 创建对象"></a>6. 使用 <em>java.util.Optional</em> 创建对象</h2><h3 id="使用-Optional-of-或-Optional-ofNullable"><a href="#使用-Optional-of-或-Optional-ofNullable" class="headerlink" title="使用 Optional.of() 或 Optional.ofNullable()"></a>使用 <code>Optional.of()</code> 或 <code>Optional.ofNullable()</code></h3><p><code>Optional</code> 是一个容器对象，用于表示一个可能为 <code>null</code> 的值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Person&gt; optionalPerson = Optional.of(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>));</span><br><span class="line">Optional&lt;Person&gt; optionalPersonNull = Optional.ofNullable(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="7-使用-Java-8-的-Lambda-表达式"><a href="#7-使用-Java-8-的-Lambda-表达式" class="headerlink" title="7. 使用 Java 8 的 Lambda 表达式"></a>7. 使用 Java 8 的 Lambda 表达式</h2><h3 id="Lambda-表达式创建对象"><a href="#Lambda-表达式创建对象" class="headerlink" title="Lambda 表达式创建对象"></a>Lambda 表达式创建对象</h3><p>Lambda 表达式用于简化函数式接口的实例化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = () -&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personSupplier.get();</span><br></pre></td></tr></table></figure></div>

<h2 id="8-使用-ObjectFactory-类"><a href="#8-使用-ObjectFactory-类" class="headerlink" title="8. 使用 ObjectFactory 类"></a>8. 使用 <em>ObjectFactory</em> 类</h2><h3 id="自定义工厂类"><a href="#自定义工厂类" class="headerlink" title="自定义工厂类"></a>自定义工厂类</h3><p>你可以创建一个工厂类来负责对象的创建。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">createPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用工厂类创建对象"><a href="#使用工厂类创建对象" class="headerlink" title="使用工厂类创建对象"></a>使用工厂类创建对象</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PersonFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonFactory</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> factory.createPerson(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="9-使用-ApplicationContext-（Spring-框架）"><a href="#9-使用-ApplicationContext-（Spring-框架）" class="headerlink" title="9. 使用 ApplicationContext （Spring 框架）"></a>9. 使用 <em>ApplicationContext</em> （Spring 框架）</h2><h3 id="Spring-框架中的-Bean"><a href="#Spring-框架中的-Bean" class="headerlink" title="Spring 框架中的 Bean"></a>Spring 框架中的 Bean</h3><p>在 Spring 框架中，Bean 可以通过 <code>ApplicationContext</code> 创建。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> context.getBean(Person.class);</span><br></pre></td></tr></table></figure></div>

<h3 id="配置-Bean"><a href="#配置-Bean" class="headerlink" title="配置 Bean"></a>配置 Bean</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="10-使用序列化与反序列化"><a href="#10-使用序列化与反序列化" class="headerlink" title="10. 使用序列化与反序列化"></a>10. 使用序列化与反序列化</h2><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>对象可以通过序列化和反序列化进行创建。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.ser&quot;</span>));</span><br><span class="line">oos.writeObject(person);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.ser&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure></div>

<h3 id="需要实现-Serializable-接口"><a href="#需要实现-Serializable-接口" class="headerlink" title="需要实现 Serializable 接口"></a>需要实现 <code>Serializable</code> 接口</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="11-使用-ObjectInputStream-和-ObjectOutputStream"><a href="#11-使用-ObjectInputStream-和-ObjectOutputStream" class="headerlink" title="11. 使用 ObjectInputStream 和 ObjectOutputStream"></a>11. 使用 <em>ObjectInputStream</em> 和 <em>ObjectOutputStream</em></h2><h3 id="Stream-序列化与反序列化"><a href="#Stream-序列化与反序列化" class="headerlink" title="Stream 序列化与反序列化"></a><code>Stream</code> 序列化与反序列化</h3><p>通过 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 可以将对象转换为字节流并存储到文件中，再从文件中读取对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.ser&quot;</span>));</span><br><span class="line">oos.writeObject(person);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.ser&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure></div>

<h2 id="12-使用-Proxy-创建动态代理对象"><a href="#12-使用-Proxy-创建动态代理对象" class="headerlink" title="12. 使用 Proxy 创建动态代理对象"></a>12. 使用 <em>Proxy</em> 创建动态代理对象</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p><code>Proxy</code> 类用于创建实现特定接口的动态代理对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">personProxy</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(</span><br><span class="line">    Person.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Person.class&#125;,</span><br><span class="line">    (proxy, method, args) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 方法调用的处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div>

<h2 id="13-使用-Record-类"><a href="#13-使用-Record-类" class="headerlink" title="13. 使用 Record 类"></a>13. 使用 <em>Record</em> 类</h2><h3 id="Record-类（Java-14-引入）"><a href="#Record-类（Java-14-引入）" class="headerlink" title="Record 类（Java 14 引入）"></a><code>Record</code> 类（Java 14 引入）</h3><p><code>Record</code> 是一种新类型的类，用于简化数据存储类的创建。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建-Record-对象"><a href="#创建-Record-对象" class="headerlink" title="创建 Record 对象"></a>创建 <code>Record</code> 对象</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="14-使用-Object-clone-方法"><a href="#14-使用-Object-clone-方法" class="headerlink" title="14. 使用 Object.clone() 方法"></a>14. 使用 <em>Object.clone()</em> 方法</h2><h3 id="Object-clone-克隆对象"><a href="#Object-clone-克隆对象" class="headerlink" title="Object.clone() 克隆对象"></a><code>Object.clone()</code> 克隆对象</h3><p>可以使用 <code>Object.clone()</code> 方法来复制现有对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="15-使用-Factory-Bean"><a href="#15-使用-Factory-Bean" class="headerlink" title="15. 使用 Factory Bean"></a>15. 使用 <em>Factory Bean</em></h2><h3 id="Spring-的-Factory-Bean"><a href="#Spring-的-Factory-Bean" class="headerlink" title="Spring 的 Factory Bean"></a>Spring 的 Factory Bean</h3><p><code>FactoryBean</code> 是 Spring 框架中的一种特殊 bean，用于创建其他 beans。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="配置-Factory-Bean"><a href="#配置-Factory-Bean" class="headerlink" title="配置 Factory Bean"></a>配置 <code>Factory Bean</code></h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PersonFactoryBean <span class="title function_">personFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PersonFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="16-使用-Java-17-的-Record-类"><a href="#16-使用-Java-17-的-Record-类" class="headerlink" title="16. 使用 Java 17 的 Record 类"></a>16. 使用 Java 17 的 <em>Record</em> 类</h2><h3 id="Record-类（Java-17-引入）"><a href="#Record-类（Java-17-引入）" class="headerlink" title="Record 类（Java 17 引入）"></a><code>Record</code> 类（Java 17 引入）</h3><p><code>Record</code> 类是 Java 14 引入的，简化了数据传输对象的创建。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Factory-Bean-创建-Record-对象"><a href="#Factory-Bean-创建-Record-对象" class="headerlink" title="Factory Bean 创建 Record 对象"></a><code>Factory Bean</code> 创建 <code>Record</code> 对象</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="17-使用-Supplier-和-Function-接口"><a href="#17-使用-Supplier-和-Function-接口" class="headerlink" title="17. 使用 Supplier 和 Function 接口"></a>17. 使用 <em>Supplier</em> 和 <em>Function</em> 接口</h2><h3 id="Java-8-函数式接口"><a href="#Java-8-函数式接口" class="headerlink" title="Java 8 函数式接口"></a>Java 8 函数式接口</h3><p>可以使用 <code>Supplier</code> 和 <code>Function</code> 接口来创建对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = () -&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personSupplier.get();</span><br></pre></td></tr></table></figure></div>

<h3 id="Function-接口的使用"><a href="#Function-接口的使用" class="headerlink" title="Function 接口的使用"></a><code>Function</code> 接口的使用</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Person&gt; personCreator = name -&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(name, <span class="number">30</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personCreator.apply(<span class="string">&quot;John&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 提供了多种创建对象的方式，适用于不同的场景和需求。从最简单的 <code>new</code> 关键字到复杂的 <code>Factory Bean</code> 和 <code>动态代理</code>，这些技术可以帮助你在编写 Java 代码时选择最合适的对象创建方式。掌握这些技术将有助于提高代码的灵活性、可维护性和性能。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a class="link"   href="https://docs.oracle.com/en/java/" >Java官方文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.designpatterns.io/" >Java 设计模式<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://spring.io/projects/spring-framework" >Spring Framework 文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/" >Java 8 新特性<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.oracle.com/java/technologies/javase-jdk14-downloads.html" >Java 14 新特性<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.oracle.com/java/technologies/javase-downloads.html" >Java 17 新特性<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 异常定位</title>
    <url>/2024/07/25/Java-%E5%BC%82%E5%B8%B8%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>在 Java 中，当程序发生异常时，如何定位并解决异常通常是开发过程中需要掌握的重要技能。以下是一些常见的方法和技巧，帮助你在开发过程中有效地定位和处理异常:</p>
<h2 id="log-日志"><a href="#log-日志" class="headerlink" title="log 日志"></a>log 日志</h2><h3 id="1-异常堆栈跟踪"><a href="#1-异常堆栈跟踪" class="headerlink" title="1. 异常堆栈跟踪"></a>1. 异常堆栈跟踪</h3><p>异常堆栈跟踪是最常见和最有用的定位异常的方法。当异常发生时，Java 虚拟机(JVM)会打印出异常的堆栈跟踪信息，其中包含了异常发生的位置、调用链和具体的错误信息。</p>
<p>通常，异常堆栈跟踪信息会输出到控制台或日志文件中。例如:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">    at com.example.MyClass.myMethod(MyClass.java:<span class="number">12</span>)</span><br><span class="line">    at com.example.MyClass.main(MyClass.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure></div>

<p>在上面的例子中:</p>
<ul>
<li><code>java.lang.NullPointerException</code> 是异常类型。</li>
<li><code>com.example.MyClass.myMethod(MyClass.java:12)</code> 指示异常发生在 <code>MyClass.java</code> 文件的第 12 行。</li>
<li><code>com.example.MyClass.main(MyClass.java:6)</code> 指示异常的调用链，从 <code>main</code> 方法调用了 <code>myMethod</code> 方法。</li>
</ul>
<p>通过阅读堆栈跟踪，可以快速定位到异常发生的位置，并且了解是什么原因导致的异常。</p>
<h3 id="2-使用日志框架记录异常信息"><a href="#2-使用日志框架记录异常信息" class="headerlink" title="2. 使用日志框架记录异常信息"></a>2. 使用日志框架记录异常信息</h3><p>在实际应用中，推荐使用日志框架(如 Logback、Log4j、java.util.logging 等)记录异常信息。通过配置日志级别和适当的格式化，可以方便地管理和分析异常信息。</p>
<p>例如，在使用 Logback 时，可以这样记录异常信息:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyClass.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 代码可能会抛出异常的地方</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;An error occurred&quot;</span>, e); <span class="comment">// 记录异常信息和堆栈跟踪</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-使用调试工具"><a href="#3-使用调试工具" class="headerlink" title="3. 使用调试工具"></a>3. 使用调试工具</h3><p>调试工具(如 IntelliJ IDEA、Eclipse 等集成开发环境)可以帮助你更方便地定位和解决异常。通过设置断点、单步调试等功能，可以实时查看程序的执行流程和变量状态，从而找到导致异常的具体原因。</p>
<h3 id="4-单元测试"><a href="#4-单元测试" class="headerlink" title="4. 单元测试"></a>4. 单元测试</h3><p>编写单元测试可以帮助你及早发现代码中的问题，包括异常情况。通过编写针对异常情况的测试用例，可以模拟不同的场景，验证程序在异常情况下的行为是否符合预期。</p>
<h3 id="5-异常处理最佳实践"><a href="#5-异常处理最佳实践" class="headerlink" title="5. 异常处理最佳实践"></a>5. 异常处理最佳实践</h3><ul>
<li><strong>避免捕获过宽的异常</strong>:捕获过宽的异常可能会隐藏问题，推荐捕获具体的异常类型。</li>
<li><strong>适当地处理异常</strong>:根据具体情况选择合适的异常处理策略，例如重试、回滚、记录日志等。</li>
<li><strong>关注异常的根本原因</strong>:不仅仅关注异常的表面现象，更要找到异常的根本原因并解决它。</li>
</ul>
<h2 id="JDK-工具"><a href="#JDK-工具" class="headerlink" title="JDK 工具"></a>JDK 工具</h2><p>在 Linux 下，使用 JDK 自带的工具可以帮助你定位 Java 程序中的异常。以下是几种常用的 JDK 工具和技术，可以帮助你在 Linux 环境下定位和分析 Java 异常:</p>
<h3 id="1-使用堆栈跟踪"><a href="#1-使用堆栈跟踪" class="headerlink" title="1. 使用堆栈跟踪"></a>1. 使用堆栈跟踪</h3><p>Java 异常的堆栈跟踪信息是最基本的定位异常的方法。当程序在 Linux 下运行时，异常信息会输出到控制台或日志文件中。通过阅读堆栈跟踪，可以快速了解异常的类型、位置以及可能的原因。</p>
<h3 id="2-使用-jstack-工具"><a href="#2-使用-jstack-工具" class="headerlink" title="2. 使用 jstack 工具"></a>2. 使用 jstack 工具</h3><p><code>jstack</code> 是 JDK 自带的一个命令行工具，用于生成 Java 线程的堆栈跟踪信息。它可以帮助你查看 Java 程序的线程状态和调用堆栈，从而帮助定位可能的死锁、死循环或者其他线程相关的异常情况。</p>
<p>例如，你可以通过以下命令查看正在运行的 Java 进程的线程堆栈信息:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">jstack &lt;pid&gt;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>&lt;pid&gt;</code> 是 Java 进程的进程号。</p>
<h3 id="3-使用-jmap-工具"><a href="#3-使用-jmap-工具" class="headerlink" title="3. 使用 jmap 工具"></a>3. 使用 jmap 工具</h3><p><code>jmap</code> 是 JDK 自带的另一个命令行工具，用于生成 Java 进程的内存映像文件。通过分析内存映像文件，可以查看 Java 程序的内存使用情况，包括堆内存、GC 状况等信息，有助于分析内存相关的异常情况。</p>
<p>例如，你可以通过以下命令生成 Java 进程的内存映像文件:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=&lt;filename&gt;.bin &lt;pid&gt;</span><br></pre></td></tr></table></figure></div>

<p>然后可以使用其他工具(如 Eclipse Memory Analyzer)来分析 <code>&lt;filename&gt;.bin</code> 文件。</p>
<h3 id="4-使用-jstat-工具"><a href="#4-使用-jstat-工具" class="headerlink" title="4. 使用 jstat 工具"></a>4. 使用 jstat 工具</h3><p><code>jstat</code> 是 JDK 自带的用于监视 Java 虚拟机各种运行状态的命令行工具，包括垃圾回收情况、类装载、编译等。它可以帮助你了解程序运行时的性能状况，有助于定位一些与性能相关的异常情况。</p>
<p>例如，你可以通过以下命令查看 Java 进程的垃圾回收统计信息:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">jstat -gc &lt;pid&gt; &lt;interval&gt; &lt;count&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="5-使用-VisualVM-工具"><a href="#5-使用-VisualVM-工具" class="headerlink" title="5. 使用 VisualVM 工具"></a>5. 使用 VisualVM 工具</h3><p><code>VisualVM</code> 是 JDK 提供的一款图形化工具，集成了多种分析和监控 Java 应用程序的功能。它可以帮助你实时监视 Java 进程的性能指标、内存使用情况，并能够生成线程、堆栈跟踪信息等，是分析和定位 Java 异常的强大工具之一。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在使用这些工具时，确保你有足够的权限访问 Java 进程。</li>
<li>谨慎使用生成内存映像文件等可能影响 Java 进程性能的操作。</li>
<li>结合多种工具和方法进行综合分析，有助于更快速和准确地定位 Java 程序中的异常问题。</li>
</ul>
<h2 id="Arthas-工具"><a href="#Arthas-工具" class="headerlink" title="Arthas 工具"></a>Arthas 工具</h2><p>Arthas(阿尔萨斯)是一款开源的 Java 应用诊断工具，它提供了丰富的命令和功能，可以帮助开发人员定位和解决 Java 应用程序中的各种问题，包括异常问题、性能问题等。下面介绍如何使用 Arthas 来定位 Java 应用程序中的问题。</p>
<h3 id="安装-Arthas"><a href="#安装-Arthas" class="headerlink" title="安装 Arthas"></a>安装 Arthas</h3><p>首先，你需要安装 Arthas。Arthas 的安装非常简单，只需下载 Arthas 的启动脚本并执行即可。以下是安装步骤:</p>
<ol>
<li><p>下载 Arthas 启动脚本:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>启动 Arthas:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure></div>

<p>这会启动 Arthas 的命令行界面(TIP)，你可以在这里输入命令来进行诊断和调试。</p>
</li>
</ol>
<h3 id="使用-Arthas-定位问题"><a href="#使用-Arthas-定位问题" class="headerlink" title="使用 Arthas 定位问题"></a>使用 Arthas 定位问题</h3><h4 id="1-查看-Java-进程列表"><a href="#1-查看-Java-进程列表" class="headerlink" title="1. 查看 Java 进程列表"></a>1. 查看 Java 进程列表</h4><p>首先，使用 <code>ps</code> 命令查看当前运行的 Java 进程:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps</span><br></pre></td></tr></table></figure></div>

<p>找到你要诊断的 Java 进程的 PID。</p>
<h4 id="2-连接到-Java-进程"><a href="#2-连接到-Java-进程" class="headerlink" title="2. 连接到 Java 进程"></a>2. 连接到 Java 进程</h4><p>使用 Arthas 连接到指定的 Java 进程:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./as.sh &lt;pid&gt;</span><br></pre></td></tr></table></figure></div>

<p>这会进入 Arthas 的命令行界面。</p>
<h4 id="3-查看异常信息"><a href="#3-查看异常信息" class="headerlink" title="3. 查看异常信息"></a>3. 查看异常信息</h4><p>在 Arthas 的命令行界面中，你可以使用一些命令来查看异常信息、线程堆栈、类加载情况等，以帮助定位问题。</p>
<ul>
<li><p><strong>查看异常信息</strong>:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看最近的异常堆栈</span></span><br><span class="line">$ trace [options]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看异常详情</span></span><br><span class="line">$ exception &lt;throwableId&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>查看线程堆栈</strong>:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有线程的堆栈信息</span></span><br><span class="line">$ thread</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>查看类加载情况</strong>:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看已加载的类</span></span><br><span class="line">$ class</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>监控方法执行时间</strong>:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监控方法执行时间</span></span><br><span class="line">$ watch &lt;package.class&gt; &lt;method&gt; &lt;condition&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>动态修改代码</strong>:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑类方法</span></span><br><span class="line">$ redefine &lt;class-name&gt; &lt;method-name&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="4-使用-Dashboard-分析性能"><a href="#4-使用-Dashboard-分析性能" class="headerlink" title="4. 使用 Dashboard 分析性能"></a>4. 使用 Dashboard 分析性能</h4><p>Arthas 还提供了 Dashboard 功能，可以通过 Web 界面来实时监控应用程序的性能指标和状态。可以在 Arthas 命令行中输入以下命令启动 Dashboard:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ dashboard</span><br></pre></td></tr></table></figure></div>

<p>然后在浏览器中访问 <code>http://localhost:8563</code> 查看 Dashboard。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，你可以利用 Arthas 强大的命令和功能来帮助定位和解决 Java 应用程序中的各种问题。Arthas 提供了丰富的工具和命令，适用于异常问题、性能问题、内存泄漏等各种场景，是 Java 应用程序调试和诊断的重要工具之一。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 常见的分布式任务调度框架</title>
    <url>/2024/07/09/Java-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p>Quartz、XXL-Job、PowerJob 和 ElasticJob 都是常见的分布式任务调度框架，每个框架都有其特定的优势和适用场景。</p>
</blockquote>
<h3 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h3><ul>
<li><strong>类型：</strong> Quartz 是一个轻量级的开源任务调度框架，适合用于传统的 Java 任务调度和定时任务管理。</li>
<li><strong>特点：</strong><ul>
<li>提供丰富的任务调度功能，支持多种触发器（SimpleTrigger、CronTrigger 等）。</li>
<li>可以与 Spring 框架集成，支持声明式的配置。</li>
<li>提供基于内存或 JDBC 的任务存储。</li>
<li>可以独立使用或嵌入到应用中。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 适合小型到中型的任务调度场景，对任务调度的精确度和可靠性有较高要求的项目。</li>
</ul>
<h3 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="XXL-Job"></a>XXL-Job</h3><ul>
<li><strong>类型：</strong> XXL-Job 是一个开源的分布式任务调度平台，专门为解决大规模任务调度问题设计。</li>
<li><strong>特点：</strong><ul>
<li>提供可视化的任务管理界面，支持在线配置任务和监控任务执行情况。</li>
<li>支持分布式任务调度，可以部署多个执行器（Executor）实现任务分片。</li>
<li>提供基于数据库存储任务信息，具备较好的扩展性和稳定性。</li>
<li>内置了报警机制和任务失败重试机制。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 适合企业级应用，需要大规模、分布式任务调度和管理的场景，如数据处理、定时报表生成等。</li>
</ul>
<h3 id="PowerJob"><a href="#PowerJob" class="headerlink" title="PowerJob"></a>PowerJob</h3><ul>
<li><strong>类型：</strong> PowerJob 是一个开源的分布式任务调度平台，具有简单易用和高扩展性的特点。</li>
<li><strong>特点：</strong><ul>
<li>提供 Web 可视化界面管理任务，支持在线配置、监控任务执行情况。</li>
<li>支持分布式任务调度，可以水平扩展。</li>
<li>提供基于数据库存储任务信息，并且支持多种存储引擎。</li>
<li>内置了任务依赖管理和失败重试机制。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 适合需要可视化管理和高扩展性的分布式任务调度应用，如数据处理、消息处理等。</li>
</ul>
<h3 id="ElasticJob"><a href="#ElasticJob" class="headerlink" title="ElasticJob"></a>ElasticJob</h3><ul>
<li><strong>类型：</strong> ElasticJob 是一个开源的分布式任务调度解决方案，主要用于处理大规模数据处理和分布式任务调度。</li>
<li><strong>特点：</strong><ul>
<li>提供了分布式作业的解决方案，支持数据分片和分布式调度。</li>
<li>内置了多种作业类型，如简单作业、数据流作业、脚本作业等。</li>
<li>可以与 ZooKeeper、Redis 等作为分布式协调服务进行集成。</li>
<li>支持任务的弹性扩展和灵活配置。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 适合需要大规模数据处理和分布式任务调度的场景，如大数据处理、实时数据处理等。</li>
</ul>
<h3 id="选择适合的框架"><a href="#选择适合的框架" class="headerlink" title="选择适合的框架"></a>选择适合的框架</h3><ul>
<li><strong>Quartz</strong> 是一个通用的任务调度框架，适合于传统的 Java 任务调度需求，特别是在单机或简单分布式场景下使用。</li>
<li><strong>XXL-Job</strong> 和 <strong>PowerJob</strong> 都专注于企业级的大规模任务调度，提供了更强大的可视化管理和分布式调度能力。</li>
<li><strong>ElasticJob</strong> 则更加注重于分布式任务处理和大数据处理场景，支持更灵活的作业类型和分布式协调。</li>
</ul>
<p>根据具体的项目需求和技术栈选择合适的框架是关键。例如，如果需要高度可视化的管理界面和企业级的分布式任务调度能力，可以考虑 XXL-Job 或 PowerJob；如果涉及到大规模数据处理和分布式任务，ElasticJob 是一个不错的选择。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Job</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Framework</tag>
        <tag>Job</tag>
        <tag>Distributed</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 环境变量配置</title>
    <url>/2024/06/24/Java-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>💡 安装后需配置环境变量</p>
</blockquote>
<p>Java 环境变量配置主要涉及设置 <code>JAVA_HOME</code> 和更新系统的 <code>PATH</code> 环境变量。以下是详细的步骤和说明：</p>
<h2 id="确定-Java-安装路径"><a href="#确定-Java-安装路径" class="headerlink" title="确定 Java 安装路径"></a>确定 Java 安装路径</h2><p>首先，你需要确定 Java 的安装路径。通常，Java 会安装在 <code>C:\Program Files\Java\</code> 目录下。你可以通过“控制面板”中的“程序和功能”来查找已安装的 Java 版本，或者通过命令行使用 <code>where java</code> 来查找 Java 可执行文件的路径。</p>
<h2 id="设置-JAVA-HOME-环境变量"><a href="#设置-JAVA-HOME-环境变量" class="headerlink" title="设置 JAVA_HOME 环境变量"></a>设置 JAVA_HOME 环境变量</h2><p>JAVA_HOME 环境变量用于指定 Java 的安装目录。你可以按照以下步骤设置它：</p>
<h3 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统:"></a>Windows 系统:</h3><ol>
<li>打开“控制面板”。</li>
<li>点击“系统与安全”。</li>
<li>点击“系统”。</li>
<li>点击“高级系统设置”。</li>
<li>在“高级”选项卡下，点击“环境变量”。</li>
<li>在“系统变量”下，点击“新建”，变量名输入 <code>JAVA_HOME</code>，变量值填入你的 Java 安装路径（例如 <code>C:\Program Files\Java\jdk11_XXX</code>）。</li>
</ol>
<h3 id="Linux-或-macOS-系统"><a href="#Linux-或-macOS-系统" class="headerlink" title="Linux 或 macOS 系统:"></a>Linux 或 macOS 系统:</h3><p>你可以在终端中使用文本编辑器(如 <code>nano</code> 或 <code>vim</code>)编辑 <code>.bashrc</code>,<code>.bash_profile</code> 或 <code>.zshrc</code> 文件(取决于你的 <code>shell</code> 和操作系统)，然后添加以下行：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/path/to/java-installation</span><br></pre></td></tr></table></figure></div>

<p>将 <code>/path/to/java-installation</code> 替换为你的 Java 安装路径。</p>
<h2 id="更新-PATH-环境变量"><a href="#更新-PATH-环境变量" class="headerlink" title="更新 PATH 环境变量"></a>更新 PATH 环境变量</h2><p>你需要将 Java 的 <code>bin</code> 目录添加到系统的 <code>PATH</code> 环境变量中，这样你就可以从任何位置运行 Java 命令。</p>
<h3 id="对于-Windows-系统"><a href="#对于-Windows-系统" class="headerlink" title="对于 Windows 系统:"></a>对于 Windows 系统:</h3><p>在“环境变量”窗口中，找到并选中<code>Path</code>变量，点击“编辑”。在编辑窗口中，添加 <code>JAVA_HOME\bin</code> 到值的开头或任何合适的位置。确保用分号 ; 分隔不同的路径。</p>
<h3 id="对于-Linux-或-macOS-系统"><a href="#对于-Linux-或-macOS-系统" class="headerlink" title="对于 Linux 或 macOS 系统:"></a>对于 Linux 或 macOS 系统:</h3><p>在 <code>.bashrc</code>,<code>.bash_profile</code> 或 <code>.zshrc</code> 文件中添加以下行：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure></div>

<p>保存文件并重新加载配置(在终端中运行 <code>source ~/.bashrc</code> 或相应的配置文件)。</p>
<h2 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h2><p>配置完成后，你可以通过打开命令行或终端，并运行 <code>java -version</code> 和 <code>javac -version</code> 来验证 Java 是否正确配置。这两个命令分别显示 Java 运行时和编译器的版本信息。<br>以上步骤应该能帮助你正确配置 Java 的环境变量。如果你在使用过程中遇到任何问题，请随时提问！</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Env</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 引用类型 Reference</title>
    <url>/2024/07/08/Java-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Reference/</url>
    <content><![CDATA[<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/reference/reference_1.webp"
                      alt="Reference"
                ><figcaption>Reference</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/reference/reference_2.webp"
                      alt="Reference"
                ><figcaption>Reference</figcaption></figure></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>每一种语言都有着自己操作内存元素的方式，C语言通过指针，而java就是通过引用。作为一门面向对象的语言，在java中世事万物皆对象。但是我们操作的标识符实际上是对象的一个引用 reference。今天我们来分析一下java中的四种引用。</p>
</blockquote>
<h3 id="引用的历史"><a href="#引用的历史" class="headerlink" title="引用的历史"></a>引用的历史</h3><p>在Java中，我们的垃圾回收机制回收垃圾对象的时候就会依据对象的引用。比如说通过不同的垃圾回收算法，这里有两种：引用计数法和可达性分析法</p>
<ol>
<li>引用计数法：为每个对象添加一个引用计数器，每当有一个引用指向它时，计数器就加1，当引用失效时，计数器就减1，当计数器为0时，则认为该对象可以被回收。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/reference/reference_3.webp"
                      alt="Reference"
                ><figcaption>Reference</figcaption></figure></li>
<li>可达性分析算法：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/reference/reference_4.webp"
                      alt="Reference"
                ><figcaption>Reference</figcaption></figure></li>
</ol>
<p>目前的垃圾回收基本上采用第二种方式，第一种方式基本上已经被舍弃了。<br>在jdk1.2之前，java对引用的概念只有“已被引用”和”未被引用”两种状态。后来所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用、软引用、弱引用、虚引用4 种，也就是我们今天所讲的主题。这 4 种引用的强度依次减弱。</p>
<h2 id="Java-有四种引用类型："><a href="#Java-有四种引用类型：" class="headerlink" title="Java 有四种引用类型："></a>Java 有四种引用类型：</h2><ol>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ol>
<p>四种引用的级别由高到低依次为：强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用。</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>在 Java 中最常见的就是强引用， 把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收，因此强引用是造成 Java 内存泄漏的主要原因之一。所以要想回收该对象，则应该将指向该对象的变量显示设为 null，这样该对象就由强引用转变为无引用了。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 帮助垃圾收集器回收此对象</span></span><br><span class="line">str = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); </span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure></div>

<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。弱引用也可以用于缓存，可以参考 WeakHashMap 类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">WeakReference&lt;String&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure></div>

<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。 虚引用的主要作用是跟踪对象被垃圾回收的状态。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//创建引用队列</span></span><br><span class="line">ReferenceQueue&lt;String&gt; refQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">//创建的虚引用</span></span><br><span class="line">PhantomReference&lt;String&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(str, refQueue);</span><br><span class="line"><span class="comment">//phantomRef.get()总是返回null</span></span><br></pre></td></tr></table></figure></div>

<hr>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>阻止GC?</th>
<th>回收时机</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>是</td>
<td>显式null化后</td>
<td>普通对象引用</td>
</tr>
<tr>
<td>软引用</td>
<td>否</td>
<td>内存不足时</td>
<td>内存敏感的缓存</td>
</tr>
<tr>
<td>弱引用</td>
<td>否</td>
<td>随时可能</td>
<td>非必须的对象引用，允许随时回收</td>
</tr>
<tr>
<td>虚引用</td>
<td>否</td>
<td>随时可能，对象即将被回收</td>
<td>跟踪对象被垃圾收集器回收的活动</td>
</tr>
<tr>
<td>GC Roots</td>
<td>否</td>
<td>从不回收</td>
<td>作为垃圾收集器的起始点</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编程规范</title>
    <url>/2021/04/23/Java%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="Java开发规范"><a href="#Java开发规范" class="headerlink" title="Java开发规范"></a>Java开发规范</h1><h2 id="前言-为什么需要编码规范1"><a href="#前言-为什么需要编码规范1" class="headerlink" title="前言 为什么需要编码规范1"></a>前言 为什么需要编码规范<a href="#refer-anchor-1"><sup>1</sup></a></h2><p>为什么需要编码规范，借用《Java编程语言代码规范》一段开场白：</p>
<blockquote>
<p>一个软件需要花费80%的生命周期成本去维护。 　　<br>几乎没有任何软件的整个生命周期仅由其原作者来维护。 　　<br>编码规范改善软件的可读性,让工程师更快更彻底地理解新的代码。 　　<br>如果你将源代码转变为一个产品,那么您需要确保它和你创建的其它产品一样是干净且包装良好的。</p>
</blockquote>
<p>好的代码结构和代码风格一般bug也相对少，当然除了编码规范，也少不了充分自测。[<sub>写代码一部分是完成工作用来给机器执行, 另一部分是给人使用的(我们都是创造者), 无论未来的维护这是不是你, 一段程序的健壮、扩展、灵活是很重要的一件事, 虽然它可有可无,也不会记录KPI,但是何必有杂念呢    — Sp!ke</sub>]</p>
<h2 id="1-如何命名"><a href="#1-如何命名" class="headerlink" title="1 如何命名"></a>1 如何命名</h2><blockquote>
<p>代码就是最好的注释[<sub>我们是如何读文章的, 你又是怎么样读懂我写的这句话的 —Sp!ke</sub>]</p>
</blockquote>
<h3 id="1-1-命名"><a href="#1-1-命名" class="headerlink" title="1.1 命名"></a>1.1 命名</h3><ol>
<li>如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。</li>
<li>变量名应该简短且有意义，并能够顾名思义。简单并不意味着越短越好，比如一个字符的变量名是不允许的，很影响代码的可读性。</li>
</ol>
<p>[<sub>哪里是用缩写,哪里使用全拼,命名其他人能见词知义么,非英语母语的地区会有下一个问题<code>select get query find | selectOne getData queryInfo | findAll queryList getDatas</code>,是不是每个人都需一本字典才能开发,如果有是不是特定的字典 —Sp!ke</sub>]</p>
<h4 id="1-1-1-命名风格"><a href="#1-1-1-命名风格" class="headerlink" title="1.1.1 命名风格"></a>1.1.1 命名风格</h4><ol>
<li><p>代码中的命名均不能以$\color{CornflowerBlue}{下划线或美元符号}$ 开始，也不能以$\color{CornflowerBlue}{下划线或美元}$符号结束<br> $\color{OrangeRed}{反例:}  $ <code>_name / __name / $name / name_ / name$ / name__</code></p>
</li>
<li><p>代码中的命名均不能包含$\color{CornflowerBlue}{魔法数字或无意义的数字}$, 但是允许有意义的<br> $\color{MediumSeaGreen}{正例:}$ <code>timeout3s / list2Map / string2List</code><br> $\color{OrangeRed}{反例:}$ <code>table1 / i1 / a123aaa / str1</code></p>
</li>
<li><p>类名使用UpperCamelCase风格，但以下情形例外：DO &#x2F; BO &#x2F; DTO &#x2F; VO &#x2F; AO &#x2F; PO &#x2F; UID等<br> $\color{MediumSeaGreen}{正例:} $ <code>MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion</code><br> $\color{OrangeRed}{反例:}$ <code>macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</code></p>
</li>
<li><p>方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式<br> $\color{MediumSeaGreen}{正例:}$ <code>localValue / getHttpMessage() / inputUserId</code><br>[<sub>其实我并不是很热衷写这种用例, 虽然它很直观,但是阿里巴巴已经写好了,感兴趣可以直接下载附件,更多的是我们每书写一段代码是否有认真思考过,有些人没有命名意识会做错,有些人不知道但是拷贝的做会正确,有些人通过经验习惯做会正确,但是有没有停下来归纳一下正确的写法有哪些通用的,这会比写出一百两百个用例更有效 —Sp!ke</sub>]</p>
</li>
</ol>
<h4 id="1-1-2-常量、变量命名"><a href="#1-1-2-常量、变量命名" class="headerlink" title="1.1.2 常量、变量命名"></a>1.1.2 常量、变量命名</h4><p>[<sub>常量与变量命名并没有太多的点只是罗列几点 —Sp!ke</sub>]</p>
<p>变量:</p>
<ol>
<li>驼峰命名规则</li>
<li>第一个首字母小写后续单词首字母大写</li>
<li>减少不通用的缩写</li>
<li>命名需要满足阅读顺序 <code>actorListName</code> -&gt; <code>actorNameList</code>,  <code>sourcePrefixActorList</code>-&gt;<code>actorSourcePerfixList</code></li>
<li>不要加入无意义的魔法数字或者符号 <code>str1</code> -&gt; <code>origin</code> , <code>table13</code> -&gt; <code>mainTable</code></li>
<li>歧义的变量 例如：<code>logger</code> <code>LOGGER</code> 根据实际情况处理</li>
</ol>
<p>常量</p>
<ol>
<li>全大写</li>
<li>单词之间使用下划线做分割</li>
<li>其他规则参考变量</li>
</ol>
<h4 id="1-1-3-类命名"><a href="#1-1-3-类命名" class="headerlink" title="1.1.3 类命名"></a>1.1.3 类命名</h4><p>[<sub>类的命名是很重要的，但是不单单是命名更多的是名字就是他的职责与功能，类有两个点需要时刻注意 1.类型 2.命名 —Sp!ke</sub>]</p>
<h5 id="1-1-3-1-类型"><a href="#1-1-3-1-类型" class="headerlink" title="1.1.3.1 类型"></a>1.1.3.1 类型</h5><p>[<sub>无论下面哪种类型在编译之后都会以.class形式存在， 那么为什么又要拆分成不同类型呢，不同类型负责的职责也不同，当然你也可以混用但是不建议，失去了真正职责的类相当于，使用饭碗装排泄物 —Sp!ke</sub>]</p>
<ol>
<li><code>Class</code> 类 : 更泛泛的通用的容器，可以理解为 normal</li>
<li><code>Enum</code> 枚举类 : 枚举的特性在于内部的强关联，以及元素之间的规律性 <code>RED, BLUE, BLACK</code> 可以做一组枚举， 但是 <code>RED, NAME, JAVA</code>一组枚举就会莫名其妙</li>
<li><code>Interface</code> 接口类 : 接口在Java中作用其一是弥补Java单继承的不足，作用其二是更好实现OOP的多态[<sub>我们的代码中有将常量放在interface里定义的情况，并不是说这种不可以，首先不建议因为失去了Interface的真正意义，其次如何给Interface命名呢<code>UserConstant</code>么，还是需要思考一下吧 —Sp!ke</sub>]</li>
<li><code>Annotation</code> 注解类 : 注解类不做太多阐述，他的使用会使程序更加灵活，但也不可控[<sub>事物都存在双面性 —Sp!ke</sub>]</li>
</ol>
<h5 id="1-1-3-2-命名"><a href="#1-1-3-2-命名" class="headerlink" title="1.1.3.2 命名"></a>1.1.3.2 命名</h5><p>[<sub>我们所期待的良好的类命名是为了看到名字就知道作用 —Sp!ke</sub>]</p>
<p>包名 <code>(packages)</code> 建议后面追加<code>s</code>, 例如<code>Utils</code> <code>Constants</code> <code>Enums</code></p>
<hr>
<p>基础层 [<sub>每一层完成他自己的事情,不要越级处理 —Sp!ke</sub>]</p>
<ol>
<li><code>Controller</code>	$\color{CornflowerBlue}{后缀}$ Web控制层 负责请求分配, 具体交给<code>Service</code>还是重定向有具体业务判断, 建议只包含<code>Request</code> <code>Response</code>(可自定义) 数据的封装与下发 [<sub>上层、下层、底层、业务 Whatever —Sp!ke</sub>]</li>
<li><code>Service</code> $\color{CornflowerBlue}{后缀}$ 业务层 具体业务处理 由入口输入(<code>Controller</code> <code>Executer</code> 等进入 ) 负责加工、执行、处理调用数据层(<code>DAO</code> <code>Manager</code> <code>RedisTemplate</code> <code>Service</code>等)</li>
<li><code>DAO</code> <code>Dao</code> $\color{CornflowerBlue}{后缀}$ 数据持久层 与持久化层对接 只处理数据的 <code>CURD</code>操作、以及数据源使用[<sub>我理解一个完整的<code>DAO</code>包含了<code>MySQL</code> <code>Redis</code> <code>Mongo</code>等等的集成 而不是单一的处理 —Sp!ke</sub>]</li>
</ol>
<hr>
<p>常见类命名</p>
<ol>
<li><code>Application</code> $\color{CornflowerBlue}{后缀}$ 启动类 项目唯一主入口 [<sub>我建议业务类型服务只用<code>Application</code>命名即可,不需要加入具体业务前缀, 可以规范运维启动脚本 —Sp!ke</sub>]</li>
<li><code>Config</code> <code>Configuration</code> $\color{CornflowerBlue}{后缀}$ 配置类</li>
<li><code>Constant</code> $\color{CornflowerBlue}{后缀}$ 常量类 建议同一个常量类中常量具有相关性,便于管理以及类的命名 [<sub> 这个是否是常量<code>int timeout = 3;</code> —Sp!ke </sub>]</li>
<li><code>Enum</code> $\color{CornflowerBlue}{后缀}$ 枚举类 内部强关联 便于数据整理相当于多维<code>Constant</code></li>
<li><code>Interface</code> $\color{CornflowerBlue}{后缀}$ 接口 [<sub>接口是用来实现的, 失去了行为的接口是没有意义的</sub>]</li>
<li><code>Base</code> <code>Common</code> <code>Super</code> <code>Abstract</code> $\color{CornflowerBlue}{前后缀均可} $ <code>Abstract</code> $\color{CornflowerBlue}{前缀}$父类或基础类</li>
<li><code>Exception</code> $\color{CornflowerBlue}{后缀}$  异常类 异常类多指自定义异常</li>
<li><code>Impl</code> $\color{CornflowerBlue}{后缀}$  实现类 与 <code>Interface</code>相关,子母关系缺一不可 使用<code>extends</code>不要加<code>Impl</code>后缀</li>
<li><code>Utils</code>  $\color{CornflowerBlue}{后缀}$ 工具类 工具类<code>pulibc</code>修饰应加入 <code>static</code> 内部 <code>private</code>为特有</li>
<li><code>Data</code> <code>Entity</code> <code>Bean</code> <code>Domain</code> <code>Model</code> <code>POJO</code>  $\color{CornflowerBlue}{后缀}$ 实体</li>
</ol>
<p>[<sub>有一种说法 <code>Data</code> <code>Model</code> 修饰不需要加, 这是一种累赘的命名 类似<code>actorNameString</code> —Sp!ke</sub>]</p>
<p>实体、数据对象[<sup>4</sup>] (#refer-anchor-4) [<sup>5</sup>] (#refer-anchor-5)</p>
<blockquote>
<ol>
<li><code>Data</code> <code>Info</code> <code>Detail</code> [<sub>不好说没有这个规则, 只能说能看懂 —Sp!ke</sub>]<ol>
<li><code>Entity</code> 就是实体的意思，所以也是最常用到的，<code>Entity</code>包中的类是必须和数据库相对应的</li>
<li><code>Model</code> 最早与WEB相关, 是为页面提供数据和数据校验的</li>
<li><code>Domain</code> 代表一个对象模块, 这个包国外很多项目经常用到，字面意思是域的意思, 比如一个商城的项目，商城主要的模块就是用户，订单，商品三大模块，那么这三块数据就可以叫做三个域</li>
<li><code>POJO</code> <code>Plain OrdinaryJava Object</code>的缩写不错，但是它通指没有使用<code>Entity</code> <code>Beans</code>的普通java对象，可以把<code>POJO</code>作为支持业务逻辑的协助类</li>
<li><code>VO</code>  <code>View Object</code> 视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来</li>
<li><code>DTO</code> <code>Data Transfer Object</code> 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象</li>
<li><code>DO</code> <code>Domain Object</code> 领域对象，就是从现实世界中抽象出来的有形或无形的业务实体</li>
<li><code>PO</code> <code>Persistent Object</code> 持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。</li>
</ol>
</li>
</ol>
</blockquote>
<hr>
<p>对于常量<code>Class</code> <code>Interface</code>进行了一些文献查询，还是众说纷纭，只能说建议</p>
<blockquote>
<p>常量接口模式<br><strong>The constant interface pattern is a poor use of interfaces</strong> . That a class uses some constants internally is an implementation detail.<br>Implementing a constant interface causes this implementation detail to leak into the class’s exported API.<br>It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them.<br>Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility.<br>If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface.<br>There are several constant interfaces in the java platform libraries, such as  <code>java.io.ObjectStreamConstants</code> .<br>These interfaces should be regarded as anomalies and should not be emulated.<br><strong>原文出自see <a class="link"   href="http://www.oracle.com/technetwork/java/effectivejava-136174.html" >Effective Java<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></strong></p>
</blockquote>
<p>一下连接仅供参考</p>
<ul>
<li><a class="link"   href="https://www.cnblogs.com/wanqieddy/p/9051568.html" >https://www.cnblogs.com/wanqieddy/p/9051568.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/voo00oov/article/details/50433672" >https://blog.csdn.net/voo00oov/article/details/50433672<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://stackoverflow.com/questions/2659593/what-is-the-use-of-interface-constants" >https://stackoverflow.com/questions/2659593/what-is-the-use-of-interface-constants<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://docs.oracle.com/javase/tutorial/java/IandI/interfaceDef.html" >https://docs.oracle.com/javase/tutorial/java/IandI/interfaceDef.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>也有一种优雅的写法</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class Constants &#123;</span><br><span class="line"></span><br><span class="line">    private Constants() &#123;</span><br><span class="line">        // restrict instantiation</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final double PI = 3.14159;</span><br><span class="line">    public static final double PLANCK_CONSTANT = 6.62606896e-34;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>管理类命名</p>
<ol>
<li><code>Pool</code>  $\color{CornflowerBlue}{后缀}$ 池</li>
<li><code>Manager</code> <code>Mgr</code>  $\color{CornflowerBlue}{后缀}$ 管理器</li>
<li><code>Group</code>  $\color{CornflowerBlue}{后缀}$ 群</li>
<li><code>Proxy</code>  $\color{CornflowerBlue}{后缀}$ 代理类</li>
<li><code>Balance</code>  $\color{CornflowerBlue}{后缀}$ 均衡器</li>
<li><code>Container</code>  $\color{CornflowerBlue}{后缀}$ 容器</li>
</ol>
<hr>
<p>创建类命名</p>
<ol>
<li><code>Generator</code>  $\color{CornflowerBlue}{后缀}$ 生成器</li>
<li><code>Builder</code>  $\color{CornflowerBlue}{后缀}$ 构建器</li>
<li><code>Factory</code>  $\color{CornflowerBlue}{后缀}$ 工厂</li>
</ol>
<hr>
<p>协议通讯相关功能</p>
<ol>
<li><code>Msg</code> <code>Ack</code> <code>Req</code> <code>Resp</code>  $\color{CornflowerBlue}{前后缀均可,推荐后缀}$ 消息类</li>
<li><code>Header</code> <code>Body</code>  $\color{CornflowerBlue}{后缀}$ 头部 主体</li>
<li><code>Proto</code> <code>Protobuf</code>  $\color{CornflowerBlue}{后缀}$ 协议类</li>
<li><code>Sender</code>  $\color{CornflowerBlue}{后缀}$ 发送者</li>
<li><code>Receiver</code>  $\color{CornflowerBlue}{后缀}$ 接收者</li>
</ol>
<hr>
<p>其他功能</p>
<ol>
<li><p><code>Listener</code>  $\color{CornflowerBlue}{后缀}$ 监听</p>
</li>
<li><p><code>Filter</code>  $\color{CornflowerBlue}{后缀}$ 过滤器 Java中起源于Servlet</p>
</li>
<li><p><code>Interceptor</code>  $\color{CornflowerBlue}{后缀}$ 拦截器 Java中起源于Spring<br>[<sub>从某种意义上来说 <code>Filter</code> <code>Interceptor</code> 并没有冲突 他们是两个容器的筛选 存在顺序关系 可以查看容器的结构 —Sp!ke</sub>]</p>
</li>
<li><p><code>Executer</code>  $\color{CornflowerBlue}{后缀}$ 处理器 [<sub><code>Executer</code>与<code>Service</code>在于 <code>Service</code>可以拥有独立的规范函数 <code>Executer</code> 则具有集体特性 —Sp!ke</sub>]</p>
</li>
<li><p><code>Templater</code>  $\color{CornflowerBlue}{后缀}$ 模板</p>
</li>
<li><p><code>Converter</code>  $\color{CornflowerBlue}{后缀}$ 转换器</p>
</li>
<li><p><code>Connector</code>  $\color{CornflowerBlue}{后缀}$ 连接器</p>
</li>
<li><p><code>Recorder</code>  $\color{CornflowerBlue}{后缀}$ 记录器</p>
</li>
<li><p><code>Monitor</code>  $\color{CornflowerBlue}{后缀}$ 监控器</p>
</li>
<li><p><code>Server</code>  $\color{CornflowerBlue}{后缀}$ 服务器 注意<code>Server</code>代表一个大型的容器概念 , <code>Service</code>代表某个具体的业务</p>
</li>
<li><p><code>Client</code>  $\color{CornflowerBlue}{后缀}$ 终端类</p>
</li>
</ol>
<hr>
<p><code>er</code> <code>or</code> 尾缀代表执行者关系类似 <code>TaskPool</code> <code>Tasker</code>或者<code>ExecutorGroup</code> <code>Executor</code><br>[<sub>更多的命名可以参考设计模式名称, 核心是见词知意 —Sp!ke</sub>]<br>(<code>Singleton</code> <code>Prototype</code> <code>Adapter</code> <code>Bridge</code> <code>Decorator</code> <code>Interpreter</code> <code>Command</code> <code>Mediator</code> <code>State</code> <code>Visitor</code> <code>Strategy</code> <code>Memento</code> <code>...</code>)[<sup>7</sup>] (#refer-anchor-7)</p>
<blockquote>
<p>思考: <code>DAO</code> <code>Dao</code>, <code>DTO</code> <code>Dto</code> 模棱两可的命名如何处理?</p>
</blockquote>
<h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p>注释有利于帮助理解代码，如果使用不当，反而会影响代码的简洁性，不利于理解代码。注释在使用上笔者认为需要坚持三个原则：</p>
<ol>
<li>保持代码干净，消除不必要的注释：好的代码本身就是最好的注释，只在必要时通过注释协助理解代码，目的是保持代码的简洁性，增强代码的可读性；</li>
<li>区分注释和JavaDoc：类、域、方法使用JavaDoc，方法内部使用注释；</li>
<li>注释及时更新：注释也是代码的一部分，如果代码发生变更，注释也要跟着改；</li>
</ol>
<p>[<sub>我的理解注释的意义是补全,补全那些我们不能写成有效代码的片段、文字,也有人会指这我问为什么这个类没有一句注释, <code>String userLastName = &quot;zhang&quot;;</code> 需要注释么 —Sp!ke</sub>]</p>
<p>例:<a href="#refer-anchor-2"><sup>2</sup></a> [<sup>3</sup>] (#refer-anchor-3)</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">String unitAbbrev = &quot;μs&quot;;									| 赞，即使没有注释也非常清晰</span><br><span class="line">String unitAbbrev = &quot;\u03bcs&quot;; // &quot;μs&quot;						| 允许，但没有理由要这样做</span><br><span class="line">String unitAbbrev = &quot;\u03bcs&quot;; // Greek letter mu, &quot;s&quot;				| 允许，但这样做显得笨拙还容易出错</span><br><span class="line">String unitAbbrev = &quot;\u03bcs&quot;;								| 很糟，读者根本看不出这是什么</span><br><span class="line">return &#x27;\ufeff&#x27; + content; // byte order mark					| Good，对于非打印字符，使用转义，并在必要时写上注释</span><br></pre></td></tr></table></figure></div>

<h2 id="2-日志"><a href="#2-日志" class="headerlink" title="2 日志"></a>2 日志</h2><blockquote>
<p>不管是使用何种编程语言，日志输出几乎无处不在。总结起来，日志大致有以下几种用途：<br>    * 问题跟踪：通过日志不仅仅包括我们程序的一些bug，也可以在安装配置时，通过日志可以发现问题。<br>    * 状态监控：通过实时分析日志，可以监控系统的运行状态，做到早发现问题，早处理问题。<br>    * 安全审计：审计主要体现在安全方面上，通过日志进行分析，可以发现是否存在非授权的操作。</p>
</blockquote>
<h3 id="2-1-级别"><a href="#2-1-级别" class="headerlink" title="2.1 级别"></a>2.1 级别</h3><ol>
<li><code>fatal</code> - 严重的，造成服务中断的错误；</li>
<li><code>error</code> - 其他错误运行期错误；</li>
<li><code>warn</code> - 警告信息，如程序调用了一个即将作废的接口，接口的不当使用，运行状态不是期望的但仍可继续处理等；</li>
<li><code>info</code> - 有意义的事件信息，如程序启动，关闭事件，收到请求事件等；</li>
<li><code>debug</code> - 调试信息，可记录详细的业务处理到哪一步了，以及当前的变量状态；</li>
<li><code>trace</code> - 更详细的跟踪信息；</li>
</ol>
<h3 id="2-2-基本的Logger编码规范"><a href="#2-2-基本的Logger编码规范" class="headerlink" title="2.2 基本的Logger编码规范"></a>2.2 基本的Logger编码规范</h3><ol>
<li>在一个对象中通常只使用一个<code>Logger</code>对象，Logger应该是<code>static final</code>的，只有在少数需要在构造函数中传递<code>logger</code>的情况下才使用<code>private final</code>。</li>
<li>输出<code>Exceptions</code>的全部<code>Throwable</code>信息，因为<code>logger.error(msg)</code>和<code>logger.error(msg,e.getMessage())</code>这样的日志输出方法会丢失掉最重要的StackTrace信息。</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		logger.error(e.getMessage()); <span class="comment">// 错误</span></span><br><span class="line">		logger.error(<span class="string">&quot;Bad things&quot;</span>, e.getMessage()); <span class="comment">// 错误</span></span><br><span class="line">		logger.error(<span class="string">&quot;Bad things&quot;</span>, e); <span class="comment">// 正确</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>不允许记录日志后又抛出异常，因为这样会多次记录日志，只允许记录一次日志。</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		logger.error(e.getMessage());</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Bad things&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>不允许出现System print(包括System.out.println和System.error.println)语句。</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		System.out.println(e.getMessage()); <span class="comment">// 错误</span></span><br><span class="line">		logger.error(<span class="string">&quot;Bad things&quot;</span>, e); <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>不允许出现printStackTrace。</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace(); <span class="comment">// 错误</span></span><br><span class="line">		logger.error(<span class="string">&quot;Bad things&quot;</span>, e); <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li>日志性能的考虑，如果代码为核心代码，执行频率非常高，则输出日志建议增加判断，尤其是低级别的输出&lt;<code>debug</code>、<code>info</code>、<code>warn</code>&gt;。<br> debug日志太多后可能会影响性能，有一种改进方法是：</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">	logger.info(<span class="string">&quot;returning content: &quot;</span> + content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<pre><code>但更好的方法是Slf4j提供的最佳实践:
</code></pre>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;returning content: &quot;</span> + content);</span><br></pre></td></tr></table></figure></div>

<pre><code>一方面可以减少参数构造的开销，另一方面也不用多写两行代码。
</code></pre>
<ol start="7">
<li>有意义的日志</li>
</ol>
<p>通常情况下在程序日志里记录一些比较有意义的状态数据：程序启动，退出的时间点；程序运行消耗时间；耗时程序的执行进度；重要变量的状态变化。<br>初次之外，在公共的日志里规避打印程序的调试或者提示信息。</p>
<h3 id="2-3-日志的输出"><a href="#2-3-日志的输出" class="headerlink" title="2.3 日志的输出"></a>2.3 日志的输出</h3><h4 id="2-3-1-什么时候输出"><a href="#2-3-1-什么时候输出" class="headerlink" title="2.3.1 什么时候输出"></a>2.3.1 什么时候输出</h4><blockquote>
<p>日志并不是越多越详细就越好。在分析运行日志，查找问题时，我们经常遇到该出现的日志没有，无用的日志一大堆，或者有效的日志被大量无意义的日志信息淹没，查找起来非常困难。那么什么时候输出日志呢？以下列出了一些常见的需要输出日志的情况，而且日志的级别基本都是<code>INFO</code>，至于<code>DEBUG</code>级别日志的使用场景，需要具体情况具体分析，但也是要追求“恰如其分”，不是越多越好。</p>
</blockquote>
<ol>
<li>系统启动参数、环境变量 : 系统启动的参数、配置、环境变量、<code>System.Properties</code>等信息对于软件的正常运行至关重要，这些信息的输出有助于安装配置人员通过日志快速定位问题，所以程序有必要在启动过程中把使用到的关键参数、变量在日志中输出出来。在输出时需要注意，不是一股脑的全部输出，而是将软件运行涉及到的配置信息输出出来。比如，如果软件对jvm的内存参数比较敏感，对最低配置有要求，那么就需要在日志中将<code>-Xms -Xmx -XX:PermSize</code>这几个参数的值输出出来。</li>
<li>异常捕获 : 在捕获异常处输出日志，大家在基本都能做到，唯一需要注意的是怎么输出一个简单明了的日志信息。这在后面的问题问题中有进一步说明。</li>
<li>函数获得期望之外的结果时 : 一个函数，尤其是供外部系统或远程调用的函数，通常都会有一个期望的结果，但如果内部系统或输出参数发生错误时，函数将无法返回期望的正确结果，此时就需要记录日志，日志的基本通常是<code>WARN</code>。需要特别说明的是，这里的期望之外的结果不是说没有返回就不需要记录日志了，也不是说返回<code>false</code>就需要记录日志。比如函数：<code>isXXXXX()</code>，无论返回<code>true</code>、<code>false</code>记录日志都不是必须的，但是如果系统内部无法判断应该返回<code>true</code>还是<code>false</code>时，就需要记录日志，并且日志的级别应该至少是 <code>WARN</code>。</li>
<li>关键操作 : 关键操作的日志一般是INFO级别，如果数量、频度很高，可以考虑使用DEBUG级别。以下是一些关键操作的举例，实际的关键操作肯定不止这么多。</li>
</ol>
<h4 id="2-3-2-输出什么"><a href="#2-3-2-输出什么" class="headerlink" title="2.3.2 输出什么"></a>2.3.2 输出什么</h4><ol>
<li>关键路径 : 日志并不是独立存在的,而是以一片文章阅读方式存在的</li>
<li>关键字段 : <code>UID</code> <code>CID</code> <code>AID</code> <code>RequestID</code> 一个链路上可以通过唯一一个值,即可将整个<code>I/O</code>操作串联起来的<code>Keyword</code>, 	扩展是跨项目、跨工程之间的思考</li>
<li>关键描述 : 时间、地点、人物、事件大家都玩过这个游戏吧</li>
</ol>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><blockquote>
<p>代码! 代码! 代码!</p>
</blockquote>
<blockquote>
<p>Error&#x3D;more code^2</p>
</blockquote>
<h2 id="4-如何优化"><a href="#4-如何优化" class="headerlink" title="4 如何优化"></a>4 如何优化</h2><h2 id="5-如何思考"><a href="#5-如何思考" class="headerlink" title="5 如何思考"></a>5 如何思考</h2><h2 id="6-如何避免陷入-牛角尖、瓶颈、自大、自卑、思维僵化"><a href="#6-如何避免陷入-牛角尖、瓶颈、自大、自卑、思维僵化" class="headerlink" title="6 如何避免陷入(牛角尖、瓶颈、自大、自卑、思维僵化)"></a>6 如何避免陷入(牛角尖、瓶颈、自大、自卑、思维僵化)</h2><video id="video" controls="" loop="loop" autoplay="autoplay" src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2021-04-23-0.mp4" />


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><div id="refer-anchor-1"></div>

<ul>
<li>[1] <a class="link"   href="https://zhuanlan.zhihu.com/p/104253155" >浅谈Java编码规范<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<div id="refer-anchor-2"></div>

<ul>
<li>[2] <a class="link"   href="https://www.cnblogs.com/lanxuezaipiao/p/3534447.html" >Google Java编程风格指南中文版<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<div id="refer-anchor-3"></div>

<ul>
<li>[3] <a class="link"   href="https://google.github.io/styleguide/javaguide.html" >Google Java Style Guide<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<div id="refer-anchor-4"></div>

<ul>
<li>[4] <a class="link"   href="https://www.cnblogs.com/qianjinyan/p/10341710.html" >实体entity、JavaBean、Model、POJO、domain的区别<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<div id="refer-anchor-5"></div>

<ul>
<li>[5] <a class="link"   href="https://www.cnblogs.com/huangwentian/p/10526917.html" >浅析VO、DTO、DO、PO的概念、区别和用处<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<div id="refer-anchor-6"></div>

<ul>
<li>[6] <a class="link"   href="http://www.jizhuomi.com/software/402.html" >设计模式与追妹子(23种设计模式巧妙解析，趣味理解)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<div id="refer-anchor-7"></div>

<ul>
<li>[7] <a class="link"   href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" >设计模式|菜鸟教程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<div id="refer-anchor-8"></div>

<ul>
<li>[8] [阿里巴巴开发手册]</li>
</ul>
<div id="refer-anchor-9"></div>

<ul>
<li>[9] <a class="link"   href="https://my.oschina.net/xiaominmin/blog/1599733" >java Log日志规范<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<div id="refer-anchor-10"></div>

<ul>
<li>[10] <a class="link"   href="https://blog.csdn.net/Farrell_zeng/article/details/99303649" >log日志输出规范<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的未来：2026 年及以后展望 The Future of Java: What to Expect in 2026 and Beyond</title>
    <url>/2026/01/19/Java-%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%9A2026-%E5%B9%B4%E5%8F%8A%E4%BB%A5%E5%90%8E%E5%B1%95%E6%9C%9B-The-Future-of-Java-What-to-Expect-in-2026-and-Beyond/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/java2026/0-6.webp"
                     
                ></p>
<h2 id="1-Introduction-Java’s-Evolutionary-Trajectory-引言：Java的演进轨迹"><a href="#1-Introduction-Java’s-Evolutionary-Trajectory-引言：Java的演进轨迹" class="headerlink" title="1. Introduction: Java’s Evolutionary Trajectory 引言：Java的演进轨迹"></a>1. Introduction: Java’s Evolutionary Trajectory 引言：Java的演进轨迹</h2><p>As we approach 2026, Java stands at a fascinating inflection point. Rather than merely maintaining its position, the platform is experiencing significant innovation through projects like Valhalla, Panama, Amber, and the Vector API. These initiatives represent more than incremental improvements—they fundamentally reimagine how Java handles data, interoperates with native code, and expresses developer intent.<br>随着我们迈向 2026 年，Java 正处于一个引人入胜的转折点。该平台不仅仅维持现有地位，还通过 Valhalla、Panama、Amber 和 Vector API 等项目实现了显著创新。这些举措不仅仅代表渐进式改进，它们从根本上重塑了Java处理数据、与本机代码互操作以及表达开发者意图的方式。</p>
<p>The six-month release cadence introduced with Java 9 has accelerated innovation while maintaining stability. Java 21 adoption has reached 45% within months of launch, demonstrating that the community embraces new capabilities when they deliver tangible value. This article examines the theoretical foundations, architectural principles, and strategic implications of Java’s most significant upcoming enhancements.<br>Java 9引入的六个月发布节奏在保持稳定性的同时加速了创新。Java 21在发布数月内采用率已达到45%，这表明当新功能带来切实价值时，社区乐于接受。本文将探讨Java即将到来的最重要增强功能的理论基础、架构原理和战略意义。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/java2026/1-6.png.webp"
                     
                ></p>
<h2 id="2-Project-Valhalla-Rethinking-the-Object-Model-重新思考对象模型"><a href="#2-Project-Valhalla-Rethinking-the-Object-Model-重新思考对象模型" class="headerlink" title="2. Project Valhalla: Rethinking the Object Model 重新思考对象模型"></a>2. Project Valhalla: Rethinking the Object Model 重新思考对象模型</h2><h3 id="2-1-The-Memory-Problem-Java-Must-Solve-Java-必须解决的内存问题"><a href="#2-1-The-Memory-Problem-Java-Must-Solve-Java-必须解决的内存问题" class="headerlink" title="2.1 The Memory Problem Java Must Solve Java 必须解决的内存问题"></a>2.1 The Memory Problem Java Must Solve Java 必须解决的内存问题</h3><p>Java’s object model, elegantly simple since 1995, now faces a critical mismatch with modern hardware realities. When Java was conceived, memory fetch operations and arithmetic operations had roughly equivalent costs, but today memory fetches are 200 to 1,000 times more expensive than arithmetic operations. This fundamental shift in hardware economics makes Java’s pointer-heavy approach to data representation increasingly problematic.<br>自 1995 年以来，Java 的对象模型优雅简洁，如今却面临与现代硬件现实的严重不匹配。Java 诞生时，内存取指作和算术运算的成本大致相同，但如今内存取指作的成本是算术运算的 200 到 1000 倍。硬件经济学的这一根本转变使得 Java 以指针为主的数据表示方法变得越来越棘手。</p>
<p>Consider a simple data structure like coordinates or color values. Traditional Java creates full heap objects with identity and overhead for even the smallest data carriers. This indirection cascade—where an array of objects contains references that point to scattered heap locations—destroys cache locality and forces expensive memory traversals.<br>考虑一个简单的数据结构，比如坐标或颜色值。传统 Java 能够为最小的数据载体创建带有身份和开销的完整堆对象。这种间接级联——即一组对象包含指向散布堆位置的引用——破坏了缓存的局部性，并迫使昂贵的内存遍历。</p>
<h3 id="2-2-Value-Types-Codes-Like-a-Class-Works-Like-an-Int-值类型：像类一样编码，像int一样工作"><a href="#2-2-Value-Types-Codes-Like-a-Class-Works-Like-an-Int-值类型：像类一样编码，像int一样工作" class="headerlink" title="2.2 Value Types: Codes Like a Class, Works Like an Int 值类型：像类一样编码，像int一样工作"></a>2.2 Value Types: Codes Like a Class, Works Like an Int 值类型：像类一样编码，像int一样工作</h3><p>Project Valhalla introduces value classes that combine object-oriented abstractions with primitive performance characteristics, allowing objects without identity that can have optimized encodings. The conceptual breakthrough lies in recognizing that not all objects need identity. Many data structures—coordinates, complex numbers, tuples—represent pure values rather than entities.<br>Project Valhalla 引入了将面向对象抽象与原始性能特性结合的值类，使无身份的对象能够获得优化的编码。概念上的突破在于认识到并非所有物体都需要身份。许多数据结构——坐标、复数、元组——表示纯值而非实体。</p>
<p>Value classes sacrifice identity-dependent features (reference equality via &#x3D;&#x3D;, synchronization) in exchange for dramatic memory and performance improvements. Value classes still support null since they are reference types, while primitive classes subject to stricter constraints give up null support entirely but enable even more aggressive optimizations.<br>值类牺牲了与身份相关的特征（通过&#x3D;&#x3D;、同步实现参考等式），以换取显著的内存和性能提升。值类仍然支持空，因为它们是引用类型，而受更严格约束的原始类则完全放弃了空，但允许更激进的优化。</p>
<h3 id="2-3-The-Architectural-Impact-架构影响"><a href="#2-3-The-Architectural-Impact-架构影响" class="headerlink" title="2.3 The Architectural Impact 架构影响"></a>2.3 The Architectural Impact 架构影响</h3><p>The implications extend far beyond individual objects. Early-access benchmarks from October 2025 show nearly 3x faster performance when summing years from a 50-million-element array of LocalDate instances, reducing average execution time from approximately 72 ms to 25 ms compared to identity-based objects.<br>其影响远不止于单个对象。2025 年 10 月的抢先访问基准显示，在对 5000 万元素 LocalDate 实例的数组中求和年份时，性能几乎快了 3 倍，相较于基于身份标识的对象，平均执行时间从约 72 毫秒缩短到 25 毫秒。</p>
<p>This performance gain emerges from flattening—embedding value object data directly in arrays and fields rather than storing references. Instead of an array containing pointers to scattered heap objects, you get a contiguous block of actual data, perfectly aligned for modern CPU cache architectures.<br>这种性能提升来自于扁平化——将值对象数据直接嵌入数组和字段，而不是存储引用。你得到的不是包含指向散布堆对象的指针的数组，而是连续的实际数据块，完美适配现代CPU缓存架构。</p>
<h3 id="2-4-Enhanced-Generics-and-Reification-增强泛型与具体化"><a href="#2-4-Enhanced-Generics-and-Reification-增强泛型与具体化" class="headerlink" title="2.4 Enhanced Generics and Reification 增强泛型与具体化"></a>2.4 Enhanced Generics and Reification 增强泛型与具体化</h3><p>Valhalla’s scope includes addressing Java’s long-standing generic type erasure limitation. Enhanced generics aim to enable generic types for object references, primitives, value types, and potentially void, removing the need for boxing workarounds. This means <code>List&lt;int&gt;</code> becomes possible without wrapper objects, eliminating both memory overhead and allocation pressure.<br>Valhalla 的范围包括解决 Java 长期存在的通用类型擦除限制问题。增强型泛型旨在支持对象引用、原语、值类型，甚至可能的 void 泛型，从而消除了对盒装变通方法的需求。这意味着 <code>List&lt;int&gt;</code> 无需包装对象即可实现，消除了内存开销和分配压力。</p>
<h3 id="2-5-Timeline-and-Current-Status-时间线与现状"><a href="#2-5-Timeline-and-Current-Status-时间线与现状" class="headerlink" title="2.5 Timeline and Current Status 时间线与现状"></a>2.5 Timeline and Current Status 时间线与现状</h3><p>As of October 2025, JEP 401: Value Classes and Objects has early-access builds implementing value classes with preview features available in early-access builds of JDK 26. The anticipated delivery spans multiple releases through a steady stream of enhancements rather than a single monolithic update. Realistic stabilization targets point toward Java 26-27 (2026-2027) for production readiness.<br>截至 2025 年 10 月，JEP 401：值类与对象包含早期访问版本，实现了带有预览功能的值类，这些版本可在 JDK 26 的早期体验版本中提供。预期的发布是通过持续不断的增强，跨越多个版本，而非单一的单一更新。现实的稳定目标指向 Java 26-27（2026-2027）以实现生产准备。</p>
<h2 id="3-Project-Panama-Bridging-Java-and-Native-Code-连接Java与原生代码-本机代码"><a href="#3-Project-Panama-Bridging-Java-and-Native-Code-连接Java与原生代码-本机代码" class="headerlink" title="3. Project Panama: Bridging Java and Native Code 连接Java与原生代码(本机代码)"></a>3. Project Panama: Bridging Java and Native Code 连接Java与原生代码(本机代码)</h2><h3 id="3-1-The-JNI-Problem-Statement-JNI-问题陈述"><a href="#3-1-The-JNI-Problem-Statement-JNI-问题陈述" class="headerlink" title="3.1 The JNI Problem Statement JNI 问题陈述"></a>3.1 The JNI Problem Statement JNI 问题陈述</h3><p>For decades, the Java Native Interface served as Java’s gateway to native libraries, but its complexity imposed significant costs. JNI demands expertise in both Java and native programming, often leading to error-prone glue code with performance overhead from frequent crossing boundaries, manual memory management risking leaks or crashes, and safety concerns from direct memory access.<br>几十年来，Java 原生接口一直是 Java 访问本地库的入口，但其复杂性带来了巨大的成本。JNI 要求同时具备 Java 和原生编程的专业知识，常常导致易出错的胶水代码，频繁跨越边界带来性能开销，手动内存管理可能导致泄漏或崩溃，以及直接访问内存带来的安全隐患。</p>
<h3 id="3-2-Foreign-Function-Memory-API-Architecture-外部函数与内存-API-架构"><a href="#3-2-Foreign-Function-Memory-API-Architecture-外部函数与内存-API-架构" class="headerlink" title="3.2 Foreign Function &amp; Memory API Architecture 外部函数与内存 API 架构"></a>3.2 Foreign Function &amp; Memory API Architecture 外部函数与内存 API 架构</h3><p>Project Panama’s Foreign Function and Memory API became standard in Java 22 after incubation since Java 14, providing developers a direct way to call native functions, allocate native memory, and map native data structures. The architectural elegance lies in type-safe memory access without sacrificing performance.<br>Project Panama 的外部函数与内存 API 自 Java 14 孵化后成为 Java 22 的标准，为开发者提供了直接调用本地函数、分配本地内存和映射本地数据结构的方式。架构上的优雅在于类型安全内存访问，同时不牺牲性能。</p>
<p>The API introduces several key abstractions:<br>该 API 引入了几个关键抽象：</p>
<p><strong>Memory Segments</strong> : Bounded, temporal, thread-confined views over memory sources (on-heap or off-heap). Unlike raw pointers, segments carry size information and lifecycle management.<br><strong>内存段</strong> ：对内存源（堆上或堆外）的有界、时间性、线程限制视图。与原始指针不同，分段携带大小信息和生命周期管理。</p>
<p><strong>Linker</strong> : A bridge between the JVM and C&#x2F;C++ native code (C ABI), with platform-specific implementations for Win64, SysVx64, LinuxAArch64, and MacOsAArch64.<br><strong>链接器</strong> ：连接 JVM 与 C&#x2F;C++ 原生代码（C ABI）之间的桥梁，支持针对 Win64、SysVx64、LinuxAArch64 和 MacOsAArch64 的平台特定实现。</p>
<p><strong>Function Descriptors</strong> : Type-safe specifications of native function signatures, ensuring proper marshalling between Java and native conventions.<br><strong>函数描述符</strong> ：原生函数签名的类型安全规范，确保 Java 与本地约定之间的正确编组。</p>
<p><strong>Arena-Based Memory Management</strong> : Scoped allocation that automatically releases resources, preventing the memory leaks that plague manual JNI code.<br><strong>基于 Arena 的内存管理</strong> ：有范围的分配，自动释放资源，防止困扰手动 JNI 代码的内存泄漏。</p>
<h3 id="3-3-Performance-and-Safety-Characteristics-性能与安全特性"><a href="#3-3-Performance-and-Safety-Characteristics-性能与安全特性" class="headerlink" title="3.3 Performance and Safety Characteristics 性能与安全特性"></a>3.3 Performance and Safety Characteristics 性能与安全特性</h3><p>The trade-off between safety and raw performance deserves examination. While interop code is written in Java, it cannot be considered 100% safe since the runtime must trust developer descriptions of native functions, which is why access to the foreign linker is a restricted operation requiring the <code>foreign.restricted=permit</code> flag.<br>安全性与纯性能之间的权衡值得深入探讨。虽然互作代码用 Java 编写，但不能被视为百分之百安全，因为运行时必须信任开发者对本地函数的描述，这也是访问外部链接器是受限作的原因，需要使用 <code>foreign.restricted=permit</code> 标志。</p>
<p>This design intentionally surfaces the inherent risks of native interop while providing guardrails against common errors. The API prevents many categories of bugs—buffer overruns, use-after-free, null pointer dereferences—through compile-time and runtime checks, yet acknowledges that native code boundaries represent trust boundaries.<br>这种设计有意暴露了本地互操作的内在风险，同时为常见错误提供防护措施。该 API 通过编译时和运行时检查防止了许多类型的错误——缓冲区超载、释放后使用、空指针去引用——同时承认本地代码边界代表信任边界。</p>
<h3 id="3-4-Production-Status-生产状态"><a href="#3-4-Production-Status-生产状态" class="headerlink" title="3.4 Production Status  生产状态"></a>3.4 Production Status  生产状态</h3><p>As of 2025, the FFM API is considered largely stable after rigorous refinement since Java 19, with streamlined memory management, enhanced safety measures, and customization features. The transition from preview to production in Java 22 marks a significant milestone, positioning Panama as JNI’s modern replacement for new development.<br>截至 2025 年，经过自 Java 19 以来严格优化的 FFM API 基本稳定，具备简化的内存管理、增强的安全措施和自定义功能。Java 22 从预览到生产的转变标志着一个重要里程碑，使Panama成为 JNI 新开发的现代替代品。</p>
<h2 id="4-Project-Amber-The-Evolution-of-Expression-表达能力的演进"><a href="#4-Project-Amber-The-Evolution-of-Expression-表达能力的演进" class="headerlink" title="4. Project Amber: The Evolution of Expression 表达能力的演进"></a>4. Project Amber: The Evolution of Expression 表达能力的演进</h2><h3 id="4-1-The-Ceremony-Reduction-Philosophy-仪式简化理念"><a href="#4-1-The-Ceremony-Reduction-Philosophy-仪式简化理念" class="headerlink" title="4.1 The Ceremony Reduction Philosophy 仪式简化理念"></a>4.1 The Ceremony Reduction Philosophy 仪式简化理念</h3><p>Project Amber’s mission is identifying and incubating smaller, productivity-oriented language features that make everyday Java code more readable, writable, and maintainable through a process often called right-sizing language ceremony. Unlike projects targeting performance or interoperability, Amber focuses on developer ergonomics and expressiveness.<br>Project Amber 的使命是识别并孵化更小的、以生产力为导向的语言特性，使日常 Java 代码更易读、更易写和更易维护，这一过程通常被称为“语言仪式感适度化”。与注重性能或互作性的项目不同，Amber 专注于开发者的人体工学和表现力。</p>
<h3 id="4-2-Completed-Transformations-已完成的功能"><a href="#4-2-Completed-Transformations-已完成的功能" class="headerlink" title="4.2 Completed Transformations 已完成的功能"></a>4.2 Completed Transformations 已完成的功能</h3><p>The delivered features have fundamentally altered how modern Java code looks and feels:<br>这些已交付的功能从根本上改变了现代 Java 代码的界面和体验：</p>
<p><strong>Local Variable Type Inference (var)</strong> : Eliminates redundant type declarations where the compiler can infer types, reducing noise without sacrificing type safety.<br><strong>局部变量类型推理（var）</strong> ： 消除编译器可能推断类型的冗余类型声明，减少噪声而不牺牲类型安全。</p>
<p><strong>Switch Expressions</strong> : Transformed switch from a statement to an expression with exhaustiveness checking and pattern matching capabilities, enabling concise, safe conditional logic.<br><strong>Switch表达式</strong> ：将从语句转换为具备穷尽性检查和模式匹配功能的表达式，实现简洁安全的条件逻辑。</p>
<p><strong>Text Blocks</strong> : Multi-line string literals that respect formatting, eliminating concatenation gymnastics for SQL, JSON, and HTML.<br><strong>文本块</strong> ：多行字符串文字，尊重格式，消除了 SQL、JSON 和 HTML 的串接繁琐。</p>
<p><strong>Records</strong> : Compact syntax for immutable data carriers with automatically derived equality, hashing, and toString implementations.<br><strong>记录类</strong> ：为不可变数据载体提供紧凑语法，支持自动推导的等式、哈希和 toString 实现。</p>
<p><strong>Sealed Classes</strong> : Control over inheritance hierarchies by explicitly permitting which types can extend or implement a sealed type, enabling exhaustive pattern matching.<br><strong>密封类</strong> ：通过明确允许哪些类型可以扩展或实现密封类型，控制继承层级，实现穷尽模式匹配。</p>
<p><strong>Pattern Matching</strong> : Enhanced instanceof and switch to allow pattern matching, eliminating explicit casting after type checks and enabling sophisticated data deconstruction.<br><strong>模式匹配</strong> ：增强实例和切换支持模式匹配，消除类型检查后的显式铸造，实现复杂的数据解构。</p>
<h3 id="4-3-Currently-Evolving-Features-当前演进中的功能"><a href="#4-3-Currently-Evolving-Features-当前演进中的功能" class="headerlink" title="4.3 Currently Evolving Features 当前演进中的功能"></a>4.3 Currently Evolving Features 当前演进中的功能</h3><p>For 2025, Amber focuses on finalizing four preview features: Flexible Constructor Bodies allowing code before super&#x2F;this calls, Compact Source Files and Instance Main Methods simplifying entry points, Module Import Declarations for concise package imports, and Primitive Patterns for matching on primitive types.<br>2025 年，Amber 专注于完善四个预览功能：灵活构造体支持在 <code>super/this</code> 调用前编写代码，简化入口点的紧凑源文件 <code>Compact Source Files</code> 和实例主方法，用于简洁包导入的模块导入声明，以及用于匹配原始类型的原始模式 <code>Primitive Patterns</code>。</p>
<p>Beyond these, exploratory work continues on:<br>除此之外，探索性工作仍在继续：</p>
<p><strong>Custom Deconstructors</strong> : Extending pattern matching beyond records to arbitrary classes, enabling deconstruction without requiring record constraints.<br><strong>自定义解构器</strong> ：将模式匹配扩展到任意类别，实现拆解而无需记录约束。</p>
<p><strong>Withers</strong> : A with expression that deconstructs an instance into variables, allows reassigning their values, then calls a constructor to produce a modified copy.<br><strong>Withers</strong> ：一个表达式，将实例拆解为变量，允许重新分配其值，然后调用构造函数生成修改后的副本。</p>
<p><strong>String Templates</strong> : Mechanisms for safe, efficient string interpolation that disappeared from Java 23 for redesign but remains under active development.<br><strong>字符串模板</strong> ：用于安全高效字符串插值的机制，曾在 Java 23 中因重新设计而消失，但仍在积极开发中。</p>
<h3 id="4-4-The-Data-Oriented-Programming-Paradigm-面向数据编程范式"><a href="#4-4-The-Data-Oriented-Programming-Paradigm-面向数据编程范式" class="headerlink" title="4.4 The Data-Oriented Programming Paradigm 面向数据编程范式"></a>4.4 The Data-Oriented Programming Paradigm 面向数据编程范式</h3><p>Amber’s development efforts align closely with Data-Oriented Programming, focusing on making data immutable, separating data from behavior, and designing data aggregates with clear, predictable structures. This represents a complementary approach to traditional object-oriented programming rather than replacement, providing tools for scenarios where transparent data modeling offers advantages over encapsulation.<br>Amber 的开发工作与面向数据编程高度契合，专注于使数据不可变、将数据与行为分离，并设计具有清晰、可预测结构的数据聚合。这代表了传统面向对象编程的互补方法，而非替代，为透明数据建模相较封装更有利的场景提供了工具。</p>
<h2 id="5-Vector-API-Explicit-SIMD-Programming-向量-Vector-API：显式-SIMD-编程"><a href="#5-Vector-API-Explicit-SIMD-Programming-向量-Vector-API：显式-SIMD-编程" class="headerlink" title="5. Vector API: Explicit SIMD Programming 向量(Vector) API：显式 SIMD 编程"></a>5. Vector API: Explicit SIMD Programming 向量(Vector) API：显式 SIMD 编程</h2><h3 id="5-1-The-Auto-Vectorization-Limitation-自动向量化的局限性"><a href="#5-1-The-Auto-Vectorization-Limitation-自动向量化的局限性" class="headerlink" title="5.1 The Auto-Vectorization Limitation 自动向量化的局限性"></a>5.1 The Auto-Vectorization Limitation 自动向量化的局限性</h3><p>Modern CPUs offer SIMD (Single Instruction, Multiple Data) capabilities that can perform operations on multiple data elements simultaneously. Today, developers writing scalar operations that should be vectorized need to understand HotSpot’s auto-vectorization algorithm and its limitations to achieve reliable performance, and in some cases it may not be possible to write transformable scalar operations.<br>现代 CPU 提供 SIMD（单指令，多数据）功能，可以同时对多个数据元素执行作。如今，编写应被矢量化的标量运算的开发者需要理解 HotSpot 的自动向量化算法及其局限性，以实现可靠性能，在某些情况下可能无法编写可变换的标量运算。</p>
<p>This reliance on compiler heuristics makes performance unpredictable. Simple changes that seem semantically identical can prevent vectorization, leaving developers with no reliable way to express vectorizable intent.<br>这种对编译器启发式的依赖使得性能变得不可预测。看似语义相同的简单更改可能阻止矢量化，使开发者无法可靠地表达可矢量化的意图。</p>
<h3 id="5-2-Vector-API-Design-Principles-Vector-API设计原则"><a href="#5-2-Vector-API-Design-Principles-Vector-API设计原则" class="headerlink" title="5.2 Vector API Design Principles Vector API设计原则"></a>5.2 Vector API Design Principles Vector API设计原则</h3><p>The Vector API provides vector types, operations, and factories for performing SIMD operations directly in Java, with clear and concise API capable of expressing a wide range of vector computations generic with respect to vector size, enabling portability across hardware supporting different vector sizes.<br>Vector API 提供了向量类型、作和工厂，用于直接在 Java 中执行 SIMD 作，API 清晰简洁，能够表达关于向量大小的多种通用向量计算，实现跨硬件的可移植性，支持不同向量大小。</p>
<p>The architectural approach prioritizes:<br>架构方法优先考虑：</p>
<p><strong>Platform Agnosticism</strong> : Code written using Vector API runs on x64 (SSE, AVX), ARM (NEON, SVE), and RISC-V platforms with appropriate specialization.<br><strong>平台无关性</strong>：使用Vector API 编写的代码可在 x64（SSE、AVX）、ARM（NEON、SVE）和 RISC-V 平台上运行，并具备相应的专业化。</p>
<p><strong>Predictable Compilation</strong> : On capable x64 architectures, HotSpot C2 should compile vector operations to corresponding efficient vector instructions with developer confidence that expressed operations map closely to relevant vector instructions.<br><strong>可预测编译</strong> ：在具备功能 x64 架构的条件下，HotSpot C2 应能以开发者信心将向量运算编译为对应高效的向量指令，且表达作与相关向量指令高度匹配。</p>
<p><strong>Graceful Degradation</strong> : When vector computation cannot be fully expressed as vector instructions, perhaps because the architecture doesn’t support required instructions, the implementation degrades gracefully and still functions.<br><strong>优雅降级</strong> ：当向量计算无法完全用向量指令表达时，可能因为架构不支持必需指令，实现会优雅地退化但仍能正常运行。</p>
<h3 id="5-3-Performance-Characteristics-性能特征"><a href="#5-3-Performance-Characteristics-性能特征" class="headerlink" title="5.3 Performance Characteristics 性能特征"></a>5.3 Performance Characteristics 性能特征</h3><p>Benchmarks show simplified cases of summing two large integer arrays achieving over 4x faster performance using the Vector API compared to scalar operations. Real-world gains depend heavily on data access patterns, cache behavior, and the specific operations involved.<br>基准测试展示了简化的两个大型整数组求和案例，使用Vector API 实现了标量运算速度超过 4 倍的性能。实际的收益高度依赖于数据访问模式、缓存行为以及具体作。</p>
<p>The performance story includes important caveats. Main memory accesses cost 60–100+ CPU cycles per access, so as arrays grow beyond CPU cache sizes, more memory accesses reduce Vector API benefits. Additionally, JIT auto-vectorization sometimes achieves similar results for simple patterns, making the API most valuable for complex algorithms that defeat auto-vectorization.<br>表演故事包含重要的警告。主存访问每次访问消耗 60–100+ CPU 周期，因此随着数组超过 CPU 缓存容量，更多内存访问会降低向量 API 的优势。此外，JIT 自动向量化有时也能在简单模式中取得类似效果，使得该 API 对于击败自动向量化的复杂算法尤为有价值。</p>
<h3 id="5-4-Integration-with-Panama-and-Valhalla-与Panama和Valhalla的集成"><a href="#5-4-Integration-with-Panama-and-Valhalla-与Panama和Valhalla的集成" class="headerlink" title="5.4 Integration with Panama and Valhalla 与Panama和Valhalla的集成"></a>5.4 Integration with Panama and Valhalla 与Panama和Valhalla的集成</h3><p>The Vector API leverages Intel Short Vector Math Library on x64 and SIMD Library for Evaluating Elementary Functions on ARM and RISC-V, linking to native mathematical functions using Panama’s Foreign Function &amp; Memory API. Furthermore, the Vector API uses box types as proxies for primitive types, forced by current generic limitations, with expected changes when Valhalla introduces more capable generics.<br>向量 API 利用了基于 x64 的 Intel Short Vector Math Library 和在 ARM 和 RISC-V 上计算初等函数的 SIMD 库，并通过 Panama 的 Foreign Function &amp; Memory API 链接到本地数学函数。此外，Vector API 使用盒子类型作为原始类型的代理，这是受当前通用限制所限，预计当Valhalla推出更强大的通用类型时会发生变化。</p>
<h3 id="5-5-Current-Status-and-Timeline-现状与时间线"><a href="#5-5-Current-Status-and-Timeline-现状与时间线" class="headerlink" title="5.5 Current Status and Timeline 现状与时间线"></a>5.5 Current Status and Timeline 现状与时间线</h3><p>JEP 529: Vector API (Eleventh Incubator) targeted JDK 26 in December 2025, indicating continued refinement before finalization. The extended incubation reflects the complexity of achieving consistent performance across diverse hardware platforms while maintaining API stability. Realistic stabilization likely arrives with Java 26 (2026).<br>JEP 529：Vector API（第十一孵化器）于 2025 年 12 月针对 JDK 26，表明在最终确定前还在持续完善。延长的孵化反映了在不同硬件平台上实现稳定性能的复杂性，同时保持 API 稳定性。现实稳定很可能会在 Java 26（2026 年）中实现。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/java2026/2-6.png.webp"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/java2026/3-4.png.webp"
                     
                ></p>
<h2 id="6-Module-System-Adoption-and-Reality-模块系统：采纳与现实"><a href="#6-Module-System-Adoption-and-Reality-模块系统：采纳与现实" class="headerlink" title="6. Module System: Adoption and Reality 模块系统：采纳与现实"></a>6. Module System: Adoption and Reality 模块系统：采纳与现实</h2><h3 id="6-1-JPMS-Conceptual-Foundations-JPMS-概念基础"><a href="#6-1-JPMS-Conceptual-Foundations-JPMS-概念基础" class="headerlink" title="6.1 JPMS Conceptual Foundations JPMS 概念基础"></a>6.1 JPMS Conceptual Foundations JPMS 概念基础</h3><p>The Java Platform Module System is a code-level structure that doesn’t change JAR packaging but adds a higher-level descriptor through the <code>module-info.java</code> file, making it easier for developers to organize large applications and libraries while improving platform structure and security.<br>Java 平台模块系统是一种代码级结构，不改变 JAR 封装，但通过 <code>module-info.java</code> 文件添加更高级的描述符，使开发者更容易组织大型应用和库，同时提升平台结构和安全性。</p>
<p>The module system addresses several architectural problems:<br>模块系统解决了若干架构问题：</p>
<p><strong>Classpath Hell</strong> : The classpath ultimately becomes a large, undifferentiated bucket into which all dependencies are inserted, with the module path adding a level above that acts as storage for packages while choosing which ones are accessible.<br><strong>类路径地狱</strong> ：类路径最终变成一个大型、未区分的桶，所有依赖都插入其中，模块路径在上方增加了一层，作为包的存储，同时选择哪些包是可访问的。</p>
<p><strong>Encapsulation</strong> : Modules explicitly declare which packages they export and which other modules they require, preventing accidental dependencies on internal APIs.<br><strong>封装</strong> ：模块明确声明它们导出哪些包以及需要哪些其他模块，防止对内部 API 的意外依赖。</p>
<p><strong>Explicit Dependencies</strong> : Compile-time verification of module dependencies reduces runtime surprises and facilitates static analysis.<br><strong>显式依赖</strong> ：编译时验证模块依赖，减少运行时的意外，便于静态分析。</p>
<h3 id="6-2-Adoption-Patterns-and-Challenges-采用模式与挑战"><a href="#6-2-Adoption-Patterns-and-Challenges-采用模式与挑战" class="headerlink" title="6.2 Adoption Patterns and Challenges 采用模式与挑战"></a>6.2 Adoption Patterns and Challenges 采用模式与挑战</h3><p>As of 2025, JPMS usage has grown in GraalVM native image compilation, where modular applications enable ahead-of-time optimization by excluding unused code paths, resulting in compact executables suitable for serverless and edge scenarios.<br>截至 2025 年，JPMS 在 GraalVM 原生图像编译中的应用有所增长，模块化应用通过排除未使用的代码路径实现提前优化，从而生成适合无服务器和边缘场景的紧凑可执行文件。</p>
<p>However, enterprise adoption shows a measured pace. Spring Boot has progressed toward JPMS integration, offering partial support for modular JARs in version 3 and full modularization of auto-configuration in Spring Boot 4, splitting large artifacts into targeted modules to minimize classpath pollution.<br>然而，企业的采纳速度显示出稳健的步伐。Spring Boot 已逐步实现 JPMS 集成，版本 3 部分支持模块化 JARs，Spring Boot 4 实现了自动配置的全面模块化，将大型伪造拆分为目标模块以减少类路径污染。</p>
<p>The gradual adoption reflects practical constraints. Many organizations maintain substantial legacy codebases where modularization represents significant refactoring investment. The automatic module mechanism—where non-modular JARs receive implicit module descriptors—provides a migration path but doesn’t deliver full benefits.<br>逐步采用反映了实际的限制。许多组织维护着庞大的遗留代码库，模块化需要大量重构投资。自动模块机制——非模块化 JAR 接收隐式模块描述符——提供了迁移路径，但未能带来全部优势。</p>
<h3 id="6-3-Strong-Encapsulation-Evolution-强封装的演进"><a href="#6-3-Strong-Encapsulation-Evolution-强封装的演进" class="headerlink" title="6.3 Strong Encapsulation Evolution 强封装的演进"></a>6.3 Strong Encapsulation Evolution 强封装的演进</h3><p>From Java 16 onward, strong encapsulation became the default, turning illegal accesses into errors unless explicitly allowed via flags, with Java 17 making the –illegal-access option obsolete and enforcing strict encapsulation. This progression balanced migration compatibility with security goals.<br>从 Java 16 起，强封装成为默认，除非通过标志明确允许，否则非法访问会变成错误，Java 17 使 –illegal-access 选项变得过时，并强制严格封装。这一进展平衡了迁移兼容性与安全目标。</p>
<p>The enforcement timeline demonstrates Java’s philosophy: provide warnings and migration paths, then strengthen guarantees once the community adapts. Libraries and frameworks that relied on internal JDK APIs faced breaking changes, but the extended timeline allowed orderly transitions.<br>执法时间表体现了 Java 的理念：先提供警告和迁移路径，社区适应后再加强保障。依赖内部 JDK API 的库和框架面临重大变更，但延长的时间线允许有序过渡。</p>
<h3 id="6-4-Future-of-Modular-Java-模块化-Java-的未来"><a href="#6-4-Future-of-Modular-Java-模块化-Java-的未来" class="headerlink" title="6.4 Future of Modular Java 模块化 Java 的未来"></a>6.4 Future of Modular Java 模块化 Java 的未来</h3><p>Enterprise adoption aligns with rising Java 21 use, with surveys showing 43% of developers leveraging it in Jakarta EE contexts, indicating broader integration of modular practices for maintainable, secure systems.<br>企业采用率与 Java 21 使用率的上升相符，调查显示 43%的开发者在雅加达 EE 环境中利用了它，表明模块化实践的更广泛整合，以实现可维护且安全的系统。</p>
<p>The module system’s future likely involves deeper tooling integration, improved IDE support, and clearer best practices. Java 25’s JEP 511 introduced module import declarations via import module M; syntax, allowing package-level imports of all public types from exported packages to simplify usage, showing continued evolution toward developer-friendly module interaction.<br>模块系统的未来可能涉及更深层的工具集成、改进 IDE 支持以及更清晰的最佳实践。Java 25 的 JEP 511 引入了通过 import 模块 M 实现模块导入声明;该语法允许从导出包导入所有公共类型，简化使用，显示出向开发者友好模块交互的持续演进。</p>
<h2 id="7-Community-Governance-and-the-OpenJDK-Process-社区治理与-OpenJDK-进程"><a href="#7-Community-Governance-and-the-OpenJDK-Process-社区治理与-OpenJDK-进程" class="headerlink" title="7. Community Governance and the OpenJDK Process 社区治理与 OpenJDK 进程"></a>7. Community Governance and the OpenJDK Process 社区治理与 OpenJDK 进程</h2><h3 id="7-1-The-JCP-and-JEP-Relationship-JCP-与-JEP-的关系"><a href="#7-1-The-JCP-and-JEP-Relationship-JCP-与-JEP-的关系" class="headerlink" title="7.1 The JCP and JEP Relationship JCP 与 JEP 的关系"></a>7.1 The JCP and JEP Relationship JCP 与 JEP 的关系</h3><p>The JEP process does not supplant the Java Community Process, as the JCP remains the governing body for all standard Java SE APIs and related interfaces, with accepted proposals requiring parallel efforts in the JCP through JSRs for standard interface changes.<br>JEP 流程并未取代 Java 社区进程，因为 JCP 仍然是所有标准 Java SE API 及相关接口的管理机构，而被接受的提案则需要通过 JSR 在 JCP 中进行并行的标准接口变更工作。</p>
<p>This dual-track system balances innovation and standardization:<br>这一双轨体系平衡了创新与标准化：</p>
<p><strong>JEP (JDK Enhancement Proposal)</strong> : Allows OpenJDK committers to work more informally before becoming formal Java Specification Requests, serving as long-term roadmaps for JDK Release Projects.<br><strong>JEP（JDK 增强提案）</strong> ： 允许 OpenJDK 提交者在成为正式 Java 规范请求之前更为非正式地工作，作为 JDK 发布项目的长期路线图。</p>
<p><strong>JSR (Java Specification Request)</strong> : Formal proposals defining specifications that all Java implementations must follow, ensuring consistency across vendors.<br><strong>JSR（Java 规范请求）</strong> ： 正式提案，定义所有 Java 实现必须遵循的规范，确保各厂商间的一致性。</p>
<h3 id="7-2-Decision-Making-Structure-决策结构"><a href="#7-2-Decision-Making-Structure-决策结构" class="headerlink" title="7.2 Decision-Making Structure 决策结构"></a>7.2 Decision-Making Structure 决策结构</h3><p>The OpenJDK Lead ultimately decides which JEPs to accept for inclusion into the Roadmap but relies on demonstrated expertise of Reviewers, Group Leads, and Area Leads when evaluating incoming proposals. This hierarchy acknowledges that no single person can maintain expert-level understanding across Java’s vast complexity.<br>OpenJDK 负责人最终决定哪些 JEP 被纳入路线图，但在评估新提案时，依赖评审员、组长和区域负责人的专业能力。这一层级体系承认，没有单一个人能够在 Java 庞大的复杂性中保持专家级的理解。</p>
<p>Successful JEPs require building consensus through reviewer endorsements and group&#x2F;area lead support. Endorsement by a Group or Area Lead is meant to be a reasonably strong statement equivalent to “I will argue that this JEP should be funded”.<br>成功的 JEP 需要通过评审推荐和组&#x2F;区域负责人支持来建立共识。由团体或区域负责人背书应当是一种相当有力的声明，类似于“我将主张该 JEP 应获得资金支持”。</p>
<h3 id="7-3-The-Six-Month-Release-Cadence-Impact-六个月发布节奏影响"><a href="#7-3-The-Six-Month-Release-Cadence-Impact-六个月发布节奏影响" class="headerlink" title="7.3 The Six-Month Release Cadence Impact 六个月发布节奏影响"></a>7.3 The Six-Month Release Cadence Impact 六个月发布节奏影响</h3><p>JDK 25 reached General Availability on 16 September 2025, with features and schedule tracked via the JEP Process as amended by the JEP 2.0 proposal. The predictable cadence fundamentally changed Java’s innovation model.<br>JDK 25 于 2025 年 9 月 16 日正式上市，功能和进度通过 JEP 流程（经 JEP 2.0 提案修订）进行跟踪。这种可预测的节奏从根本上改变了 Java 的创新模式。</p>
<p>Previous multi-year release cycles created pressure to include immature features to avoid missing release windows. The six-month model allows features to mature through multiple preview rounds across releases without blocking other improvements. This patience-enabling structure proves crucial for complex initiatives like Valhalla, which require extensive real-world testing before stabilization.<br>此前多年发布周期带来了压力，必须包含尚未成熟的功能，以避免错过发布窗口。六个月模式允许功能通过多次预览轮次在不同版本中成熟，而不阻碍其他改进。这种耐心驱动的结构对于像瓦尔哈拉这样需要大量真实测试才能稳定的复杂项目至关重要。</p>
<h3 id="7-4-Community-Participation-社区参与"><a href="#7-4-Community-Participation-社区参与" class="headerlink" title="7.4 Community Participation 社区参与"></a>7.4 Community Participation 社区参与</h3><p>The Java Community Process was initially formalized in December 1998, with much of Java’s success attributed to how the language evolves and how the worldwide community collaborates in that evolution. Today’s participation mechanisms include mailing lists, early-access builds, and public issue tracking.<br>Java 社区进程最初于 1998 年 12 月正式确立，Java 的成功很大程度上归功于语言的发展以及全球社区在这一演变中的协作。如今的参与机制包括邮件列表、抢先体验版本和公共议题跟踪。</p>
<p>The transparency requirements have evolved. JSR Expert Groups must hold discussions on public mailing lists, use public issue-tracking mechanisms to record progress, and publish working documents for all to see. This openness contrasts with earlier, more closed development models.<br>透明度要求已经演变。JSR 专家组必须在公开邮件列表上进行讨论，利用公开问题跟踪机制记录进展，并发布工作文件供所有人查看。这种开放性与早期更封闭的发展模式形成鲜明对比。</p>
<h2 id="8-Java’s-Competitive-Positioning-Java的竞争定位"><a href="#8-Java’s-Competitive-Positioning-Java的竞争定位" class="headerlink" title="8. Java’s Competitive Positioning Java的竞争定位"></a>8. Java’s Competitive Positioning Java的竞争定位</h2><h3 id="8-1-The-Multi-Paradigm-Landscape-多范式格局"><a href="#8-1-The-Multi-Paradigm-Landscape-多范式格局" class="headerlink" title="8.1 The Multi-Paradigm Landscape 多范式格局"></a>8.1 The Multi-Paradigm Landscape 多范式格局</h3><p>Java faces competition on multiple fronts, each representing different trade-offs:<br>Java 面临多方面的竞争，每一个领域都带来了不同的权衡：</p>
<p><strong>Kotlin</strong> : Kotlin has gained considerable momentum, particularly after Google declared it the preferred language for Android development in 2017, though Java remains far more popular with 33.27% vs 9.16% in Stack Overflow’s 2022 survey. Kotlin’s appeal lies in interoperability—it runs on the JVM and integrates seamlessly with existing Java code, enabling gradual adoption rather than wholesale rewrites.<br><strong>Kotlin</strong> ：Kotlin 获得了相当大的势头，尤其是在谷歌在 2017 年宣布其为 Android 开发首选语言之后，尽管 Java 在 Stack Overflow 2022 年调查中仍更受欢迎，达到 33.27%对 9.16%。Kotlin 的吸引力在于互作性——它运行在 JVM 上，并与现有 Java 代码无缝集成，实现渐进式采用，而非全面重写。</p>
<p><strong>Go</strong> : Designed for simplicity and concurrency, Go targets microservices and cloud infrastructure where fast compilation and straightforward deployment matter more than rich ecosystems. Go’s garbage collection and lack of generics (until recently) represent intentional trade-offs favoring simplicity.<br><strong>Go</strong> ：Go 设计为简洁和并发，面向微服务和云基础设施，在这些领域，快速编译和直接部署比丰富的生态系统更重要。Go 的垃圾收集和直到最近缺乏通用药，都是为了简化而有意做出的权衡。</p>
<p><strong>Rust</strong> : By 2025, Rust has established itself as the language of choice for systems programming, WebAssembly, and performance-critical applications, thanks to emphasis on memory safety and zero-cost abstractions. Rust’s steep learning curve and compile-time strictness target scenarios where safety and performance justify complexity.<br><strong>Rust</strong> ：到 2025 年，Rust 已成为系统编程、WebAssembly 及性能关键应用的首选语言，得益于对内存安全和零成本抽象的重视。Rust 陡峭的学习曲线和编译时的严格性，针对的是安全性和性能合理化复杂性场景。</p>
<h3 id="8-2-Java’s-Enduring-Strengths-Java的持久优势"><a href="#8-2-Java’s-Enduring-Strengths-Java的持久优势" class="headerlink" title="8.2 Java’s Enduring Strengths Java的持久优势"></a>8.2 Java’s Enduring Strengths Java的持久优势</h3><p>As of 2025, Java continues to hold around 15% to 16% of the programming language market, with 68% of applications running on Java or the JVM, and 99% of organizations actively using Java. Several factors sustain this position:<br>截至 2025 年，Java 仍占据约 15%至 16%的编程语言市场份额，68%的应用程序运行在 Java 或 JVM 上，99%的组织积极使用 Java。支持这一立场的因素有以下几点：</p>
<p><strong>Ecosystem Maturity</strong> : Decades of library development, framework evolution, and tooling refinement create network effects difficult to replicate. Spring, Jakarta EE, testing frameworks, build tools, profilers—the complete development stack exists and works well.<br><strong>生态系统成熟度</strong> ：数十年的库开发、框架演进和工具优化，造成了难以复制的网络效应。Spring、Jakarta EE、测试框架、构建工具、性能分析器——完整的开发栈都存在且运行良好。</p>
<p><strong>Enterprise Stability</strong> : Frameworks and libraries are moving to support or require newer Java versions, with Java 17 emerging as a new baseline since Spring, JUnit, Gradle 9, and upcoming Maven 4 require Java 17 or higher. This coordinated evolution maintains ecosystem coherence while advancing capabilities.<br><strong>企业稳定性</strong> ：框架和库正在支持或要求更新的 Java 版本，Java 17 作为新的基线，自 Spring 以来，JUnit、Gradle 9 以及即将推出的 Maven 4 都要求 Java 17 或更高版本。这种协调进化在提升能力的同时，维持了生态系统的连贯性。</p>
<p><strong>Performance Evolution</strong> : Java’s performance continues improving through JIT advancements, garbage collector innovations (ZGC, Shenandoah), and now the Project Valhalla and Vector API initiatives. The performance gap with lower-level languages narrows for many workloads.<br><strong>性能演进</strong> ：Java 的性能通过 JIT 的进步、垃圾回收器创新（ZGC、Shenandoah）以及现在的 Project Valhalla 和 Vector API 项目持续提升。低级别语言的性能差距在许多工作负载下会缩小。</p>
<p><strong>Cloud Native Adaptation</strong> : Interoperability between languages enables developers to integrate Rust’s high-performance components into existing Java programs, with 15% of developers using Java together with their Rust projects. This polyglot approach allows leveraging each language’s strengths rather than forcing all-or-nothing choices.<br><strong>云原生适应</strong> ：语言间的互作性使开发者能够将 Rust 的高性能组件集成到现有的 Java 程序中，15% 的开发者将 Java 与他们的 Rust 项目一起使用。这种多语种方法允许利用每种语言的优势，而非强制选择全有或全无。</p>
<h3 id="8-3-The-AI-and-Machine-Learning-Context-人工智能与机器学习背景"><a href="#8-3-The-AI-and-Machine-Learning-Context-人工智能与机器学习背景" class="headerlink" title="8.3 The AI and Machine Learning Context 人工智能与机器学习背景"></a>8.3 The AI and Machine Learning Context 人工智能与机器学习背景</h3><p>New frameworks like Embabel, Koog, Spring AI, and LangChain4j drive rapid adoption of AI-native and AI-assisted development in Java. While Python dominates machine learning research and experimentation, Java’s role in production deployment—where reliability, monitoring, and integration with existing systems matter—remains substantial.<br>像 Embabel、Koog、Spring AI 和 LangChain4j 这样的新框架推动了 Java 中 AI 原生和辅助开发的快速采用。虽然 Python 主导了机器学习的研究和实验，但 Java 在生产部署中的作用依然重要——在生产环境中，可靠性、监控以及与现有系统的集成至关重要。</p>
<h3 id="8-4-Threat-Assessment-威胁评估"><a href="#8-4-Threat-Assessment-威胁评估" class="headerlink" title="8.4 Threat Assessment 威胁评估"></a>8.4 Threat Assessment 威胁评估</h3><p>The greatest challenge isn’t displacement by a single competitor but fragmentation across specialized niches. Different languages optimize for different constraints:<br>最大的挑战不是被单一竞争者取代，而是在专业细分市场中的碎片化。不同语言针对不同约束进行优化：</p>
<ul>
<li><strong>Development Speed</strong> : Ruby, Python remain faster for MVPs and startups racing toward product-market fit<br><strong>开发速度</strong>  ：Ruby 和 Python 依然更快，对于 MVP 和初创企业，正朝着产品市场契合争取</li>
<li><strong>Native Performance</strong> : Rust, C++ maintain advantages for systems programming and embedded contexts<br><strong>原生性能</strong>  ：Rust、C++ 在系统编程和嵌入式环境中保持优势</li>
<li><strong>Simplicity</strong> : Go’s minimalism appeals to teams prioritizing maintainability over expressiveness<br><strong>简洁性</strong> ：Go 的极简主义适合优先考虑可维护性而非表现力的团队</li>
<li><strong>Mobile</strong> : Swift (iOS) and Kotlin (Android) offer superior native platform integration<br><strong>移动端</strong> ：Swift（iOS）和 Kotlin（Android）提供了更优的原生平台集成</li>
</ul>
<p>Java’s strategy appears to be expanding its range rather than defending a single niche. Valhalla targets performance-critical scenarios, Panama enables systems-level integration, Amber improves developer productivity, and the Vector API addresses numerical computing. This multi-front evolution aims to keep Java relevant across the broadest possible spectrum of use cases.<br>Java的策略似乎是扩大其产品范围，而非守护单一细分市场。Valhalla 针对性能关键场景，Panama 实现系统级集成，Amber 提升开发者生产力，Vector API 专注于数值计算。这一多方面的演进旨在保持 Java 在最广泛的用例中保持相关性。</p>
<h2 id="9-Conclusion-What-We’ve-Learned-结论：我们的收获"><a href="#9-Conclusion-What-We’ve-Learned-结论：我们的收获" class="headerlink" title="9. Conclusion: What We’ve Learned 结论：我们的收获"></a>9. Conclusion: What We’ve Learned 结论：我们的收获</h2><p>As we survey Java’s trajectory toward 2026 and beyond, several principles emerge:<br>展望Java走向2026年及以后的发展轨迹，出现了几个原则：</p>
<ol>
<li><p>Performance Through Smarter Data Representation: Project Valhalla’s value types address a fundamental architectural mismatch between Java’s object model and modern hardware, with demonstrated 3x performance improvements that could reshape Java’s positioning in performance-sensitive domains.<br>通过更智能的数据表示实现性能 ：Project Valhalla 的价值类型解决了 Java 对象模型与现代硬件之间的根本架构不匹配问题，展示了三倍的性能提升，可能重塑 Java 在性能敏感领域的定位。</p>
</li>
<li><p>Simplified Native Interoperability: Project Panama’s Foreign Function &amp; Memory API eliminates JNI complexity while maintaining type safety, finally providing a modern mechanism for the native integration that enterprise systems regularly require.<br>简化原生互作性 ：Project Panama 的外部函数与内存 API 消除了 JNI 的复杂性，同时保持类型安全，最终为企业系统日常所需的原生集成提供了现代化机制。</p>
</li>
<li><p>Expressive Power Without Ceremony: Project Amber’s continuous stream of enhancements—from pattern matching to records to sealed classes—demonstrates that productivity improvements need not compromise type safety or runtime performance.<br>无需仪式感的表达力 ：Project Amber 持续不断的改进——从模式匹配到记录再到密封类——证明了生产力提升不必牺牲类型安全或运行时性能。</p>
</li>
<li><p>Explicit Parallelism: The Vector API provides developers direct access to SIMD capabilities with platform-agnostic abstractions, addressing performance-critical scenarios that auto-vectorization cannot reliably handle.<br>显式并行性 ：向量 API 为开发者提供基于平台无关抽象的 SIMD 能力的直接访问，解决自动向量化无法可靠处理的性能关键场景。</p>
</li>
<li><p>Measured Module Adoption: While JPMS provides architectural benefits, practical adoption shows gradual progression driven by specific use cases (GraalVM native images, cloud-native applications) rather than wholesale migration pressure.<br>模块的采用率：虽然 JPMS 在架构上有优势，但实际采用则由特定用例（如 GraalVM 原生映像、云原生应用）推动，而非大规模迁移压力。</p>
</li>
<li><p>Transparent Governance: The combination of JEP and JCP processes, accelerated by the six-month release cadence, enables rapid innovation while maintaining stability and community input.<br>透明治理 ：JEP 与 JCP 流程的结合，通过六个月一次的发布周期加速，实现快速创新，同时保持稳定和社区参与。</p>
</li>
<li><p>Competitive Resilience Through Evolution: Java maintains relevance not by defending historical strengths but by expanding capabilities into adjacent domains, from low-level performance to modern language features to AI integration.<br>通过演进保持竞争韧性：Java 保持相关性，不是靠捍卫历史优势，而是通过扩展能力到邻近领域，从低级性能到现代语言特性再到人工智能集成。</p>
</li>
</ol>
<p>The Java platform entering 2026 represents something more interesting than merely maintaining legacy systems. Through careful attention to hardware realities, developer ergonomics, and ecosystem evolution, Java positions itself as a platform that can grow with changing requirements rather than one frozen in past successes. Whether this evolutionary approach successfully navigates the challenges ahead will depend on execution, community response, and the ability to deliver promised capabilities as stable, production-ready features rather than perpetual previews.<br>进入 2026 年的 Java 平台代表着比单纯维护遗留系统更有趣的事情。通过对硬件现实、开发者的人体工学和生态系统演进的细致关注，Java 定位为一个能够随着需求不断变化而成长的平台，而非停滞于过去的成功。这种进化式方法能否成功应对未来的挑战，取决于执行力、社区响应以及能否将承诺的功能作为稳定、适量生产功能而非永久预览交付。</p>
<p>The timeline ahead demands patience. Valhalla’s value types won’t reach production before 2026-2027. The Vector API continues incubating toward finalization. Yet this measured pace reflects a mature platform that values stability over rushing features to market. For organizations building systems meant to operate for decades, Java’s careful evolution and backward compatibility represent assets, not liabilities.<br>前方的时间线需要耐心等待。Valhalla的价值类型要到 2026-2027 年才会投入生产。Vector API 仍在潜伏，朝着最终成型迈进。然而，这种稳健的节奏反映了一个成熟的平台，重视稳定性而非仓促推出的功能。对于构建那些计划运行数十年的系统的组织来说，Java 的细致演进和向后兼容是资产，而非负担。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Expect</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 生成时间戳</title>
    <url>/2017/02/22/JavaScript-%E7%94%9F%E6%88%90%E6%97%B6%E9%97%B4%E6%88%B3/</url>
    <content><![CDATA[<blockquote>
<p>JS生成时间戳三种方式</p>
</blockquote>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timestamp1 = <span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="keyword">var</span> timestamp2 = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">valueOf</span>();</span><br><span class="line"><span class="keyword">var</span> timestamp3 = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()；</span><br></pre></td></tr></table></figure></div>
<h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timestamp1 = <span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure></div>
<pre><code>指定的日期和时间据 1970/1/1 午夜（GMT 时间）之间的毫秒数。
</code></pre>
<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><blockquote>
<p>1120752000000</p>
</blockquote>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timestamp2 = (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">valueOf</span>();</span><br></pre></td></tr></table></figure></div>
<pre><code>返回 1970 年 1 月 1 日至今的毫秒数。
</code></pre>
<h5 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h5><blockquote>
<p>1120752000234</p>
</blockquote>
<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timestamp3 = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()；</span><br></pre></td></tr></table></figure></div>
<pre><code>返回 Date 对象的原始值。
</code></pre>
<h5 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h5><blockquote>
<p>1120752000234</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下JDK安装</title>
    <url>/2017/02/21/Linux-%E4%B8%8BJDK%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>注意：如果系统中存在JDK 或者 OpenJDK，先卸载。</p>
</blockquote>
<h3 id="第一步-下载JDK后解压"><a href="#第一步-下载JDK后解压" class="headerlink" title="第一步 下载JDK后解压"></a>第一步 下载JDK后解压</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-*u**-linux-x64.tar.gz  -C /dir</span><br></pre></td></tr></table></figure></div>

<h3 id="第二步-设置JAVA环境变量"><a href="#第二步-设置JAVA环境变量" class="headerlink" title="第二步 设置JAVA环境变量"></a>第二步 设置JAVA环境变量</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim /root/.bash_profile</span><br></pre></td></tr></table></figure></div>

<p>编辑文件，添加一下内容</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/src/jdk1.*.*_**</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> CLASSPATH</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure></div>

<p>编辑相同内容</p>
<h3 id="第三步-使环境变量生效"><a href="#第三步-使环境变量生效" class="headerlink" title="第三步 使环境变量生效"></a>第三步 使环境变量生效</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /root/.bash_profile</span><br></pre></td></tr></table></figure></div>

<h3 id="第四部-验证JAVA环境"><a href="#第四部-验证JAVA环境" class="headerlink" title="第四部 验证JAVA环境"></a>第四部 验证JAVA环境</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java –version</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下MySQL安装</title>
    <url>/2017/02/27/Linux-%E4%B8%8BMySQL%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>注意：如果安装失败，可尝试关闭selinux和防火墙再行测试。</p>
</blockquote>
<h3 id="安装MySQL前准备"><a href="#安装MySQL前准备" class="headerlink" title="安装MySQL前准备"></a>安装MySQL前准备</h3><h5 id="第一步：安装编译源码所需的工具和库"><a href="#第一步：安装编译源码所需的工具和库" class="headerlink" title="第一步：安装编译源码所需的工具和库"></a>第一步：安装编译源码所需的工具和库</h5><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc gcc-c++ ncurses-devel perl </span><br></pre></td></tr></table></figure></div>

<h5 id="第二步：mysql-5-6版本之后需要cmake-安装cmake"><a href="#第二步：mysql-5-6版本之后需要cmake-安装cmake" class="headerlink" title="第二步：mysql 5.6版本之后需要cmake,安装cmake"></a>第二步：mysql 5.6版本之后需要cmake,安装cmake</h5><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz   </span><br><span class="line">tar -xzvf cmake-2.8.10.2.tar.gz   </span><br><span class="line"><span class="built_in">cd</span> cmake-2.8.10.2   </span><br><span class="line">./bootstrap ; make ; make install   </span><br></pre></td></tr></table></figure></div>

<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><h5 id="第一步：新建mysql用户和mysql组"><a href="#第一步：新建mysql用户和mysql组" class="headerlink" title="第一步：新建mysql用户和mysql组"></a>第一步：新建mysql用户和mysql组</h5><p>新增mysql用户组 </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd mysql </span><br></pre></td></tr></table></figure></div>

<p>新增mysql用户 </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -r -g mysql mysql </span><br></pre></td></tr></table></figure></div>

<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_27_1.jpg"
                     
                ></p>
<h5 id="第二步：新建MySQL所需要的目录"><a href="#第二步：新建MySQL所需要的目录" class="headerlink" title="第二步：新建MySQL所需要的目录"></a>第二步：新建MySQL所需要的目录</h5><p>新建mysql安装目录 </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -pv  /usr/local/mysql</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>建立mysql的安装目录，建议先创建目录<br>若不建立可能在编译安装的时候报no such irectory</p>
</blockquote>
<p>新建mysql数据库数据文件目录</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /data/mysqldb  </span><br></pre></td></tr></table></figure></div>

<p>指定mysql的数据文件的目录，建议编译安装前先创建此目录</p>
<h5 id="第三步：下载MySQL并解压"><a href="#第三步：下载MySQL并解压" class="headerlink" title="第三步：下载MySQL并解压"></a>第三步：下载MySQL并解压</h5><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.24.tar.gz</span><br><span class="line">tar -zxvf mysql-5.6.14.tar.gz</span><br></pre></td></tr></table></figure></div>

<h5 id="第四步：安装MySQL"><a href="#第四步：安装MySQL" class="headerlink" title="第四步：安装MySQL"></a>第四步：安装MySQL</h5><p>切换到 mysql-5.6.24  </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> mysql-5.6.24</span><br></pre></td></tr></table></figure></div>

<p>编译mysql，执行如下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cmake \</span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/usr/local/mysql \</span><br><span class="line">-DMYSQL_DATADIR=/usr/local/mysql/data \</span><br><span class="line">-DSYSCONFDIR=/etc \</span><br><span class="line">-DWITH_MYISAM_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_INNOBASE_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_MEMORY_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_READLINE=1 \</span><br><span class="line">-DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock \</span><br><span class="line">-DMYSQL_TCP_PORT=3306 \</span><br><span class="line">-DENABLED_LOCAL_INFILE=1 \</span><br><span class="line">-DWITH_PARTITION_STORAGE_ENGINE=1 \</span><br><span class="line">-DEXTRA_CHARSETS=all \</span><br><span class="line">-DDEFAULT_CHARSET=utf8 \</span><br><span class="line">-DDEFAULT_COLLATION=utf8_general_ci</span><br></pre></td></tr></table></figure></div>

<p>接着使用 make &amp;&amp; make install 来编译并安装</p>
<p>安装完毕的截图如下</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_27_2.jpg"
                     
                > </p>
<h3 id="安装MySQL后设置"><a href="#安装MySQL后设置" class="headerlink" title="安装MySQL后设置"></a>安装MySQL后设置</h3><h5 id="第一步：修改mysql目录属组"><a href="#第一步：修改mysql目录属组" class="headerlink" title="第一步：修改mysql目录属组"></a>第一步：修改mysql目录属组</h5><p>修改mysql安装目录</p>
<blockquote>
<p>若不修改默认的是root用户root组，启动会报错<br>（Starting MySQL..The server quit without updating PID file [FAILED]&#x2F;mysql&#x2F;Server03.mylinux.com.pid）</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/mysql   </span><br><span class="line"><span class="built_in">chown</span> -R mysql:mysql . </span><br></pre></td></tr></table></figure></div>

<p>修改mysql数据库文件目录</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/mysqldb  </span><br><span class="line"><span class="built_in">chown</span> -R mysql:mysql .  </span><br></pre></td></tr></table></figure></div>

<h5 id="第二步：初始化mysql数据库"><a href="#第二步：初始化mysql数据库" class="headerlink" title="第二步：初始化mysql数据库"></a>第二步：初始化mysql数据库</h5><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/mysql   </span><br></pre></td></tr></table></figure></div>

<p>以mysql的身份初始化</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">scripts/mysql_install_db --user=mysql --datadir=/data/mysqldb </span><br></pre></td></tr></table></figure></div>

<h5 id="第三步：复制mysql服务启动配置文件"><a href="#第三步：复制mysql服务启动配置文件" class="headerlink" title="第三步：复制mysql服务启动配置文件"></a>第三步：复制mysql服务启动配置文件</h5><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/mysql/support-files/my-default.cnf /etc/my.cnf  </span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注：如果&#x2F;etc&#x2F;my.cnf文件存在，则覆盖。</p>
</blockquote>
<h5 id="第四步：复制mysql服务启动脚本及加入PATH路径"><a href="#第四步：复制mysql服务启动脚本及加入PATH路径" class="headerlink" title="第四步：复制mysql服务启动脚本及加入PATH路径"></a>第四步：复制mysql服务启动脚本及加入PATH路径</h5><blockquote>
<p>（不用每次都要到安装目录执行mysql）</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> support-files/mysql.server /etc/init.d/mysqld     </span><br><span class="line">vim /etc/profile   </span><br><span class="line">PATH=/usr/local/mysql/bin:/usr/local/mysql/lib:<span class="variable">$PATH</span>  </span><br><span class="line"><span class="built_in">export</span> PATH  </span><br><span class="line"><span class="built_in">source</span> /etc/profile    </span><br></pre></td></tr></table></figure></div>

<h5 id="第五步：-启动mysql服务并加入开机自启动-可选这个步骤，以后可以自己启动的"><a href="#第五步：-启动mysql服务并加入开机自启动-可选这个步骤，以后可以自己启动的" class="headerlink" title="第五步： 启动mysql服务并加入开机自启动(可选这个步骤，以后可以自己启动的)"></a>第五步： 启动mysql服务并加入开机自启动(可选这个步骤，以后可以自己启动的)</h5><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld start </span><br><span class="line">chkconfig --level 35 mysqld on</span><br></pre></td></tr></table></figure></div>

<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_27_3.jpg"
                     
                > </p>
<h5 id="第六步：检查mysql服务是否启动"><a href="#第六步：检查mysql服务是否启动" class="headerlink" title="第六步：检查mysql服务是否启动"></a>第六步：检查mysql服务是否启动</h5><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tulnp | grep 3306   </span><br></pre></td></tr></table></figure></div>

<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_27_4.jpg"
                     
                ></p>
<p>到此服务器mysql已经安装并已经启动，接下来修改MySQL用户root的密码，登录测试</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root password <span class="string">&#x27;123456&#x27;</span>  </span><br></pre></td></tr></table></figure></div>

<h5 id="第七步：mysql命令登录测试"><a href="#第七步：mysql命令登录测试" class="headerlink" title="第七步：mysql命令登录测试"></a>第七步：mysql命令登录测试</h5><p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_27_5.jpg"
                     
                > </p>
<p>mysql安装完毕，成功登录</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下Tomcat安装</title>
    <url>/2017/02/26/Linux-%E4%B8%8BTomcat%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="第一步-下载tomcat"><a href="#第一步-下载tomcat" class="headerlink" title="第一步 下载tomcat"></a>第一步 下载tomcat</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://apache.fayea.com/tomcat/tomcat-*/v*.*.**/bin/apache-tomcat-*.*.**.tar.gz</span><br></pre></td></tr></table></figure></div>
<p> 或者在本地下载好tomcat安装包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_01.jpg"
                     
                ></p>
<h3 id="第二步-将tomcat移动放置到-usr-local-目录下"><a href="#第二步-将tomcat移动放置到-usr-local-目录下" class="headerlink" title="第二步 将tomcat移动放置到 &#x2F;usr&#x2F;local&#x2F; 目录下"></a>第二步 将tomcat移动放置到 &#x2F;usr&#x2F;local&#x2F; 目录下</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> apache-tomcat-*.*.**.tar.gz /usr/local/</span><br></pre></td></tr></table></figure></div>
<h3 id="第三步-将tomcat解压缩"><a href="#第三步-将tomcat解压缩" class="headerlink" title="第三步 将tomcat解压缩"></a>第三步 将tomcat解压缩</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvzf /usr/local/apache-tomcat-*.*.**.tar.gz</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_02.jpg"
                     
                ></p>
<h3 id="第四步-设置tomcat开机自启动，"><a href="#第四步-设置tomcat开机自启动，" class="headerlink" title="第四步 设置tomcat开机自启动，"></a>第四步 设置tomcat开机自启动，</h3><p>编辑&#x2F;usr&#x2F;local&#x2F;apache-tomcat-<em>.</em>.**.tar.gz&#x2F;bin&#x2F;startup.sh</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/local/apache-tomcat-*.*.**/bin/startup.sh</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_03.jpg"
                     
                ></p>
<p>添加</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#chkconfig: 2345 80 90</span></span><br><span class="line"><span class="comment">#description:tomcat auto start</span></span><br><span class="line"><span class="comment">#processname: tomcat</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_04.jpg"
                     
                ></p>
<p>编辑&#x2F;usr&#x2F;local&#x2F;apache-tomcat-<em>.</em>.**&#x2F;bin&#x2F;catalina.sh</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/local/apache-tomcat-*.*.**/bin/catalina.sh</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_05.jpg"
                     
                ></p>
<p>搜索export关键字，加入如下行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CATALINA_BASE=/usr/local/apache-tomcat-*.*.**</span><br><span class="line"><span class="built_in">export</span> CATALINA_HOME=/usr/local/apache-tomcat-*.*.**</span><br><span class="line"><span class="built_in">export</span> CATALINA_TMPDIR=/usr/local/apache-tomcat-*.*.**</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_06.jpg"
                     
                ></p>
<p>将tomcat加入开机自启动</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_07.jpg"
                     
                ></p>
<p>加入如下内容：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/jdk*.*.*_**</span><br><span class="line">/usr/local/apache-tomcat-*.*.**/bin/startup.sh start</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_08.jpg"
                     
                ></p>
<h3 id="第五步-测试Tomcat运行"><a href="#第五步-测试Tomcat运行" class="headerlink" title="第五步 测试Tomcat运行"></a>第五步 测试Tomcat运行</h3><p>执行</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/local/apache-tomcat-*.*.**/bin/startup.sh </span><br></pre></td></tr></table></figure></div>

<p>启动tomcat</p>
<p>打开浏览器测试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_09.jpg"
                     
                > </p>
<p>执行</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/local/apache-tomcat-*.*.**/bin/shutdown.sh </span><br></pre></td></tr></table></figure></div>

<p>关闭tomcat</p>
<h3 id="第六步-修改端口"><a href="#第六步-修改端口" class="headerlink" title="第六步 修改端口"></a>第六步 修改端口</h3><p>tomcat默认监听8080端口，如果要修改成为80端口，按如下步骤修改：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/local/apache-tomcat-*.*.**/conf/server.xml</span><br></pre></td></tr></table></figure></div>

<p>将</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">&quot;tomcatThreadPool&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>修改为：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;80&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">&quot;tomcatThreadPool&quot;</span> <span class="attr">port</span>=<span class="string">&quot;80&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_10.jpg"
                     
                ></p>
<p>重启tomcat生效。</p>
<p>测试Tomcat：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_02_26_11.jpg"
                     
                ></p>
<p>tomcat安装完毕。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下文件操作</title>
    <url>/2017/02/21/Linux-%E4%B8%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="linux下文件操作命令为："><a href="#linux下文件操作命令为：" class="headerlink" title="linux下文件操作命令为："></a>linux下文件操作命令为：</h3><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">复制</td>
<td align="center">cp</td>
</tr>
<tr>
<td align="center">移动</td>
<td align="center">mv</td>
</tr>
<tr>
<td align="center">删除</td>
<td align="center">rm</td>
</tr>
</tbody></table>
<h3 id="复制命令"><a href="#复制命令" class="headerlink" title="复制命令"></a>复制命令</h3><blockquote>
<p>   命令格式：cp [-adfilprsu] 源文件(source) 目标文件(destination)<br>                     cp [option] source1 source2 source3 …  directory</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">是指archive的意思，也说是指复制所有的目录</td>
</tr>
<tr>
<td align="center">-d</td>
<td align="center">若源文件为连接文件(link file)，则复制连接文件属性而非文件本身</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">强制(force)，若有重复或其它疑问时，不会询问用户，而强制复制</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">若目标文件(destination)已存在，在覆盖时会先询问是否真的操作</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">建立硬连接(hard link)的连接文件，而非复制文件本身</td>
</tr>
<tr>
<td align="center">-p</td>
<td align="center">与文件的属性一起复制，而非使用默认属性</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">递归复制，用于目录的复制操作</td>
</tr>
<tr>
<td align="center">-s</td>
<td align="center">复制成符号连接文件(symbolic link)，即“快捷方式”文件</td>
</tr>
<tr>
<td align="center">-u</td>
<td align="center">若目标文件比源文件旧，更新目标文件</td>
</tr>
</tbody></table>
<pre><code>如将/test1目录下的file1复制到/test3目录，并将文件名改为file2,可输入以下命令：
cp /test1/file1 /test3/file2
</code></pre>
<h3 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h3><blockquote>
<p>命令格式：mv [-fiv] source destination</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-f</td>
<td align="center">force，强制直接移动而不询问</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">若目标文件(destination)已经存在，就会询问是否覆盖</td>
</tr>
<tr>
<td align="center">-u</td>
<td align="center">若目标文件已经存在，且源文件比较新，才会更新</td>
</tr>
</tbody></table>
<pre><code>如将/test1目录下的file1复制到/test3 目录，并将文件名改为file2,可输入以下命令：
mv /test1/file1 /test3/file2
</code></pre>
<h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><blockquote>
<p>命令格式：rm [fir] 文件或目录</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-f</td>
<td align="center">强制删除</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">交互模式，在删除前询问用户是否操作</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">递归删除，常用在目录的删除</td>
</tr>
</tbody></table>
<pre><code>如删除/test目录下的file1文件，可以输入以下命令：
rm -i /test/file1
</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下zip压缩操作</title>
    <url>/2017/02/22/Linux-%E4%B8%8Bzip%E5%8E%8B%E7%BC%A9%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>###linux下zip压缩与解压命令为：</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">压缩</td>
<td align="center">zip</td>
</tr>
<tr>
<td align="center">解压</td>
<td align="center">unzip</td>
</tr>
</tbody></table>
<h3 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h3><blockquote>
<p>命令格式:zip [参数] [压缩后的文件名] [压缩的目录路径]</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-a</strong></td>
<td align="center">将文件转成ASCII模式</td>
</tr>
<tr>
<td align="center"><strong>-F</strong></td>
<td align="center">尝试修复损坏的压缩文件</td>
</tr>
<tr>
<td align="center"><strong>-h</strong></td>
<td align="center">显示帮助界面</td>
</tr>
<tr>
<td align="center"><strong>-m</strong></td>
<td align="center">将文件压缩之后，删除源文件</td>
</tr>
<tr>
<td align="center"><strong>-n</strong></td>
<td align="center">特定字符串 不压缩具有特定字尾字符串的文件</td>
</tr>
<tr>
<td align="center"><strong>-o</strong></td>
<td align="center">将压缩文件内的所有文件的最新变动时间设为压缩时候的时间</td>
</tr>
<tr>
<td align="center"><strong>-q</strong></td>
<td align="center">安静模式，在压缩的时候不显示指令的执行过程</td>
</tr>
<tr>
<td align="center"><strong>-r</strong></td>
<td align="center">将指定的目录下的所有子目录以及文件一起处理</td>
</tr>
<tr>
<td align="center"><strong>-S</strong></td>
<td align="center">包含系统文件和隐含文件（S是大写）</td>
</tr>
<tr>
<td align="center"><strong>-t</strong></td>
<td align="center">日期 把压缩文件的最后修改日期设为指定的日期，日期格式为mmddyyyy</td>
</tr>
</tbody></table>
<h3 id="解压命令"><a href="#解压命令" class="headerlink" title="解压命令"></a>解压命令</h3><blockquote>
<p>命令格式:unzip [参数] [需要解压的文件名]</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-l</strong></td>
<td align="center">列出压缩文件所包含的内容</td>
</tr>
<tr>
<td align="center"><strong>-v</strong></td>
<td align="center">显示详细的执行过程</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 定时上报公网IP到Github</title>
    <url>/2024/07/30/Linux-%E5%AE%9A%E6%97%B6%E4%B8%8A%E6%8A%A5%E5%85%AC%E7%BD%91IP%E5%88%B0Github/</url>
    <content><![CDATA[<h2 id="获取公网IP"><a href="#获取公网IP" class="headerlink" title="获取公网IP"></a>获取公网IP</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl icanhazip.com</span><br></pre></td></tr></table></figure></div>

<h2 id="在Linux中，你可以使用date命令获取当前日期和时间。以下是一些常用的date命令用法示例"><a href="#在Linux中，你可以使用date命令获取当前日期和时间。以下是一些常用的date命令用法示例" class="headerlink" title="在Linux中，你可以使用date命令获取当前日期和时间。以下是一些常用的date命令用法示例:"></a>在Linux中，你可以使用date命令获取当前日期和时间。以下是一些常用的date命令用法示例:</h2><p>获取当前日期和时间:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure></div>

<p>获取当前日期:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> +%Y-%m-%d</span><br></pre></td></tr></table></figure></div>

<p>获取当前时间:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> +%H:%M:%S</span><br></pre></td></tr></table></figure></div>

<p>获取当前日期和时间，并自定义格式:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> +<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这里的 <code>+%Y-%m-%d</code> , <code>+%H:%M:%S</code>  是格式化字符串，分别代表年-月-日、时:分:秒。你可以根据需要自定义这些格式。</p>
<h2 id="打印公网IP-日期时间"><a href="#打印公网IP-日期时间" class="headerlink" title="打印公网IP + 日期时间"></a>打印公网IP + 日期时间</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(curl icanhazip.com) - $(<span class="built_in">date</span>) &gt; ip.yaml</span><br></pre></td></tr></table></figure></div>

<h2 id="git-commit-动态加入日期"><a href="#git-commit-动态加入日期" class="headerlink" title="git commit 动态加入日期"></a>git commit 动态加入日期</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Your commit message <span class="subst">$(date +&#x27;%Y-%m-%d&#x27;)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="git-提交"><a href="#git-提交" class="headerlink" title="git 提交"></a>git 提交</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">vim report.sh</span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="built_in">echo</span> $(curl icanhazip.com) - $(<span class="built_in">date</span>) &gt; /path/to/ip.yaml</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;feat: <span class="subst">$(date &#x27;+%Y-%m-%d&#x27;)</span>&quot;</span></span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure></div>

<h2 id="在Linux中，可以使用cron来设置定时任务执行-sh脚本。以下是设置定时任务的步骤"><a href="#在Linux中，可以使用cron来设置定时任务执行-sh脚本。以下是设置定时任务的步骤" class="headerlink" title="在Linux中，可以使用cron来设置定时任务执行.sh脚本。以下是设置定时任务的步骤"></a>在Linux中，可以使用cron来设置定时任务执行.sh脚本。以下是设置定时任务的步骤</h2><p>打开终端。</p>
<p>输入crontab -e命令编辑当前用户的cron任务。</p>
<p>在打开的编辑器中，添加定时任务的行。</p>
<p>保存并退出编辑器。</p>
<p>例如，如果你想每天早上5点执行名为script.sh的脚本，你可以这样设置:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">0 5 * * * /path/to/script.sh</span><br></pre></td></tr></table></figure></div>

<p>这行的意思是:分钟(0) 小时(5) 每天的哪个小时() 每月的哪一天() 每年的哪一月(*)</p>
<p>确保你的.sh脚本有执行权限:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /path/to/script.sh</span><br></pre></td></tr></table></figure></div>

<p>如果你的script.sh在当前用户的home目录下，并且已经有执行权限，则可以直接使用相对路径:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">0 5 * * * ./script.sh</span><br></pre></td></tr></table></figure></div>

<p>注意:如果脚本中有相对路径，请确保这些相对路径是相对于当前工作目录(不是脚本文件本身的位置)。</p>
<h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure></div>

<h2 id="要查看当前用户的-crontab-定时任务"><a href="#要查看当前用户的-crontab-定时任务" class="headerlink" title="要查看当前用户的 crontab(定时任务)"></a>要查看当前用户的 crontab(定时任务)</h2><p>要查看当前用户的 crontab(定时任务)，可以使用以下命令:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure></div>

<p>这条命令会列出当前用户的所有 crontab 任务。如果 crontab 为空，则不会显示任何内容。</p>
<p>如果你想查看其他用户的 crontab(例如 root 用户)，你可以使用以下命令:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo crontab -l -u username</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>username</code> 是你要查看其 crontab 的用户名。使用 <code>sudo</code> 是因为只有 root 或者有 sudo 权限的用户才能查看其他用户的 crontab。</p>
<h2 id="crontab-使用-vim-模式"><a href="#crontab-使用-vim-模式" class="headerlink" title="crontab 使用 vim 模式"></a>crontab 使用 vim 模式</h2><p>如果你想在编辑 crontab 文件时使用 Vim 编辑器而不是默认的 Nano 编辑器，可以按照以下步骤操作:</p>
<h3 id="设置默认编辑器"><a href="#设置默认编辑器" class="headerlink" title="设置默认编辑器"></a><strong>设置默认编辑器</strong></h3><p>在终端中运行以下命令，选择 Vim 作为默认的 crontab 编辑器:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> VISUAL=vim</span><br><span class="line"><span class="built_in">export</span> EDITOR=vim</span><br></pre></td></tr></table></figure></div>

<p>这两条命令将 VISUAL 和 EDITOR 环境变量设置为 vim。你也可以将它们添加到你的 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 文件中，这样每次打开终端时都会自动设置。</p>
<h3 id="编辑-crontab-文件"><a href="#编辑-crontab-文件" class="headerlink" title="编辑 crontab 文件"></a><strong>编辑 crontab 文件</strong></h3><p>现在，运行 <code>crontab -e</code> 命令会自动使用 Vim 编辑器打开 crontab 文件。你可以像在普通的 Vim 中编辑文件一样进行操作。</p>
<h3 id="保存和退出"><a href="#保存和退出" class="headerlink" title="保存和退出"></a><strong>保存和退出</strong></h3><p>在 Vim 编辑器中，按下 <code>Esc</code> 键进入命令模式，然后输入 <code>:wq</code> 并按 <code>Enter</code> 键保存并退出文件。</p>
<p>通过这种方法，你可以使用 Vim 编辑器来编辑 crontab 文件，而不是默认的 Nano 编辑器。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 工具 btop 安装</title>
    <url>/2024/07/28/Linux-%E5%B7%A5%E5%85%B7-btop-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/linux/btop.png"
                      alt="btop"
                ><figcaption>btop</figcaption></figure></p>
<p><a class="link"   href="https://github.com/aristocratos/btop" >btop<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="Debain-安装"><a href="#Debain-安装" class="headerlink" title="Debain 安装"></a>Debain 安装</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install btop</span><br><span class="line">btop</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Program</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 将可执行文件设为全局可用</title>
    <url>/2024/07/01/Linux-%E5%B0%86%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%AE%BE%E4%B8%BA%E5%85%A8%E5%B1%80%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s &lt;binary-path&gt;/&lt;binary-name&gt; /usr/bin/&lt;binary-name&gt;</span><br></pre></td></tr></table></figure></div>

<p>或</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> &lt;binary-name&gt; /usr/local/bin/</span><br></pre></td></tr></table></figure></div>

<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:/usr/local/&lt;binary-name&gt;&quot;</span> &gt;&gt; ~/.profile &amp;&amp; <span class="built_in">source</span> ~/.profile</span><br></pre></td></tr></table></figure></div>


<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li><code>/usr/local/bin/</code> 用户安装的</li>
<li><code>/usr/bin/</code> 系统安装的，系统更新时可能发生覆盖</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a class="link"   href="https://stackoverflow.com/questions/14637979/how-to-permanently-set-path-on-linux-unix" >How to permanently set $PATH on Linux&#x2F;Unix [closed]<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://unix.stackexchange.com/questions/4186/what-is-usr-local-bin" >What is &#x2F;usr&#x2F;local&#x2F;bin?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 工具 htop 源码安装</title>
    <url>/2024/07/26/Linux-%E5%B7%A5%E5%85%B7-htop-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/linux/htop-2.0.png"
                      alt="htop"
                ><figcaption>htop</figcaption></figure></p>
<p><a class="link"   href="https://htop.dev/" >htop<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. 准备环境</h3><p>首先确保系统中已经安装了编译 <code>htop</code> 所需的工具和库：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install gcc-c++ ncurses-devel</span><br></pre></td></tr></table></figure></div>

<h3 id="2-下载-htop-源码"><a href="#2-下载-htop-源码" class="headerlink" title="2. 下载 htop 源码"></a>2. 下载 <code>htop</code> 源码</h3><p>从 <code>htop</code> 的 GitHub 仓库下载最新的源码包：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/htop-dev/htop/archive/refs/tags/3.3.0.tar.gz -O htop-3.1.2.tar.gz</span><br></pre></td></tr></table></figure></div>

<p>解压下载的源码包：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf htop-3.3.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> htop-3.3.0</span><br></pre></td></tr></table></figure></div>

<h3 id="3-编译和安装"><a href="#3-编译和安装" class="headerlink" title="3. 编译和安装"></a>3. 编译和安装</h3><p>在源码目录中，执行以下命令编译和安装 <code>htop</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></div>

<h3 id="4-运行-htop"><a href="#4-运行-htop" class="headerlink" title="4. 运行 htop"></a>4. 运行 <code>htop</code></h3><p>安装完成后，你可以通过以下命令启动 <code>htop</code>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">htop</span><br></pre></td></tr></table></figure></div>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在编译之前，确保系统中已经安装了 <code>gcc</code>、<code>g++</code> 和 <code>ncurses</code> 库。</li>
<li>如果出现依赖项缺失的情况，根据错误信息安装相应的依赖项。</li>
<li>编译安装的 <code>htop</code> 可能需要在 <code>sudo</code> 下进行，以便将二进制文件复制到系统路径中。</li>
</ul>
<p>通过这些步骤，你应该可以成功地从源码编译和安装 <code>htop</code>，并在 CentOS 系统上使用它来监控和管理系统进程。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 防火墙端口开放</title>
    <url>/2024/06/22/Linux-%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE/</url>
    <content><![CDATA[<h2 id="端口开放"><a href="#端口开放" class="headerlink" title="端口开放"></a>端口开放</h2><p>在Linux中，要开放一个端口，通常需要使用iptables或者firewalld（如果安装了firewalld的话）。</p>
<p>以下是两种情况的示例：</p>
<ol>
<li>使用iptables开放端口（例如开放TCP端口8080）：</li>
</ol>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>如果你的系统使用firewalld，可以使用以下命令：</li>
</ol>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --add-port=8080/tcp</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></div>

<p>请确保替换8080为你想要开放的实际端口号，并根据你的实际情况选择使用iptables还是firewalld。</p>
<p>注意：如果你的系统使用的是ufw，可以使用以下命令：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 8080/tcp</span><br></pre></td></tr></table></figure></div>

<p>这些命令将允许进入指定端口的流量。如果你需要指定IP范围或者其他更复杂的规则，你可能需要编辑iptables的规则或者使用firewalld的更高级功能。</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Log Java常见日志框架</title>
    <url>/2026/01/13/Log-Java%E5%B8%B8%E8%A7%81%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<ul>
<li><a class="link"   href="https://blog.csdn.net/imjcoder/article/details/121688831" >Java日志-总结<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7029968437933768734" >Java 日志记录最佳实践<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/560751693" >别再乱打日志了<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/367591121" >90%的开发不懂Java日志!<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/490155854" >十分钟搞定Java日志体系<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<h2 id="常用日志"><a href="#常用日志" class="headerlink" title="常用日志"></a>常用日志</h2><ol>
<li>JDK日志</li>
<li>log4j系列</li>
<li>logbak系列</li>
</ol>
<h3 id="JDK日志-java-util-logging-jul"><a href="#JDK日志-java-util-logging-jul" class="headerlink" title="JDK日志 (java.util.logging&#x3D;jul)"></a>JDK日志 (java.util.logging&#x3D;jul)</h3><blockquote>
<p>从jdk1.4起，JDK开始自带一套日志系统。JDK Logger最大的优点就是不需要任何类库的支持，只要有Java的运行环境就可以使用。相对于其他的日志框架，JDK自带的日志可谓是鸡肋，无论易用性，功能还是扩展性都要稍逊一筹，所以在商业系统中很少直接使用。</p>
</blockquote>
<p>JDK默认的logging配置文件为：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$JAVA_HOME</span>/jre/lib/logging.properties</span><br></pre></td></tr></table></figure></div>

<p>可以使用系统属性java.util.logging.config.file指定相应的配置文件对默认的配置文件进行覆盖，比如</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">java -Djava.util.logging.config.file=myfile</span><br></pre></td></tr></table></figure></div>

<p>JDK Logging 把日志分为如下七个级别，等级依次降低。</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>SERVER</th>
<th>WARNING</th>
<th>INFO</th>
<th>CONFIG</th>
<th>FINE</th>
<th>FINER</th>
<th>FINEST</th>
</tr>
</thead>
<tbody><tr>
<td>调用方法</td>
<td>server()</td>
<td>warning()</td>
<td>info()</td>
<td>config()</td>
<td>fine()</td>
<td>finer</td>
<td>finest</td>
</tr>
<tr>
<td>含义</td>
<td>严重</td>
<td>警告</td>
<td>信息</td>
<td>配置</td>
<td>良好</td>
<td>较好</td>
<td>最好</td>
</tr>
</tbody></table>
<p>如果将级别设置为INFO，则INFO后面的不会输出。info前面的全部输出。通过控制级别达到控制输出的目的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogJDKTest</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> Logger.getLogger(LogJDKTest.class.toString());</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              <span class="comment">// all→finest→finer→fine→config→info→warning→server→off</span></span><br><span class="line">              <span class="comment">// 级别依次升高，后面的日志级别会屏蔽之前的级别</span></span><br><span class="line">              log.setLevel(Level.INFO);</span><br><span class="line">              log.finest(<span class="string">&quot;finest&quot;</span>);</span><br><span class="line">              log.finer(<span class="string">&quot;finer&quot;</span>);</span><br><span class="line">              log.fine(<span class="string">&quot;fine&quot;</span>);</span><br><span class="line">              log.config(<span class="string">&quot;config&quot;</span>);</span><br><span class="line">              log.info(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">              log.warning(<span class="string">&quot;warning&quot;</span>);</span><br><span class="line">              log.severe(<span class="string">&quot;server&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>控制台输出：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">六月 23, 2021 11:07:29 上午 com.test.log.LogJDKTest main</span><br><span class="line">信息: info</span><br><span class="line">六月 23, 2021 11:07:29 上午 com.test.log.LogJDKTest main</span><br><span class="line">警告: warning</span><br><span class="line">六月 23, 2021 11:07:29 上午 com.test.log.LogJDKTest main</span><br><span class="line">严重: server</span><br></pre></td></tr></table></figure></div>

<p>1.JDK log默认会有一个控制台输出，它有两个参数，第一个参数设置输出级别，第二个参数设置输出的字符串。<br>2.同时也可以设置多个输出（Hander），每个输出设置不用的level，然后通过addHandler添加到了log中。</p>
<p>注意：为log设置级别与为每个handler设置级别的意义是不同的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.ConsoleHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Handler;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogJDKTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> Logger.getLogger(LogJDKTest.class.toString());</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">console</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleHandler</span>();</span><br><span class="line">        console.setLevel(Level.SEVERE);</span><br><span class="line">        log.addHandler(console);</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">console2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleHandler</span>();</span><br><span class="line">        console2.setLevel(Level.INFO);</span><br><span class="line">        log.addHandler(console2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// all→finest→finer→fine→config→info→warning→server→off</span></span><br><span class="line">        <span class="comment">// 级别依次升高，后面的日志级别会屏蔽之前的级别</span></span><br><span class="line">        log.setLevel(Level.INFO);</span><br><span class="line">        log.finest(<span class="string">&quot;finest&quot;</span>);</span><br><span class="line">        log.finer(<span class="string">&quot;finer&quot;</span>);</span><br><span class="line">        log.fine(<span class="string">&quot;fine&quot;</span>);</span><br><span class="line">        log.config(<span class="string">&quot;config&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">        log.warning(<span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        log.severe(<span class="string">&quot;server&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>控制台输出：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">六月 23, 2021 11:09:03 上午 com.middleware.test.log.LogJDKTest main</span><br><span class="line">信息: info</span><br><span class="line">六月 23, 2021 11:09:03 上午 com.middleware.test.log.LogJDKTest main</span><br><span class="line">警告: warning</span><br><span class="line">六月 23, 2021 11:09:03 上午 com.middleware.test.log.LogJDKTest main</span><br><span class="line">严重: server</span><br><span class="line">六月 23, 2021 11:09:03 上午 com.middleware.test.log.LogJDKTest main</span><br><span class="line">严重: server</span><br></pre></td></tr></table></figure></div>

<p>all，则所有的信息都会被输出，如果设为off，则所有的信息都不会输出。</p>
<h3 id="log4j1"><a href="#log4j1" class="headerlink" title="log4j1"></a>log4j1</h3><blockquote>
<p>Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务 器、NT的事件记录器、UNIX Syslog守护进程等；用户也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，用户能够更加细致地控制日志的生成过程。这些可以通过一个 配置文件来灵活地进行配置，而不需要修改程序代码。</p>
</blockquote>
<p>导入maven</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在resources同级创建并设置log4j.properties</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 设置###</span></span><br><span class="line"><span class="string">log4j.rootLogger</span> <span class="string">=</span> <span class="string">debug,stdout,D,E</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">### 输出信息到控制抬 ###</span></span><br><span class="line"><span class="string">log4j.appender.stdout</span> <span class="string">=</span> <span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="string">log4j.appender.stdout.Target</span> <span class="string">=</span> <span class="string">System.out</span></span><br><span class="line"><span class="string">log4j.appender.stdout.layout</span> <span class="string">=</span> <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="string">log4j.appender.stdout.layout.ConversionPattern</span> <span class="string">=</span> [<span class="string">%-5p</span>] <span class="string">%d&#123;yyyy-MM-dd</span> <span class="string">HH:mm:ss,SSS&#125;</span> <span class="string">method:%l%n%m%n</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">### 输出DEBUG 级别以上的日志到=E://logs/error.log ###</span></span><br><span class="line"><span class="string">log4j.appender.D</span> <span class="string">=</span> <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="string">log4j.appender.D.File</span> <span class="string">=</span> <span class="string">E://logs/log.log</span></span><br><span class="line"><span class="string">log4j.appender.D.Append</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">log4j.appender.D.Threshold</span> <span class="string">=</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="string">log4j.appender.D.layout</span> <span class="string">=</span> <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="string">log4j.appender.D.layout.ConversionPattern</span> <span class="string">=</span> <span class="string">%-d&#123;yyyy-MM-dd</span> <span class="string">HH:mm:ss&#125;</span>  [ <span class="string">%t:%r</span> ] <span class="bullet">-</span> [ <span class="string">%p</span> ]  <span class="string">%m%n</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span></span><br><span class="line"><span class="string">log4j.appender.E</span> <span class="string">=</span> <span class="string">org.apache.log4j.DailyRollingFileAppender</span></span><br><span class="line"><span class="string">log4j.appender.E.File</span> <span class="string">=E://logs/error.log</span></span><br><span class="line"><span class="string">log4j.appender.E.Append</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">log4j.appender.E.Threshold</span> <span class="string">=</span> <span class="string">ERROR</span></span><br><span class="line"><span class="string">log4j.appender.E.layout</span> <span class="string">=</span> <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="string">log4j.appender.E.layout.ConversionPattern</span> <span class="string">=</span> <span class="string">%-d&#123;yyyy-MM-dd</span> <span class="string">HH:mm:ss&#125;</span>  [ <span class="string">%t:%r</span> ] <span class="bullet">-</span> [ <span class="string">%p</span> ]  <span class="string">%m%n</span></span><br></pre></td></tr></table></figure></div>

<p>设置日志内容</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLog4j</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TestLog4j.class);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录debug级别的信息</span></span><br><span class="line">        logger.debug(<span class="string">&quot;This is debug message.&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录info级别的信息</span></span><br><span class="line">        logger.info(<span class="string">&quot;This is info message.&quot;</span>);</span><br><span class="line">        <span class="comment">// 记录error级别的信息</span></span><br><span class="line">        logger.error(<span class="string">&quot;This is error message.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>控制台的信息</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">[DEBUG] 2021-06-23 12:00:46,717 method:com.middleware.test.log.TestLog4j.main(TestLog4j.java:11)</span><br><span class="line">This is debug message.</span><br><span class="line">[INFO ] 2021-06-23 12:00:46,719 method:com.middleware.test.log.TestLog4j.main(TestLog4j.java:13)</span><br><span class="line">This is info message.</span><br><span class="line">[ERROR] 2021-06-23 12:00:46,719 method:com.middleware.test.log.TestLog4j.main(TestLog4j.java:15)</span><br><span class="line">This is error message.</span><br></pre></td></tr></table></figure></div>

<h3 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h3><p>导入maven包</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>测试代码</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger(LogManager.ROOT_LOGGER_NAME);</span><br><span class="line"> </span><br><span class="line">        logger.trace(<span class="string">&quot;trace level&quot;</span>);</span><br><span class="line">        logger.debug(<span class="string">&quot;debug level&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;info level&quot;</span>);</span><br><span class="line">        logger.warn(<span class="string">&quot;warn level&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;error level&quot;</span>);</span><br><span class="line">        logger.fatal(<span class="string">&quot;fatal level&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        logger.error(<span class="string">&quot;字符串拼接一：&#123;&#125;,记录main执行：&quot;</span>,<span class="string">&quot;logger&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;字符串拼接二：&quot;</span>,<span class="string">&quot;logger&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h3><blockquote>
<p>Logback是由log4j创始人设计的又一个开源日记组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个 改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日记系统如log4j或JDK14 Logging。logback-access访问模块与Servlet容器集成提供通过Http来访问日记的功能。</p>
</blockquote>
<p>Logback是由log4j创始人设计的另一个开源日志组件,官方网站： Logback Home。它当前分为下面下个模块：</p>
<ul>
<li>logback-core：其它两个模块的基础模块</li>
<li>logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging</li>
<li>logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能</li>
</ul>
<h4 id="logback取代log4j的理由"><a href="#logback取代log4j的理由" class="headerlink" title="logback取代log4j的理由"></a>logback取代log4j的理由</h4><ol>
<li>更快的实现：Logback的内核重写了，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升了，初始化内存加载也更小了。</li>
<li>非常充分的测试：Logback经过了几年，数不清小时的测试。Logback的测试完全不同级别的。</li>
<li>Logback-classic非常自然实现了SLF4j：Logback-classic实现了SLF4j。在使用SLF4j中，你都感觉不到logback-classic。而且因为logback-classic非常自然地实现了slf4j ， 所 以切换到log4j或者其他，非常容易，只需要提供成另一个jar包就OK，根本不需要去动那些通过SLF4JAPI实现的代码。</li>
<li>非常充分的文档 官方网站有两百多页的文档。</li>
<li>自动重新加载配置文件，当配置文件修改了，Logback-classic能自动重新加载配置文件。扫描过程快且安全，它并不需要另外创建一个扫描线程。这个技术充分保证了应用程序能跑得很欢在JEE环境里面。</li>
<li>Lilith是log事件的观察者，和log4j的chainsaw类似。而lilith还能处理大数量的log数据 。</li>
<li>谨慎的模式和非常友好的恢复，在谨慎模式下，多个FileAppender实例跑在多个JVM下，能 够安全地写道同一个日志文件。RollingFileAppender会有些限制。Logback的FileAppender和它的子类包括 RollingFileAppender能够非常友好地从I&#x2F;O异常中恢复。</li>
<li>配置文件可以处理不同的情况，开发人员经常需要判断不同的Logback配置文件在不同的环境下（开发，测试，生产）。而这些配置文件仅仅只有一些很小的不同，可以通过,和来实现，这样一个配置文件就可以适应多个环境。</li>
<li>Filters（过滤器）有些时候，需要诊断一个问题，需要打出日志。在log4j，只有降低日志级别，不过这样会打出大量的日志，会影响应用性能。在Logback，你可以继续 保持那个日志级别而除掉某种特殊情况，如alice这个用户登录，她的日志将打在DEBUG级别而其他用户可以继续打在WARN级别。要实现这个功能只需加4行XML配置。可以参考MDCFIlter 。</li>
<li>SiftingAppender（一个非常多功能的Appender）：它可以用来分割日志文件根据任何一个给定的运行参数。如，SiftingAppender能够区别日志事件跟进用户的Session，然后每个用户会有一个日志文件。</li>
<li>自动压缩已经打出来的log：RollingFileAppender在产生新文件的时候，会自动压缩已经打出来的日志文件。压缩是个异步过程，所以甚至对于大的日志文件，在压缩过程中应用不会受任何影响。</li>
<li>堆栈树带有包版本：Logback在打出堆栈树日志时，会带上包的数据。</li>
<li>自动去除旧的日志文件：通过设置TimeBasedRollingPolicy或者SizeAndTimeBasedFNATP的maxHistory属性，你可以控制已经产生日志文件的最大数量。如果设置maxHistory 12，那那些log文件超过12个月的都会被自动移除。</li>
</ol>
<h4 id="logback的配置介绍"><a href="#logback的配置介绍" class="headerlink" title="logback的配置介绍"></a>logback的配置介绍</h4><ul>
<li>Logger、appender及layout<br>Logger作为日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别。<br>Appender主要用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、 MySQL、PostreSQL、 Oracle和其他数据库、 JMS和远程UNIX Syslog守护进程等。<br>Layout 负责把事件转换成字符串，格式化的日志信息的输出。</li>
<li>logger context<br>各个logger 都被关联到一个 LoggerContext，LoggerContext负责制造logger，也负责以树结构排列各logger。其他所有logger也通过org.slf4j.LoggerFactory 类的静态方法getLogger取得。 getLogger方法以 logger名称为参数。用同一名字调用LoggerFactory.getLogger 方法所得到的永远都是同一个logger对象的引用。</li>
<li>有效级别及级别的继承<br>Logger 可以被分配级别。级别包括：TRACE、DEBUG、INFO、WARN 和 ERROR，定义于ch.qos.logback.classic.Level类。如果 logger没有被分配级别，那么它将从有被分配级别的最近的祖先那里继承级别。root logger 默认级别是 DEBUG。</li>
<li>打印方法与基本的选择规则<br>打印方法决定记录请求的级别。例如，如果 L 是一个 logger 实例，那么，语句 L.info(“..”)是一条级别为 INFO的记录语句。记录请求的级别在高于或等于其 logger 的有效级别时被称为被启用，否则，称为被禁用。记录请求级别为 p，其 logger的有效级别为 q，只有则当 p&gt;&#x3D;q时，该请求才会被执行。</li>
</ul>
<p>该规则是 logback 的核心。级别排序为： TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR</p>
<h4 id="logback的默认配置"><a href="#logback的默认配置" class="headerlink" title="logback的默认配置"></a>logback的默认配置</h4><p>如果配置文件 logback-test.xml 和 logback.xml 都不存在，那么 logback 默认地会调用BasicConfigurator ，创建一个最小化配置。最小化配置由一个关联到根 logger 的ConsoleAppender 组成。输出用模式为%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n 的 PatternLayoutEncoder 进行格式化。root logger 默认级别是 DEBUG。</p>
<ul>
<li>Logback的配置文件<br>Logback 配置文件的语法非常灵活。正因为灵活，所以无法用 DTD 或 XML schema 进行定义。尽管如此，可以这样描述配置文件的基本结构：以<configuration>开头，后面有零个或多个<appender>元素，有零个或多个<logger>元素，有最多一个<root>元素。</li>
<li>Logback默认配置的步骤<ol>
<li>尝试在 classpath下查找文件logback-test.xml；</li>
<li>如果文件不存在，则查找文件logback.xml；</li>
<li>如果两个文件都不存在，logback用BasicConfigurator自动对自己进行配置，这会导致记录输出到控制台。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Log</tag>
        <tag>日志</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Log 如何打印好一份日志</title>
    <url>/2026/01/12/Log-%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E5%A5%BD%E4%B8%80%E4%BB%BD%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<blockquote>
<p><code>写不好日志的程序员，就像不会写病历的医生</code></p>
</blockquote>
<p><em>打日志远不止是“把变量打印出来”那么简单。</em> 它是一项需要深刻理解业务、具备前瞻性思维、并兼顾性能与可维护性的工程实践。一个经验丰富的开发者打出的日志，往往能在系统上线数月甚至数年后，成为排查问题、配置监控、分析报表的关键依据。</p>
<blockquote>
<p><code>好的日志，是写给未来的自己和团队看的。</code></p>
</blockquote>
<h2 id="格式统一"><a href="#格式统一" class="headerlink" title="格式统一"></a>格式统一</h2><h3 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">log.info(<span class="string">&quot;start process&quot;</span>);</span><br><span class="line">log.error(<span class="string">&quot;error happen&quot;</span>);</span><br><span class="line"></span><br><span class="line">INFO  [main] com.example.demo.DemoApplication - start process</span><br><span class="line">ERROR [main] com.example.demo.DemoApplication - error happen</span><br></pre></td></tr></table></figure></div>

<p>无上下文, 无时间戳, 没有更多有价值信息</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- logback.xml核心配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">    %d&#123;yy-MM-dd HH:mm:ss.SSS&#125; </span><br><span class="line">    |%X&#123;traceId:-NO_ID&#125; </span><br><span class="line">    |%thread </span><br><span class="line">    |%-5level </span><br><span class="line">    |%logger&#123;36&#125; </span><br><span class="line">    |%msg%n</span><br><span class="line"><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在<code>logback.xml</code>中统一配置了日志的时间格式、<code>tradeId</code>，线程、等级、日志详情都信息。</p>
<p>日志的格式统一了，更方便点位问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/logs/log2.jpg"
                     
                ></p>
<h2 id="异常必带堆栈"><a href="#异常必带堆栈" class="headerlink" title="异常必带堆栈"></a>异常必带堆栈</h2><h3 id="反例-同事看了想打人"><a href="#反例-同事看了想打人" class="headerlink" title="反例 (同事看了想打人)"></a>反例 (同事看了想打人)</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    processOrder();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;处理失败&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>出现异常了，日志中没打印任何的异常堆栈信息。</p>
<p>相当于自己把异常吃掉了。</p>
<p>非常不好排查问题。</p>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">log.error(<span class="string">&quot;订单处理异常 orderId=&#123;&#125;&quot;</span>, orderId, e); <span class="comment">// e必须存在！</span></span><br></pre></td></tr></table></figure></div>

<p>日志中记录了出现异常的订单号<code>orderId</code>和异常的堆栈信息<code>e</code>。</p>
<p>有必要时还需打印堆栈链中的<code>cauze</code>信息</p>
<h2 id="级别合理"><a href="#级别合理" class="headerlink" title="级别合理"></a>级别合理</h2><h3 id="反例-1"><a href="#反例-1" class="headerlink" title="反例"></a>反例</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/logs/log1.jpg"
                     
                ></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">log.debug(<span class="string">&quot;用户余额不足 userId=&#123;&#125;&quot;</span>, userId); <span class="comment">// 业务异常应属WARN</span></span><br><span class="line">log.error(<span class="string">&quot;接口响应稍慢&quot;</span>); <span class="comment">// 普通超时属INFO</span></span><br></pre></td></tr></table></figure></div>

<p>接口响应稍慢，打印了error级别的日志，显然不太合理。</p>
<p>正常情况下，普通超时属INFO级别。</p>
<h3 id="正解-2"><a href="#正解-2" class="headerlink" title="正解"></a>正解</h3><ul>
<li><code>error</code>：错误日志，指比较严重的错误，对正常业务有影响，需要运维配置监控的；</li>
<li><code>warn</code>：警告日志，一般的错误，对业务影响不大，但是需要开发关注；</li>
<li><code>info</code>：信息日志，记录排查问题的关键信息，如调用时间、出参入参等等；</li>
<li><code>debug</code>：用于开发DEBUG的，关键逻辑里面的运行时数据；</li>
<li><code>trace</code>：最详细的信息，一般这些信息只记录到日志文件中。</li>
</ul>
<h2 id="参数完整"><a href="#参数完整" class="headerlink" title="参数完整"></a>参数完整</h2><h3 id="反例-让查问题的人无语"><a href="#反例-让查问题的人无语" class="headerlink" title="反例 (让查问题的人无语)"></a>反例 (让查问题的人无语)</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">log.info(<span class="string">&quot;用户登录失败&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>上面这个日志只打印了“用户登录失败”这个文案。</p>
<p>谁在哪登录失败？</p>
<h3 id="正解-3"><a href="#正解-3" class="headerlink" title="正解"></a>正解</h3><blockquote>
<p>日志要打印出方法的入参、出参<br>我们并不需要打印很多很多日志，只需要打印可以快速定位问题的有效日志。有效的日志，是甩锅的利器!</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">log.warn(<span class="string">&quot;用户登录失败 username=&#123;&#125;, clientIP=&#123;&#125;, failReason=&#123;&#125;&quot;</span>, username, clientIP, <span class="string">&quot;密码错误次数超限&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>登录失败的业务场景，需要记录哪个用户，ip是多少，在什么时间，登录失败了，失败的原因是什么。</p>
<p>时间在logback.xml中统一配置了格式。</p>
<p>这样才方便快速定位问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/logs/log3.jpg"
                     
                ></p>
<h2 id="合理的打印时机"><a href="#合理的打印时机" class="headerlink" title="合理的打印时机"></a>合理的打印时机</h2><blockquote>
<p>遇到if…else…等条件时，每个分支首行都尽量打印日志</p>
</blockquote>
<p>当你碰到if…else…或者switch这样的条件时，可以在分支的首行就打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;,开始处理会员逻辑&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是非会员,Id:&#123;&#125;,开始处理非会员逻辑&quot;</span>,user,getUserId())</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="数据脱敏"><a href="#数据脱敏" class="headerlink" title="数据脱敏"></a>数据脱敏</h2><p>在记录的日志中，需要对一下用户的个人敏感数据做脱敏处理。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 脱敏工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogMasker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">maskMobile</span><span class="params">(String mobile)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mobile.replaceAll(<span class="string">&quot;(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)&quot;</span>, <span class="string">&quot;$1****$2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">log.info(<span class="string">&quot;用户注册 mobile=&#123;&#125;&quot;</span>, LogMasker.maskMobile(<span class="string">&quot;13812345678&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<h2 id="异步保性能"><a href="#异步保性能" class="headerlink" title="异步保性能"></a>异步保性能</h2><p>问题复现某次秒杀活动中直接同步写日志，导致大量线程阻塞：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">log.info(<span class="string">&quot;秒杀请求 userId=&#123;&#125;, itemId=&#123;&#125;&quot;</span>, userId, itemId);</span><br></pre></td></tr></table></figure></div>

<p>高并发下IO阻塞。</p>
<p>致命伤害分析:</p>
<ol>
<li>同步写日志导致线程上下文切换频繁</li>
<li>磁盘IO成为系统瓶颈</li>
<li>高峰期日志打印耗时占总RT的25%</li>
</ol>
<h3 id="正解-四步配置"><a href="#正解-四步配置" class="headerlink" title="正解 四步配置"></a>正解 四步配置</h3><h4 id="步骤1：logback-xml配置异步通道"><a href="#步骤1：logback-xml配置异步通道" class="headerlink" title="步骤1：logback.xml配置异步通道"></a>步骤1：logback.xml配置异步通道</h4><div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 异步Appender核心配置 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ASYNC&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 不丢失日志的阈值：当队列剩余容量＜此值时，TRACE/DEBUG级别日志将被丢弃 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 队列深度：建议设为 (最大并发线程数 × 2) --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 关联真实Appender --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="步骤2：日志输出优化代码"><a href="#步骤2：日志输出优化代码" class="headerlink" title="步骤2：日志输出优化代码"></a>步骤2：日志输出优化代码</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无需前置判断，框架自动处理  </span></span><br><span class="line">log.debug(<span class="string">&quot;接收到MQ消息：&#123;&#125;&quot;</span>, msg.toSimpleString()); <span class="comment">// 自动异步写入队列  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不应做复杂计算后再打印（异步前仍在业务线程执行）  </span></span><br><span class="line"><span class="comment">// 错误做法：  </span></span><br><span class="line">log.debug(<span class="string">&quot;详细内容：&#123;&#125;&quot;</span>, computeExpensiveLog());</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/logs/log5.jpg"
                     
                ></p>
<h4 id="步骤3：性能关键参数公式"><a href="#步骤3：性能关键参数公式" class="headerlink" title="步骤3：性能关键参数公式"></a>步骤3：性能关键参数公式</h4><blockquote>
<p>最大内存占用 ≈ 队列长度 × 平均单条日志大小<br>推荐队列深度 &#x3D; 峰值TPS × 容忍最大延迟(秒)<br>例如：10000 TPS × 0.5s容忍 ⇒ 5000队列大小</p>
</blockquote>
<h4 id="步骤4：日志内容优化"><a href="#步骤4：日志内容优化" class="headerlink" title="步骤4：日志内容优化"></a>步骤4：日志内容优化</h4><blockquote>
<p>不要使用<code>e.printStackTrace()</code></p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正解</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 业务代码处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  log.error(<span class="string">&quot;你的程序有异常啦&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em><strong>理由</strong></em></p>
<ol>
<li><code>e.printStackTrace()</code>打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便</li>
<li><code>e.printStackTrace()</code>语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了,即内存满了，那么，用户的请求就卡住了</li>
</ol>
<p><em><strong>风险规避策略</strong></em></p>
<ol>
<li>防队列堆积：监控队列使用率，达80%触发告警</li>
<li>防OOM：严格约束大对象toString()的调用</li>
<li>紧急逃生：预设JMX接口用于快速切换同步模式</li>
</ol>
<h2 id="避免重复打印日志"><a href="#避免重复打印日志" class="headerlink" title="避免重复打印日志"></a>避免重复打印日志</h2><blockquote>
<p>避免重复打印日志，酱紫会浪费磁盘空间。如果你已经有一行日志清楚表达了意思，避免再冗余打印</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.isVip())&#123;</span><br><span class="line">  log.info(<span class="string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//冗余，可以跟前面的日志合并一起</span></span><br><span class="line">  log.info(<span class="string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());</span><br><span class="line">  <span class="comment">//会员逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//非会员逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="日志文件分离"><a href="#日志文件分离" class="headerlink" title="日志文件分离"></a>日志文件分离</h2><ul>
<li>我们可以把不同类型的日志分离出去，比如<code>access.log</code>，或者<code>error</code>级别<code>error.log</code>，都可以单独打印到一个文件里面。</li>
<li>当然，也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便啦。</li>
</ul>
<h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><h3 id="混沌场景"><a href="#混沌场景" class="headerlink" title="混沌场景"></a>混沌场景</h3><p>跨服务调用无法关联日志。我们需要有链路追踪方案。</p>
<h3 id="全链路方案"><a href="#全链路方案" class="headerlink" title="全链路方案"></a>全链路方案</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拦截器注入traceId</span></span><br><span class="line">MDC.put(<span class="string">&quot;traceId&quot;</span>, UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志格式包含traceId</span></span><br><span class="line">&lt;pattern&gt;%d&#123;HH:mm:ss&#125; |%X&#123;traceId&#125;| %msg%n&lt;/pattern&gt;</span><br></pre></td></tr></table></figure></div>

<p>可以在MDC中设置traceId。</p>
<p>后面可以通过traceId全链路追踪日志。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/logs/log4.jpg"
                     
                ></p>
<h2 id="动态调参"><a href="#动态调参" class="headerlink" title="动态调参"></a>动态调参</h2><h3 id="半夜重启的痛"><a href="#半夜重启的痛" class="headerlink" title="半夜重启的痛"></a>半夜重启的痛</h3><p>线上问题需要临时开DEBUG日志，比如：查询用户的某次异常操作的日志。</p>
<h3 id="热更新方案"><a href="#热更新方案" class="headerlink" title="热更新方案"></a>热更新方案</h3><p><code>Spring Actuator</code> 支持动态调整日志级别。可以具体到某个类或包。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/logs/log5.png"
                     
                ></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST &quot;http://localhost:8081/actuator/loggers/ROOT&quot; -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;configuredLevel&quot;: &quot;DEBUG&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure></div>

<p>有时候我们需要临时打印DEBUG日志，这就需要有个动态参数控制了。</p>
<p>否则每次调整打印日志级别都需要重启服务，可能会影响用户的正常使用。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">journey</span><br><span class="line">    title 日志级别动态调整</span><br><span class="line">    section 旧模式</span><br><span class="line">        发现问题 --&gt; 修改配置 --&gt; 重启应用 --&gt; 丢失现场</span><br><span class="line">    section 新模式</span><br><span class="line">        发现问题 --&gt; 动态调整 --&gt; 立即生效 --&gt; 保持现场</span><br></pre></td></tr></table></figure></div>

<h2 id="结构化存储"><a href="#结构化存储" class="headerlink" title="结构化存储"></a>结构化存储</h2><h3 id="混沌日志"><a href="#混沌日志" class="headerlink" title="混沌日志"></a>混沌日志</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户购买了苹果手机 订单号1001 金额8999</span><br></pre></td></tr></table></figure></div>

<p>上面的日志拼接成了一个字符串，虽说中间有空格分隔了，但哪些字段对应了哪些值，看起来不是很清楚。</p>
<p>我们在存储日志的时候，需要做结构化存储，方便快速的查询和搜索。</p>
<h3 id="机器友好式日志"><a href="#机器友好式日志" class="headerlink" title="机器友好式日志"></a>机器友好式日志</h3><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ORDER_CREATE&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;orderId&quot;</span><span class="punctuation">:</span> <span class="number">1001</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span> <span class="number">8999</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;products&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;iPhone&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;sku&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A123&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>这里使用了json格式存储日志。</p>
<p>日志中的数据一目了然。</p>
<h2 id="智能监控"><a href="#智能监控" class="headerlink" title="智能监控"></a>智能监控</h2><h3 id="最失败案例"><a href="#最失败案例" class="headerlink" title="最失败案例"></a>最失败案例</h3><p>某次用户开通会员操作，错误日志堆积3天才被发现，黄花菜都凉了。</p>
<h3 id="ELK监控方案"><a href="#ELK监控方案" class="headerlink" title="ELK监控方案"></a>ELK监控方案</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/logs/log7.jpg"
                     
                ></p>
<p>报警规则示例:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR日志连续5分钟 &gt; 100条 → 电话告警  </span><br><span class="line">WARN日志持续1小时 → 邮件通知</span><br></pre></td></tr></table></figure></div>

<hr>
<p>最后的灵魂拷问：下次线上故障时，你的日志能让新人5分钟定位问题吗?</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/logs/log8.jpg"
                     
                ></p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Log</tag>
        <tag>日志</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown 插入数学公式</title>
    <url>/2017/02/28/MarkDown-%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="使用Google-Chart的服务器"><a href="#使用Google-Chart的服务器" class="headerlink" title="使用Google Chart的服务器"></a>使用Google Chart的服务器</h3><blockquote>
<p>提示：若无法正确打开<br>在hosts 文件中添加</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">61.91.161.217	chart.googleapis.com</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl= 在此插入Latex公式&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border:none;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>一个例子，</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border:none;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>公式显示结果为：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}"
                      style="border:none;"
                >

<h3 id="符号对照表"><a href="#符号对照表" class="headerlink" title="符号对照表"></a>符号对照表</h3><blockquote>
<p>注意：不知什么原因 “+” 无法编译 ，后面 “+” 使用 %2B 代替即可</p>
</blockquote>
<h5 id="如何输入上下标"><a href="#如何输入上下标" class="headerlink" title="如何输入上下标"></a>如何输入上下标</h5><blockquote>
<p>^表示上标, _表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。</p>
</blockquote>
<p>例子：x^{y^z}&#x3D;(1+{\rm e}^x)^{-2xy^w}</p>
<p>显示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=x^{y^z}=(1%2B{\rm e}^x)^{-2xy^w}"
                      style="border:none;"
                ></p>
<h5 id="如何输入括号和分隔符"><a href="#如何输入括号和分隔符" class="headerlink" title="如何输入括号和分隔符"></a>如何输入括号和分隔符</h5><blockquote>
<p>()、[]和|表示自己，{}表示{}。当要显示大号的括号或分隔符时，要用\left和\right命令。</p>
</blockquote>
<p>例子：f(x,y,z) &#x3D; 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)</p>
<p>显示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=f(x,y,z) = 3y^2z \left( 3%2B\frac{7x%2B5}{1%2By^2} \right)"
                      style="border:none;"
                ></p>
<h5 id="如何输入分数"><a href="#如何输入分数" class="headerlink" title="如何输入分数"></a>如何输入分数</h5><p>例子：\frac{1}{3}　或　1 \over 3</p>
<p>显示： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\frac{1}{3} "
                      style="border:none;"
                > 　或  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=1 \over 3"
                      style="border:none;"
                ></p>
<h5 id="如何输入开方"><a href="#如何输入开方" class="headerlink" title="如何输入开方"></a>如何输入开方</h5><p>例子：\sqrt{2}　和　\sqrt[n]{3}</p>
<p>显示： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\sqrt{2}  "
                      style="border:none;"
                >　和　 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\sqrt[n]{3} "
                      style="border:none;"
                ></p>
<h5 id="如何输入省略号"><a href="#如何输入省略号" class="headerlink" title="如何输入省略号"></a>如何输入省略号</h5><blockquote>
<p>数学公式中常见的省略号有两种，\ldots表示与文本底线对齐的省略号，\cdots表示与文本中线对齐的省略号。</p>
</blockquote>
<p>例子：f(x1,x2,\ldots,xn) &#x3D; x1^2 + x2^2 + \cdots + xn^2</p>
<p>显示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=f(x<em>1,x</em>2,\ldots,x<em>n) = x</em>1^2 %2B x<em>2^2 %2B \cdots %2B x</em>n^2"
                      style="border:none;"
                ></p>
<h5 id="如何输入矢量"><a href="#如何输入矢量" class="headerlink" title="如何输入矢量"></a>如何输入矢量</h5><p>例子：\vec{a} \cdot \vec{b}&#x3D;0</p>
<p>显示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\vec{a} \cdot \vec{b}=0"
                      style="border:none;"
                ></p>
<h5 id="如何输入积分"><a href="#如何输入积分" class="headerlink" title="如何输入积分"></a>如何输入积分</h5><p>例子：\int_0^1 x^2 {\rm d}x</p>
<p>显示： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\int_0^1 x^2 {\rm d}x"
                      style="border:none;"
                ></p>
<h5 id="如何输入极限运算"><a href="#如何输入极限运算" class="headerlink" title="如何输入极限运算"></a>如何输入极限运算</h5><p>例子：\lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}</p>
<p>显示： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\lim_{n \rightarrow %2B\infty} \frac{1}{n(n%2B1)}"
                      style="border:none;"
                ></p>
<h5 id="如何输入累加、累乘运算"><a href="#如何输入累加、累乘运算" class="headerlink" title="如何输入累加、累乘运算"></a>如何输入累加、累乘运算</h5><p>例子：\sum{i&#x3D;0}^n \frac{1}{i^2}　和　\prod{i&#x3D;0}^n \frac{1}{i^2}</p>
<p>显示： <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\sum{i=0}^n \frac{1}{i^2}"
                      style="border:none;"
                > 　和　 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\prod{i=0}^n \frac{1}{i^2}"
                      style="border:none;"
                ></p>
<h5 id="如何输入希腊字母"><a href="#如何输入希腊字母" class="headerlink" title="如何输入希腊字母"></a>如何输入希腊字母</h5><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">值</th>
<th align="center">符号</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\alpha</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\alpha"
                      style="border:none;"
                ></td>
<td align="center">\beta</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\beta"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\gamma</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\gamma"
                      style="border:none;"
                ></td>
<td align="center">\delta</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\delta"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\epsilon</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\epsilon"
                      style="border:none;"
                ></td>
<td align="center">\varepsilon</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\varepsilon"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\zeta</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\zeta"
                      style="border:none;"
                ></td>
<td align="center">\eta</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\eta"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\theta</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\theta"
                      style="border:none;"
                ></td>
<td align="center">\vartheta</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\vartheta"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\iota</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\iota"
                      style="border:none;"
                ></td>
<td align="center">\kappa</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\kappa"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\lambda</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\lambda"
                      style="border:none;"
                ></td>
<td align="center">\mu</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\mu"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\nu</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\nu"
                      style="border:none;"
                ></td>
<td align="center">\xi</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\xi"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\pi</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\pi"
                      style="border:none;"
                ></td>
<td align="center">\varpi</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\varpi"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\rho</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\rho"
                      style="border:none;"
                ></td>
<td align="center">\varrho</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\varrho"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\sigma</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\sigma"
                      style="border:none;"
                ></td>
<td align="center">\varsigma</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\varsigma"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\tau</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\tau"
                      style="border:none;"
                ></td>
<td align="center">\upsilon</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\upsilon"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\phi</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\phi"
                      style="border:none;"
                ></td>
<td align="center">\varphi</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\varphi"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\chi</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\chi"
                      style="border:none;"
                ></td>
<td align="center">\psi</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\psi"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\omega</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\omega"
                      style="border:none;"
                ></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h5 id="如何输入其它特殊字符"><a href="#如何输入其它特殊字符" class="headerlink" title="如何输入其它特殊字符"></a>如何输入其它特殊字符</h5><p>关系运算符</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">值</th>
<th align="center">符号</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\pm</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\pm"
                      style="border:none;"
                ></td>
<td align="center">\times</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\times"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\div</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\div"
                      style="border:none;"
                ></td>
<td align="center">\mid</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\mid"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\nmid</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\nmid"
                      style="border:none;"
                ></td>
<td align="center">\cdot</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\cdot"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\circ</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\circ"
                      style="border:none;"
                ></td>
<td align="center">\ast</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\ast"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\bigodot</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\bigodot"
                      style="border:none;"
                ></td>
<td align="center">\bigotimes</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\bigotimes"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\bigoplus</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\bigoplus"
                      style="border:none;"
                ></td>
<td align="center">\leq</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\leq"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\geq</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\geq"
                      style="border:none;"
                ></td>
<td align="center">\neq</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\neq"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\approx</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\approx"
                      style="border:none;"
                ></td>
<td align="center">\equiv</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\equiv"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\sum</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\sum"
                      style="border:none;"
                ></td>
<td align="center">\prod</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\prod"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\coprod</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\coprod"
                      style="border:none;"
                ></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>集合运算符</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">值</th>
<th align="center">符号</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\emptyset</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\emptyset"
                      style="border:none;"
                ></td>
<td align="center">\in</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\in"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\notin</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\notin"
                      style="border:none;"
                ></td>
<td align="center">\subset</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\subset"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\supset</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\supset"
                      style="border:none;"
                ></td>
<td align="center">\subseteq</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\subseteq"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\supseteq</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\supseteq"
                      style="border:none;"
                ></td>
<td align="center">\bigcap</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\bigcap"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\bigcup</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\bigcup"
                      style="border:none;"
                ></td>
<td align="center">\bigvee</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\bigvee"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\bigwedge</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\bigwedge"
                      style="border:none;"
                ></td>
<td align="center">\biguplus</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\biguplus"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\bigsqcup</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\bigsqcup"
                      style="border:none;"
                ></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>对数运算符</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">值</th>
<th align="center">符号</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\log</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\log"
                      style="border:none;"
                ></td>
<td align="center">\lg</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\lg"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\ln</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\ln"
                      style="border:none;"
                ></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>三角运算符</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">值</th>
<th align="center">符号</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\bot</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\bot"
                      style="border:none;"
                ></td>
<td align="center">\angle</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\angle"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">30^\circ</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=30^\circ"
                      style="border:none;"
                ></td>
<td align="center">\sin</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\sin"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\cos</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\cos"
                      style="border:none;"
                ></td>
<td align="center">\tan</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\tan"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\cot</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\cot"
                      style="border:none;"
                ></td>
<td align="center">\sec</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\sec"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\csc</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\csc"
                      style="border:none;"
                ></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>微积分运算符</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">值</th>
<th align="center">符号</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\prime</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\prime"
                      style="border:none;"
                ></td>
<td align="center">\int</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\int"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\iint</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\iint"
                      style="border:none;"
                ></td>
<td align="center">\iiint</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\iiint"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\iiiint</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\iiiint"
                      style="border:none;"
                ></td>
<td align="center">\oint</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\oint"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\lim</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\lim"
                      style="border:none;"
                ></td>
<td align="center">\infty</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\infty"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\nabla</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\nabla"
                      style="border:none;"
                ></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>逻辑运算符</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">值</th>
<th align="center">符号</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\because</td>
<td align="center"><strong>未找到</strong></td>
<td align="center">\therefore</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\therefore"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\forall</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\forall"
                      style="border:none;"
                ></td>
<td align="center">\exists</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\exists"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\not&#x3D;</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\not="
                      style="border:none;"
                ></td>
<td align="center">\not&gt;</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\not>"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\not\subset</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\not\subset"
                      style="border:none;"
                ></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>戴帽符号</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">值</th>
<th align="center">符号</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\hat{y}</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\hat{y}"
                      style="border:none;"
                ></td>
<td align="center">\check{y}</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\check{y}"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\breve{y}</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\breve{y}"
                      style="border:none;"
                ></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>连线符号</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">值</th>
<th align="center">符号</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\overline{a+b+c+d}</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\overline{a+b+c+d}"
                      style="border:none;"
                ></td>
<td align="center">\underline{a+b+c+d}</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\underline{a+b+c+d}"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\overbrace{a+\underbrace{b+c}<em>{1.0}+d}^{2.0}</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\overbrace{a+\underbrace{b+c}{1.0}+d}^{2.0}"
                      style="border:none;"
                ></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>箭头符号</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">值</th>
<th align="center">符号</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\uparrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\uparrow"
                      style="border:none;"
                ></td>
<td align="center">\downarrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\downarrow"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\Uparrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\Uparrow"
                      style="border:none;"
                ></td>
<td align="center">\Downarrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\Downarrow"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\rightarrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\rightarrow"
                      style="border:none;"
                ></td>
<td align="center">\leftarrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\leftarrow"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\Rightarrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\Rightarrow"
                      style="border:none;"
                ></td>
<td align="center">\Leftarrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\Leftarrow"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\longrightarrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\longrightarrow"
                      style="border:none;"
                ></td>
<td align="center">\longleftarrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\longleftarrow"
                      style="border:none;"
                ></td>
</tr>
<tr>
<td align="center">\Longrightarrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\Longrightarrow"
                      style="border:none;"
                ></td>
<td align="center">\Longleftarrow</td>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl=\Longleftarrow"
                      style="border:none;"
                ></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>MarkDown</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown 支持的语言</title>
    <url>/2017/02/27/MarkDown-%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AppleScript</td>
<td align="center">applescript</td>
</tr>
<tr>
<td align="center">ActionScript 3.0</td>
<td align="center">actionscript3 , as3</td>
</tr>
<tr>
<td align="center">Shell</td>
<td align="center">bash , shell</td>
</tr>
<tr>
<td align="center">ColdFusion</td>
<td align="center">coldfusion , cf</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">cpp , c</td>
</tr>
<tr>
<td align="center">C#</td>
<td align="center">c# , c-sharp , csharp</td>
</tr>
<tr>
<td align="center">CSS</td>
<td align="center">css</td>
</tr>
<tr>
<td align="center">Delphi</td>
<td align="center">delphi , pascal , pas</td>
</tr>
<tr>
<td align="center">diff&amp;patch</td>
<td align="center">diff patch</td>
</tr>
<tr>
<td align="center">Erlang</td>
<td align="center">erl , erlang</td>
</tr>
<tr>
<td align="center">Groovy</td>
<td align="center">groovy</td>
</tr>
<tr>
<td align="center">Java</td>
<td align="center">java</td>
</tr>
<tr>
<td align="center">JavaFX</td>
<td align="center">jfx , javafx</td>
</tr>
<tr>
<td align="center">JavaScript</td>
<td align="center">js , jscript , javascript</td>
</tr>
<tr>
<td align="center">Perl</td>
<td align="center">perl , pl , Perl</td>
</tr>
<tr>
<td align="center">PHP</td>
<td align="center">php</td>
</tr>
<tr>
<td align="center">text</td>
<td align="center">text , plain</td>
</tr>
<tr>
<td align="center">Python</td>
<td align="center">py , python</td>
</tr>
<tr>
<td align="center">Ruby</td>
<td align="center">ruby , rails , ror , rb</td>
</tr>
<tr>
<td align="center">SASS&amp;SCSS</td>
<td align="center">sass , scss</td>
</tr>
<tr>
<td align="center">Scala</td>
<td align="center">scala</td>
</tr>
<tr>
<td align="center">SQL</td>
<td align="center">sql</td>
</tr>
<tr>
<td align="center">Visual</td>
<td align="center">Basic	vb , vbnet</td>
</tr>
<tr>
<td align="center">XML</td>
<td align="center">xml , xhtml , xslt , html</td>
</tr>
<tr>
<td align="center">Objective C</td>
<td align="center">objc , obj-c</td>
</tr>
<tr>
<td align="center">F#</td>
<td align="center">f# f-sharp , fsharp</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">r , s , splus</td>
</tr>
<tr>
<td align="center">matlab</td>
<td align="center">matlab</td>
</tr>
<tr>
<td align="center">swift</td>
<td align="center">swift</td>
</tr>
<tr>
<td align="center">GO</td>
<td align="center">go , golang</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 配置多个远程仓库</title>
    <url>/2024/06/28/Maven-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>配置Maven Settings.xml文件</p>
<h2 id="mirrorOf-将-改为-central"><a href="#mirrorOf-将-改为-central" class="headerlink" title="mirrorOf 将 * 改为 central"></a>mirrorOf 将 * 改为 central</h2><div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原来的 http://repo1.maven.org  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>mavenRepository3<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenRepository3<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="调整-profiles-activeProfiles"><a href="#调整-profiles-activeProfiles" class="headerlink" title="调整 profiles activeProfiles"></a>调整 profiles activeProfiles</h2><div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>private-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>kaadas<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://private-repository/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span> </span><br><span class="line">          <span class="comment">&lt;!-- &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-central<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-central<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>private-repository<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>maven-central<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Env</tag>
        <tag>Maven</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 环境变量配置</title>
    <url>/2024/06/24/Maven-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><code>Maven</code>的环境变量配置主要涉及到设置<code>MAVEN_HOME</code>和更新系统的<code>PATH</code>环境变量。以下是在Windows和Linux&#x2F;macOS系统上配置<code>Maven</code>环境变量的步骤：</p>
<h2 id="Windows系统："><a href="#Windows系统：" class="headerlink" title="Windows系统："></a>Windows系统：</h2><ol>
<li>设置<code>MAVEN_HOME</code>：</li>
</ol>
<ul>
<li>找到<code>Maven</code>的安装目录，例如<code>C:\Program Files\apache-maven-3.8.1</code>（具体路径根据你的安装情况而定）。</li>
<li>右键点击“我的电脑”或“此电脑”，选择“属性”，然后点击“高级系统设置”。</li>
<li>在系统属性窗口中，点击“环境变量”按钮。</li>
<li>在系统变量区域，点击“新建”，变量名填写<code>MAVEN_HOME</code>，变量值填写你的<code>Maven</code>安装路径。</li>
</ul>
<ol start="2">
<li>更新<code>PATH</code>环境变量：</li>
</ol>
<ul>
<li>在系统变量区域，找到<code>Path</code>变量，选中它然后点击“编辑”。</li>
<li>在值的末尾添加<code>;%MAVEN_HOME%\bin;</code>（注意前面的分号）。这确保了系统可以在<code>Maven</code>的<code>bin</code>目录中找到执行文件。</li>
<li>点击“确定”保存更改。</li>
</ul>
<p>现在，当你打开命令提示符或PowerShell时，应该能够使用mvn命令来调用Maven。</p>
<h2 id="Linux-macOS系统："><a href="#Linux-macOS系统：" class="headerlink" title="Linux&#x2F;macOS系统："></a>Linux&#x2F;macOS系统：</h2><ol>
<li>编辑<code>bash</code>配置文件（例如<code>.bashrc</code>或<code>.bash_profile</code>）：<br> 打开终端，然后输入以下命令来编辑你的bash配置文件（具体取决于你的系统配置）： <div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">nano ~/.bashrc  <span class="comment"># 或者使用你喜欢的文本编辑器，如 vim, emacs 等。</span></span><br></pre></td></tr></table></figure></div></li>
<li>设置<code>MAVEN_HOME</code>：<br> 在打开的文件中，添加或修改以下行： <div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> MAVEN_HOME=/path/to/apache-maven  <span class="comment"># 替换为你的Maven安装路径。</span></span><br></pre></td></tr></table></figure></div></li>
<li>更新<code>PATH</code>环境变量：<br> 在文件的末尾添加以下行： <div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$MAVEN_HOME</span>/bin  <span class="comment"># 这将Maven的bin目录添加到你的PATH中。</span></span><br></pre></td></tr></table></figure></div></li>
<li>保存并关闭文件：在<code>nano</code>中，按<code>Ctrl + X</code>，然后按<code>Y</code>保存更改，最后按<code>Enter</code>退出。</li>
<li>使更改生效：在终端中输入以下命令来使更改立即生效： <div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 或者使用你的配置文件名。</span></span><br></pre></td></tr></table></figure></div>
现在，你应该能够在终端中使用<code>mvn</code>命令来调用<code>Maven</code>了。如果你使用的是其他<code>shell</code>（如<code>zsh</code>），请确保你在正确的配置文件中进行了更改。</li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Env</tag>
        <tag>Maven</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven-项目命名</title>
    <url>/2021/04/22/Maven-%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<h1 id="Maven项目命名规范"><a href="#Maven项目命名规范" class="headerlink" title="Maven项目命名规范"></a>Maven项目命名规范</h1><blockquote>
<p><code>groupId</code> will identify your project uniquely across all projects, so we need to enforce a naming schema. It has to follow the package name rules, what means that has to be at least as a domain name you control, and you can create as many subgroups as you want. Look at More information about package names.<br>eg. org.apache.maven, org.apache.commons</p>
<p>A good way to determine the granularity of the groupId is to use the project structure. That is, if the current project is a multiple module project, it should append a new identifier to the parent’s groupId.</p>
<p>eg. org.apache.maven, org.apache.maven.plugins, org.apache.maven.reporting</p>
<p><code>artifactId</code> is the name of the jar without version. If you created it then you can choose whatever name you want with lowercase letters and no strange symbols. If it’s a third party jar you have to take the name of the jar as it’s distributed.<br>eg. maven, commons-math</p>
<p><code>version</code> if you distribute it then you can choose any typical version with numbers and dots (1.0, 1.1, 1.0.1, …). Don’t use dates as they are usually associated with SNAPSHOT (nightly) builds. If it’s a third party artifact, you have to use their version number whatever it is, and as strange as it can look.<br>eg. 2.0, 2.0.1, 1.3.1</p>
<p>（<a class="link"   href="https://maven.apache.org/guides/mini/guide-naming-conventions.html%EF%BC%89" >https://maven.apache.org/guides/mini/guide-naming-conventions.html）<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h2 id="groupId"><a href="#groupId" class="headerlink" title="groupId"></a>groupId</h2><p>groupId定义当前Maven项目隶属的实际项目，例如org.sonatype.nexus，此id前半部分org.sonatype代表此项目隶属的组织或公司，后部分代表项目的名称，如果此项目多模块话开发的话就子模块可以分为org.sonatype.nexus.plugins和org.sonatype.nexus.utils等。特别注意的是groupId不应该对应项目隶属的组织或公司，也就是说groupId不能只有org.sonatype而没有nexus。</p>
<p> 例如：我建立一个项目，此项目是此后所有项目的一个总的平台，那么groupId应该是org.limingming.projectName,projectName是平台的名称，org.limingming是代表我个人的组织，如果以我所在的浪潮集团来说的话就应该是com.inspur.loushang。</p>
<h2 id="artifactId"><a href="#artifactId" class="headerlink" title="artifactId"></a>artifactId</h2><p>artifactId是构件ID，该元素定义实际项目中的一个Maven项目或者是子模块，如上面官方约定中所说，构建名称必须小写字母，没有其他的特殊字符，推荐使用“实际项目名称－模块名称”的方式定义，例如：spirng-mvn、spring-core等。</p>
<p>推荐格式：使用实际项目名称作为artifactId的前缀，紧接着为模块名称</p>
<p>例如：<strong>spirng-mvn-2.0.0.jar</strong><br>nexus-indexer、spring-mvc、hibernate-c3po……这些id都是以实际项目名称作为前缀，然后接着一个中划线，再紧跟项目的模块名称，默认情况下maven会在artifactId添加version作为最后生成的名称。</p>
]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 脚本 Windows to Linux 文件传输</title>
    <url>/2024/07/10/Python-%E8%84%9A%E6%9C%AC-Windows-to-Linux-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<p>要在 Python 中实现从 Windows 到 Linux 的文件传输，可以使用多种方法，这里介绍两种常见的方式：使用 Paramiko 库进行 SSH 文件传输和使用 SCP 命令的 subprocess 模块。</p>
<h3 id="方法一：使用-Paramiko-进行-SSH-文件传输"><a href="#方法一：使用-Paramiko-进行-SSH-文件传输" class="headerlink" title="方法一：使用 Paramiko 进行 SSH 文件传输"></a>方法一：使用 Paramiko 进行 SSH 文件传输</h3><p>Paramiko 是一个用于 SSHv2 协议的 Python 实现，可以通过它来建立 SSH 连接，并在 Windows 上执行 Python 脚本来传输文件到 Linux。</p>
<ol>
<li><p><strong>安装 Paramiko</strong></p>
<p>在 Windows 上安装 Paramiko 库：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install paramiko</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编写 Python 脚本</strong></p>
<p>下面是一个简单的示例脚本，演示如何使用 Paramiko 在 Windows 上将文件传输到 Linux 主机：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH 连接信息</span></span><br><span class="line">hostname = <span class="string">&#x27;your_linux_server_ip&#x27;</span></span><br><span class="line">port = <span class="number">22</span></span><br><span class="line">username = <span class="string">&#x27;your_linux_username&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;your_linux_password&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地文件路径</span></span><br><span class="line">local_path = <span class="string">r&#x27;C:\path\to\your\file.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目标路径</span></span><br><span class="line">remote_path = <span class="string">&#x27;/home/your_username/file.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 SSH 连接</span></span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">ssh.connect(hostname, port, username, password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 SFTP 协议传输文件</span></span><br><span class="line">sftp = ssh.open_sftp()</span><br><span class="line">sftp.put(local_path, remote_path)</span><br><span class="line">sftp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 SSH 连接</span></span><br><span class="line">ssh.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File <span class="subst">&#123;os.path.basename(local_path)&#125;</span> transferred successfully to <span class="subst">&#123;hostname&#125;</span>:<span class="subst">&#123;remote_path&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将 <code>your_linux_server_ip</code> 替换为你的 Linux 服务器 IP 地址。</li>
<li>将 <code>your_linux_username</code> 和 <code>your_linux_password</code> 替换为 Linux 服务器的用户名和密码。</li>
<li>将 <code>local_path</code> 替换为你要传输的本地文件路径。</li>
<li>将 <code>remote_path</code> 替换为 Linux 上的目标路径，用于存储传输的文件。</li>
</ul>
</li>
<li><p><strong>运行 Python 脚本</strong></p>
<p>在 Windows 上运行这个 Python 脚本，它会连接到指定的 Linux 服务器，并将文件传输到远程目标路径。</p>
</li>
</ol>
<h3 id="方法二：使用-SCP-命令和-subprocess-模块"><a href="#方法二：使用-SCP-命令和-subprocess-模块" class="headerlink" title="方法二：使用 SCP 命令和 subprocess 模块"></a>方法二：使用 SCP 命令和 subprocess 模块</h3><p>另一种常见的方法是使用 Python 的 <code>subprocess</code> 模块来执行 SCP 命令，直接调用系统的 SCP 工具进行文件传输。</p>
<ol>
<li><p><strong>确保本地 Windows 上有安装 SCP 客户端。</strong></p>
<p>通常可以通过安装 Git for Windows 或者单独安装 SCP 客户端来获取 SCP 工具。</p>
</li>
<li><p><strong>编写 Python 脚本</strong></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地文件路径</span></span><br><span class="line">local_path = <span class="string">r&#x27;C:\path\to\your\file.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目标路径</span></span><br><span class="line">remote_path = <span class="string">&#x27;your_linux_username@your_linux_server_ip:/home/your_username/file.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SCP 命令</span></span><br><span class="line">scp_command = <span class="string">f&#x27;scp &quot;<span class="subst">&#123;local_path&#125;</span>&quot; <span class="subst">&#123;remote_path&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 SCP 命令</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    subprocess.run(scp_command, shell=<span class="literal">True</span>, check=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;File <span class="subst">&#123;local_path&#125;</span> transferred successfully to <span class="subst">&#123;remote_path&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将 <code>local_path</code> 替换为你要传输的本地文件路径。</li>
<li>将 <code>remote_path</code> 替换为 Linux 上的目标路径，格式为 <code>username@server_ip:path/to/remote/file.txt</code>。</li>
</ul>
</li>
<li><p><strong>运行 Python 脚本</strong></p>
<p>在 Windows 上运行这个 Python 脚本，它会调用系统的 SCP 工具，将文件传输到指定的 Linux 服务器。</p>
</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>确保 Windows 上的网络连接能够访问到 Linux 服务器。</li>
<li>在使用 Paramiko 或 SCP 传输文件时，建议确保 Linux 服务器的 SSH 服务正常运行，并且有相应的权限和路径可用于文件传输。</li>
<li>根据实际情况，可以根据需要进行进一步的错误处理和安全设置，比如使用 SSH 密钥认证替代密码认证等。</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Puls 批量插入实现</title>
    <url>/2024/07/03/MyBatis-Puls-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p><code>BaseMapper</code> 默认不提供批量插入</p>
</blockquote>
<h2 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper</h2><p>实体类对应的mapper在继承BaseMapper后，就可以使用以下Mybatis-plus提供的方法进行数据操作。<br>BaseMapper中默认提供一个insert()方法，仅支持数据的单条插入。如果有上万甚至数十万数据需要插入时，耗时过久。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="IService"><a href="#IService" class="headerlink" title="IService"></a>IService</h2><p>与BaseMapper相同，实体类对应接口在继承了IService后，可以调用其中提供的save(),saveBatch()进行插入操作。其中saveBatch()入参为list，可以实现批量插入。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IService</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认批次提交数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">DEFAULT_BATCH_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().insert(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入（批量）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> saveBatch(entityList, DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入（批量）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  插入批次数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量修改插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> saveOrUpdateBatch(entityList, DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量修改插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  每次的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是，saveBatch()方法实现的批量插入其实是伪批量，其底层实现仍然是一条条数据进行插入的。源码的解析就不贴了，有兴趣的小伙伴可以看一下这篇文章</p>
<p><a class="link"   href="https://www.cnblogs.com/chcha1/p/16340254.html" >为什么说saveBatch是伪批量插入?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="通过添加mapper层选装插件实现真正的批量插入"><a href="#通过添加mapper层选装插件实现真正的批量插入" class="headerlink" title="通过添加mapper层选装插件实现真正的批量插入"></a>通过添加mapper层选装插件实现真正的批量插入</h2><p>Mybatis-plus其实是有真正实现了批量插入的方法的，方法名是insertBatchSomeColumn()需要我们配合SQL注入器来开启。(可能是因为仅支持MySQL，所以作者没有将其设置为默认方法？)</p>
<p>开启insertBatchSomeColumn()可分为3个步骤:</p>
<h3 id="创建插件类"><a href="#创建插件类" class="headerlink" title="创建插件类"></a>创建插件类</h3><p>新建一个名为InsertBatchSqlInjector 的类，继承DefaultSqlInjector。（当然，类名可以根据自己的喜好来）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertBatchSqlInjector</span> <span class="keyword">extends</span> <span class="title class_">DefaultSqlInjector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title function_">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass, TableInfo tableInfo)</span> &#123;</span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="built_in">super</span>.getMethodList(mapperClass, tableInfo);</span><br><span class="line">        <span class="comment">// 添加InsertBatchSomeColumn方法</span></span><br><span class="line">        methodList.add(<span class="keyword">new</span> <span class="title class_">InsertBatchSomeColumn</span>());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="将SQL注入器交给Spring容器"><a href="#将SQL注入器交给Spring容器" class="headerlink" title="将SQL注入器交给Spring容器"></a>将SQL注入器交给Spring容器</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InsertBatchSqlInjector insertBatchSqlInjector;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加批量插入插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GlobalConfig <span class="title function_">globalConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        globalConfig.setSqlInjector(insertBatchSqlInjector);</span><br><span class="line">        <span class="keyword">return</span> globalConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>💡 这一步中，有一点需要注意。如果你的MybatisPlusConfig类中自定义了sqlSessionFactory，上面的配置不会被加载到，需要在sqlSessionFactory中进行设置。</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;sqlSessionFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(<span class="meta">@Qualifier(&quot;globalConfig&quot;)</span> GlobalConfig globalConfig )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">MybatisSqlSessionFactoryBean</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisSqlSessionFactoryBean</span>();</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 其他设置，与本话题无关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加自定义sql注入接口</span></span><br><span class="line">    sqlSessionFactory.setGlobalConfig(globalConfig);<span class="comment">//添加自定义sql注入接口</span></span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="配置自定义Mapper继承BaseMapper"><a href="#配置自定义Mapper继承BaseMapper" class="headerlink" title="配置自定义Mapper继承BaseMapper"></a>配置自定义Mapper继承BaseMapper</h3><p>新建BaseBatchMapper类，继承BaseMapper，并在此类中配置insertBatchSomeColumn()方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseBatchMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入 仅适用于mysql</span></span><br><span class="line"><span class="comment">     * 如果要自动填充，<span class="doctag">@Param</span>(xx) xx参数名必须是 list/collection/array 3个的其中之一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer <span class="title function_">insertBatchSomeColumn</span><span class="params">(<span class="meta">@Param(&quot;list&quot;)</span> Collection&lt;T&gt; list)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，用业务Mapper继承BaseBatchMapper就可以调用insertBatchSomeColumn()方法了。</p>
<blockquote>
<p>当然，如果在你的项目中，仅仅有一两个类需要用到批量插入，那完全没必要抽取一个BaseBatchMapper。直接用你的业务Mapper继承BaseMapper，并在对应业务Mapper中配置insertBatchSomeColumn()方法即可，代码同上。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://blog.csdn.net/knock_me/article/details/132165909" >Mybatis-plus实现【真·批量插入】<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
        <category>ORM</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatisPlus</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column </title>
    <url>/2024/07/05/MySQL-Expression-1-of-SELECT-list-is-not-in-GROUP-BY-clause-and-contains-nonaggregated-column/</url>
    <content><![CDATA[<div class="code-container" data-rel="Ini"><figure class="iseeu highlight ini"><table><tr><td class="code"><pre><span class="line">Error querying database.  Cause: java.sql.SQLSyntaxErrorException: Expression <span class="comment">#1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;db.table.id&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</span></span><br></pre></td></tr></table></figure></div>

<p>这个错误通常是因为 MySQL 数据库的 <code>sql_mode</code> 设置了 <code>only_full_group_by</code>，导致在执行 SQL 查询时，必须将 GROUP BY 子句中的每个非聚合列都包含在 SELECT 列表中。如果查询中的 SELECT 列表包含非聚合列，但没有在 GROUP BY 子句中指定，就会导致这个错误。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h2><h3 id="方法一-调整查询语句"><a href="#方法一-调整查询语句" class="headerlink" title="方法一: 调整查询语句"></a>方法一: 调整查询语句</h3><p>在 SQL 查询中，确保将 SELECT 列表中的每个列都包含在 GROUP BY 子句中。如果查询是这样的: </p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> name;</span><br></pre></td></tr></table></figure></div>

<p>要解决问题，应该将 id 列也包含在 GROUP BY 子句中: </p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id, name;</span><br></pre></td></tr></table></figure></div>

<h3 id="方法二-修改-MySQL-的-sql-mode"><a href="#方法二-修改-MySQL-的-sql-mode" class="headerlink" title="方法二: 修改 MySQL 的 sql_mode"></a>方法二: 修改 MySQL 的 sql_mode</h3><p>如果不方便修改查询语句或者需要保持现有查询逻辑，可以修改 MySQL 的 sql_mode，移除 only_full_group_by。这样做需要注意，因为 only_full_group_by 是 MySQL 的一种严格模式，移除它可能会导致在某些情况下出现不符合预期的查询结果。</p>
<p>可以通过以下步骤来修改 MySQL 的 sql_mode: </p>
<p>打开 MySQL 配置文件，通常位于 <code>/etc/mysql/my.cnf</code> 或 <code>/etc/my.cnf</code>。</p>
<p>找到 sql_mode 配置项，类似于: </p>
<div class="code-container" data-rel="Ini"><figure class="iseeu highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">sql_mode</span> = <span class="string">&quot;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>移除其中的 only_full_group_by，或者将整个 sql_mode 设置为适合的值。</p>
<p>重启 MySQL 服务使修改生效: </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart mysql</span><br></pre></td></tr></table></figure></div>

<p>请注意，在生产环境中修改 sql_mode 之前，请务必进行充分的测试，并确保了解可能带来的影响。</p>
<h3 id="方法三-使用-MySQL-的-ANY-VALUE-函数"><a href="#方法三-使用-MySQL-的-ANY-VALUE-函数" class="headerlink" title="方法三: 使用 MySQL 的 ANY_VALUE() 函数"></a>方法三: 使用 MySQL 的 ANY_VALUE() 函数</h3><p>在 MySQL 5.7 版本及以上，可以使用 ANY_VALUE() 函数来解决这个问题。这个函数可以避免严格模式下 GROUP BY 子句中非聚合列的问题。例如: </p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ANY_VALUE(id), name, <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> name;</span><br></pre></td></tr></table></figure></div>

<h2 id="方法四-使用-SQL-设置-sql-mode"><a href="#方法四-使用-SQL-设置-sql-mode" class="headerlink" title="方法四: 使用 SQL 设置 sql_mode"></a>方法四: 使用 SQL 设置 sql_mode</h2><p>命令行 设置 <code>sql_mode=only_full_group_by</code></p>
<p>在登录到 MySQL 后，可以执行以下命令查看当前的 sql_mode 设置: </p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@sql_mode</span>;</span><br></pre></td></tr></table></figure></div>

<p>这将显示当前的 sql_mode 配置。</p>
<p>设置新的 sql_mode</p>
<p>要设置 sql_mode，可以使用 SET GLOBAL 或 SET SESSION 命令。一般来说，全局设置需要超级用户权限，而会话级别设置只对当前连接有效，不需要特殊权限。</p>
<p>设置会话级别的 sql_mode: </p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION sql_mode <span class="operator">=</span> <span class="string">&#x27;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,...&#x27;</span>;  <span class="comment">-- 添加或替换需要的 sql_mode 值</span></span><br></pre></td></tr></table></figure></div>

<p>设置全局级别的 sql_mode（需要超级用户权限）: </p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> GLBAL sql_mode <span class="operator">=</span> <span class="string">&#x27;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,...&#x27;</span>;  <span class="comment">-- 添加或替换需要的 sql_mode 值</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意: 全局级别的设置会影响所有新连接到 MySQL 的会话，而会话级别的设置仅对当前会话有效。</p>
</blockquote>
<p>验证设置是否生效</p>
<p>设置完成后，可以再次执行 <code>SELECT @@sql_mode;</code> 命令来验证新的 sql_mode 是否已生效。</p>
<p>永久修改配置文件</p>
<p>如果希望永久修改 sql_mode，可以编辑 MySQL 的配置文件（如 &#x2F;etc&#x2F;mysql&#x2F;my.cnf 或 &#x2F;etc&#x2F;my.cnf），找到 sql_mode 配置项，并修改为需要的值。然后重启 MySQL 服务使修改生效: </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart mysql</span><br></pre></td></tr></table></figure></div>

<p>这样修改后，MySQL 将会在每次启动时使用新的 sql_mode 设置。</p>
<blockquote>
<p>注意事项:<br>修改 sql_mode 可能会影响到现有的应用程序和查询行为，请确保在生产环境中进行充分测试。<br>建议仅修改和删除有必要的 sql_mode 设置，以确保数据库的安全性和一致性。<br>在修改全局级别的 sql_mode 时需要特别注意，避免对其他应用产生不必要的影响。<br>通过以上步骤，可以在命令行中设置 MySQL 的 sql_mode，解决与 only_full_group_by 相关的 SQL 查询问题。<br>这样可以避免 id 列不在 GROUP BY 子句中的问题。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据具体情况，选择适合的方法来解决 <code>Expression #1 of SELECT list is not in GROUP BY clause</code> 错误。一般建议优先考虑调整查询语句或使用 <code>ANY_VALUE()</code> 函数来符合严格的 <code>sql_mode</code> 要求，保持数据库的安全性和一致性。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 脚本 进度条显示 2 样式美化</title>
    <url>/2024/07/11/Python-%E8%84%9A%E6%9C%AC-%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%98%BE%E7%A4%BA-2-%E6%A0%B7%E5%BC%8F%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p><code>tqdm</code> 增加 <code>bar_format</code> , <code>ascii</code> 配置</p>
<h3 id="进度条背景样式"><a href="#进度条背景样式" class="headerlink" title="进度条背景样式"></a>进度条背景样式</h3><p><code>ascii=&quot;-━&quot;</code> 需两个字符</p>
<ul>
<li>首字符 <code>-</code> 为背景</li>
<li>尾字符 <code>━</code> 为实际进度</li>
</ul>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/process_bar.png"
                      alt="效果"
                ><figcaption>效果</figcaption></figure></p>
<h3 id="python-执行命令日志同一行刷新"><a href="#python-执行命令日志同一行刷新" class="headerlink" title="python 执行命令日志同一行刷新"></a>python 执行命令日志同一行刷新</h3><ul>
<li>加入<code>\r</code> <code>desc=f&#39;\rUploading &#123;os.path.basename(local_path)&#125;&#39;</code></li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH 连接信息</span></span><br><span class="line">hostname = <span class="string">&#x27;your_linux_server_ip&#x27;</span></span><br><span class="line">port = <span class="number">22</span></span><br><span class="line">username = <span class="string">&#x27;your_linux_username&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;your_linux_password&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目标路径</span></span><br><span class="line">remote_path = <span class="string">&#x27;/home/target_path/file.txt&#x27;</span></span><br><span class="line">base_path = <span class="string">r&#x27;E:\source_path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 os.path.join() 拼接路径</span></span><br><span class="line">local_path = os.path.join(base_path, filename)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目标路径</span></span><br><span class="line">remote_path = <span class="string">&#x27;/root/&#x27;</span> + filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取本地文件大小</span></span><br><span class="line">local_file_size = os.path.getsize(local_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 SSH 连接</span></span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">ssh.connect(hostname, port, username, password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 SFTP 协议传输文件</span></span><br><span class="line">sftp = ssh.open_sftp()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进度条样式</span></span><br><span class="line">bar_format = <span class="string">&quot;&#123;desc&#125;: &#123;percentage:3.0f&#125;%|&#123;bar:42&#125;| &#123;n_fmt&#125;/&#123;total_fmt&#125; [&#123;elapsed&#125;&lt;&#123;remaining&#125;, &#123;rate_fmt&#125;]&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示进度条</span></span><br><span class="line"><span class="keyword">with</span> tqdm(total=local_file_size,</span><br><span class="line">          unit=<span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">          unit_scale=<span class="literal">True</span>,</span><br><span class="line">          desc=<span class="string">f&#x27;\rUploading <span class="subst">&#123;os.path.basename(local_path)&#125;</span>&#x27;</span>,</span><br><span class="line">          bar_format=bar_format,</span><br><span class="line">          <span class="built_in">ascii</span>=<span class="string">&quot;-━&quot;</span>,</span><br><span class="line">          ncols=<span class="number">42</span>,</span><br><span class="line">          colour=<span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">          dynamic_ncols=<span class="literal">True</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">data_transferred, total_size</span>):</span><br><span class="line">        pbar.update(data_transferred - pbar.n)</span><br><span class="line"></span><br><span class="line">    sftp.put(local_path, remote_path, callback=callback)</span><br><span class="line">sftp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 SSH 连接</span></span><br><span class="line">ssh.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File <span class="subst">&#123;os.path.basename(local_path)&#125;</span> transferred successfully to <span class="subst">&#123;hostname&#125;</span>:<span class="subst">&#123;remote_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 脚本 进度条显示</title>
    <url>/2024/07/10/Python-%E8%84%9A%E6%9C%AC-%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>在 Python 脚本中加入进度条显示通常可以通过第三方库来实现。具体到文件传输的场景，可以使用 <code>tqdm</code> 库来显示进度条，无论是使用 Paramiko 还是 SCP 命令都可以适用。下面分别介绍如何在这两种情况下添加进度条显示。</p>
<h3 id="使用-tqdm-显示进度条"><a href="#使用-tqdm-显示进度条" class="headerlink" title="使用 tqdm 显示进度条"></a>使用 <code>tqdm</code> 显示进度条</h3><p>首先，确保已经安装 <code>tqdm</code> 库：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install tqdm</span><br></pre></td></tr></table></figure></div>

<h4 id="1-使用-Paramiko-实现文件传输并显示进度条"><a href="#1-使用-Paramiko-实现文件传输并显示进度条" class="headerlink" title="1. 使用 Paramiko 实现文件传输并显示进度条"></a>1. 使用 Paramiko 实现文件传输并显示进度条</h4><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH 连接信息</span></span><br><span class="line">hostname = <span class="string">&#x27;your_linux_server_ip&#x27;</span></span><br><span class="line">port = <span class="number">22</span></span><br><span class="line">username = <span class="string">&#x27;your_linux_username&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;your_linux_password&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地文件路径</span></span><br><span class="line">local_path = <span class="string">r&#x27;C:\path\to\your\file.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目标路径</span></span><br><span class="line">remote_path = <span class="string">&#x27;/home/your_username/file.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取本地文件大小</span></span><br><span class="line">local_file_size = os.path.getsize(local_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 SSH 连接</span></span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">ssh.connect(hostname, port, username, password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 SFTP 协议传输文件</span></span><br><span class="line">sftp = ssh.open_sftp()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示进度条</span></span><br><span class="line"><span class="keyword">with</span> tqdm(total=local_file_size, unit=<span class="string">&#x27;B&#x27;</span>, unit_scale=<span class="literal">True</span>, desc=<span class="string">f&#x27;Uploading <span class="subst">&#123;os.path.basename(local_path)&#125;</span>&#x27;</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">data_transferred, total_size</span>):</span><br><span class="line">        pbar.update(data_transferred - pbar.n)</span><br><span class="line"></span><br><span class="line">    sftp.put(local_path, remote_path, callback=callback)</span><br><span class="line"></span><br><span class="line">sftp.close()</span><br><span class="line">ssh.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File <span class="subst">&#123;os.path.basename(local_path)&#125;</span> transferred successfully to <span class="subst">&#123;hostname&#125;</span>:<span class="subst">&#123;remote_path&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>tqdm(total=local_file_size, unit=&#39;B&#39;, unit_scale=True, desc=f&#39;Uploading &#123;os.path.basename(local_path)&#125;&#39;)</code>：设置进度条，<code>total</code> 参数设置为文件大小，<code>desc</code> 参数设置进度条描述。</li>
<li><code>callback</code> 函数用于在传输过程中更新进度条。</li>
</ul>
<h4 id="2-使用-SCP-命令和-subprocess-实现文件传输并显示进度条"><a href="#2-使用-SCP-命令和-subprocess-实现文件传输并显示进度条" class="headerlink" title="2. 使用 SCP 命令和 subprocess 实现文件传输并显示进度条"></a>2. 使用 SCP 命令和 <code>subprocess</code> 实现文件传输并显示进度条</h4><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地文件路径</span></span><br><span class="line">local_path = <span class="string">r&#x27;C:\path\to\your\file.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程目标路径</span></span><br><span class="line">remote_path = <span class="string">&#x27;your_linux_username@your_linux_server_ip:/home/your_username/file.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取本地文件大小</span></span><br><span class="line">local_file_size = os.path.getsize(local_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SCP 命令</span></span><br><span class="line">scp_command = <span class="string">f&#x27;scp &quot;<span class="subst">&#123;local_path&#125;</span>&quot; <span class="subst">&#123;remote_path&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示进度条</span></span><br><span class="line"><span class="keyword">with</span> tqdm(total=local_file_size, unit=<span class="string">&#x27;B&#x27;</span>, unit_scale=<span class="literal">True</span>, desc=<span class="string">f&#x27;Copying <span class="subst">&#123;os.path.basename(local_path)&#125;</span>&#x27;</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_progress</span>(<span class="params">chunk</span>):</span><br><span class="line">        pbar.update(chunk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        process = subprocess.Popen(scp_command, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            output = process.stderr.read(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> output:</span><br><span class="line">                update_progress(<span class="built_in">len</span>(output))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        process.wait()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File <span class="subst">&#123;local_path&#125;</span> transferred successfully to <span class="subst">&#123;remote_path&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>tqdm(total=local_file_size, unit=&#39;B&#39;, unit_scale=True, desc=f&#39;Copying &#123;os.path.basename(local_path)&#125;&#39;)</code>：设置进度条，<code>total</code> 参数设置为文件大小，<code>desc</code> 参数设置进度条描述。</li>
<li><code>update_progress</code> 函数用于在传输过程中更新进度条。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在使用 Paramiko 或者 SCP 命令传输文件时，进度条的更新通常依赖于回调函数或者实时读取输出流的长度。</li>
<li><code>tqdm</code> 库提供了丰富的配置选项，可以根据需求进行进一步定制，比如调整单位、显示格式等。</li>
<li>确保在传输大文件时，进度条的更新是基于传输数据量而不是文件读写操作的频率，以确保进度条的准确性和平滑显示。</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ 延时队列</title>
    <url>/2024/08/05/RabbitMQ-%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要在 RabbitMQ 中安装和配置延时队列插件(<code>rabbitmq_delayed_message_exchange</code>)，你需要执行以下步骤：</p>
<h3 id="使用-RabbitMQ-包管理器安装延时消息交换机插件"><a href="#使用-RabbitMQ-包管理器安装延时消息交换机插件" class="headerlink" title="使用 RabbitMQ 包管理器安装延时消息交换机插件"></a>使用 RabbitMQ 包管理器安装延时消息交换机插件</h3><ol>
<li><p>确保 RabbitMQ 已经安装</p>
<p>首先，确保你已经安装了 RabbitMQ。你可以通过以下命令检查 RabbitMQ 服务是否在运行：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>安装插件</p>
<p>RabbitMQ 提供了 <code>rabbitmq_delayed_message_exchange</code> 插件来支持延时消息。使用以下命令来安装插件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>检查插件是否安装成功</p>
<p>你可以通过以下命令查看插件列表，确认插件是否启用：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rabbitmq-plugins list</span><br></pre></td></tr></table></figure></div>

<p>检查输出中是否包含 <code>rabbitmq_delayed_message_exchange</code> 插件，并且状态为 <code>E</code>(已启用)。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Listing plugins with pattern <span class="string">&quot;.*&quot;</span> ...</span><br><span class="line">Configured: E = explicitly enabled; e = implicitly enabled</span><br><span class="line">| Status: * = running on rabbit@dev-dms-appserver</span><br><span class="line">|/</span><br><span class="line">[E*] rabbitmq_delayed_message_exchange 3.12.0</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="管理界面配置延时交换机"><a href="#管理界面配置延时交换机" class="headerlink" title="管理界面配置延时交换机"></a>管理界面配置延时交换机</h3><p>你可以通过 RabbitMQ 管理界面或命令行创建和配置延时交换机。</p>
<ul>
<li><p>通过 RabbitMQ 管理界面</p>
<ol>
<li>登录 RabbitMQ 管理界面(通常在 <code>http://localhost:15672</code>)。</li>
<li>转到 “Exchanges” 页面。</li>
<li>点击 “Add a new exchange”。</li>
<li>填写表单：<ul>
<li>Name: <code>delayed_exchange</code>(可以自定义名称)</li>
<li>Type: 选择 <code>x-delayed-message</code> 类型</li>
<li>Durable: 勾选(可选，根据需求)</li>
<li>Auto-delete: 取消勾选(可选，根据需求)</li>
</ul>
</li>
<li>在 “Arguments” 部分，添加以下参数：<ul>
<li>Key: <code>x-delayed-type</code></li>
<li>Value: <code>direct</code>(或其他类型，如 <code>topic</code>，根据你的需求)</li>
</ul>
</li>
</ol>
</li>
<li><p>通过命令行工具</p>
<p>使用 <code>rabbitmqadmin</code> 工具(你可以从 RabbitMQ 下载并安装)：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqadmin <span class="built_in">declare</span> exchange name=delayed_exchange <span class="built_in">type</span>=x-delayed-message durable=<span class="literal">true</span> arguments=<span class="string">&#x27;&#123;&quot;x-delayed-type&quot;:&quot;direct&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="HTTP-API-创建延时队列"><a href="#HTTP-API-创建延时队列" class="headerlink" title="HTTP API 创建延时队列"></a>HTTP API 创建延时队列</h3><p>你可以通过创建一个延时队列并发送消息来验证插件是否按预期工作。</p>
<p>通过 RabbitMQ Management HTTP API 测试：</p>
<ol>
<li><p>创建交换机：</p>
<p>使用延时交换机类型创建一个交换机。你可以使用以下 cURL 命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u username:password -X PUT -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">-d <span class="string">&#x27;&#123;&quot;type&quot;: &quot;x-delayed-message&quot;, &quot;arguments&quot;: &#123;&quot;x-delayed-type&quot;: &quot;direct&quot;&#125;&#125;&#x27;</span> \</span><br><span class="line">http://localhost:15672/api/exchanges/%2f/delayed_exchange</span><br></pre></td></tr></table></figure></div>

<p>这会创建一个名为 <code>delayed_exchange</code> 的延时交换机，<code>%2f</code> 是默认虚拟主机的 URL 编码形式。</p>
</li>
<li><p>创建队列：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u username:password -X PUT -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">-d <span class="string">&#x27;&#123;&quot;durable&quot;: true&#125;&#x27;</span> \</span><br><span class="line">http://localhost:15672/api/queues/%2f/delayed_queue</span><br></pre></td></tr></table></figure></div>

<p>这会创建一个名为 <code>delayed_queue</code> 的队列。</p>
</li>
<li><p>绑定交换机到队列：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u username:password -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">-d <span class="string">&#x27;&#123;&quot;routing_key&quot;: &quot;delayed_routing_key&quot;&#125;&#x27;</span> \</span><br><span class="line">http://localhost:15672/api/bindings/%2f/e/delayed_exchange/q/delayed_queue</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>发布延时消息：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u username:password -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">-d <span class="string">&#x27;&#123;&quot;properties&quot;: &#123;&quot;headers&quot;: &#123;&quot;x-delay&quot;: 10000&#125;&#125;, &quot;routing_key&quot;: &quot;delayed_routing_key&quot;, &quot;payload&quot;: &quot;Test message&quot;&#125;&#x27;</span> \</span><br><span class="line">http://localhost:15672/api/exchanges/%2f/delayed_exchange/publish</span><br></pre></td></tr></table></figure></div>

<p>这个命令会将一条延时 10 秒的消息发布到 <code>delayed_exchange</code> 交换机。</p>
</li>
</ol>
<h3 id="Spring-Boot-应用中使用延时交换机"><a href="#Spring-Boot-应用中使用延时交换机" class="headerlink" title="Spring Boot 应用中使用延时交换机"></a>Spring Boot 应用中使用延时交换机</h3><p>确保你的 Spring Boot 应用配置了正确的延时交换机设置。以下是一个 Spring Boot 配置的示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(<span class="string">&quot;delayed_exchange&quot;</span>, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>,</span><br><span class="line">                Map.of(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delayed_queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(Queue delayedQueue, CustomExchange delayedExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(<span class="string">&quot;delayed_routing_key&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="发布延时消息"><a href="#发布延时消息" class="headerlink" title="发布延时消息"></a>发布延时消息</h3><p>使用以下代码发布延时消息到延时交换机：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayedMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;delayed_exchange&quot;</span>, <span class="string">&quot;delayed_routing_key&quot;</span>, message, messagePostProcessor -&gt; &#123;</span><br><span class="line">            messagePostProcessor.getMessageProperties().setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">10000</span>); <span class="comment">// 设置延时为 10 秒</span></span><br><span class="line">            <span class="keyword">return</span> messagePostProcessor;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3><ul>
<li><p>确保 RabbitMQ 服务已重启以应用更改：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用 RabbitMQ 管理界面验证交换机和队列配置是否正确。</p>
</li>
<li><p>发送测试消息，检查延时是否生效。</p>
</li>
</ul>
<p>如果在设置过程中遇到问题，可以查看 RabbitMQ 的日志文件，通常位于 <code>/var/log/rabbitmq/</code>，以获取更多调试信息。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SonarLint - Use a secure cipher mode</title>
    <url>/2024/07/22/SonarLint-Use-a-secure-cipher-mode/</url>
    <content><![CDATA[<blockquote>
<p>SonarLint 是一个静态代码分析工具，它帮助开发者发现和修复代码中的漏洞和问题。它的警告 <code>Use a secure cipher mode</code> 主要是为了提醒开发者在使用加密算法时选择安全的加密模式。下面我将详细介绍如何满足这个建议，包括如何选择安全的加密模式和避免不安全的模式。</p>
</blockquote>
<h2 id="为什么要使用安全的加密模式？"><a href="#为什么要使用安全的加密模式？" class="headerlink" title="为什么要使用安全的加密模式？"></a>为什么要使用安全的加密模式？</h2><p>加密算法的安全性不仅取决于加密算法本身，还取决于加密模式。不同的加密模式对数据加密的方式和安全性有不同的影响。选择不安全的模式可能导致数据泄露、篡改或被攻击者利用。因此，使用安全的加密模式是保护数据隐私和完整性的关键。</p>
<h2 id="常见加密模式及其安全性"><a href="#常见加密模式及其安全性" class="headerlink" title="常见加密模式及其安全性"></a>常见加密模式及其安全性</h2><h3 id="不安全的加密模式"><a href="#不安全的加密模式" class="headerlink" title="不安全的加密模式"></a>不安全的加密模式</h3><p>以下是一些不推荐使用的加密模式以及它们的安全问题：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
<th>安全问题</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ECB (电子密码本模式)</strong></td>
<td>对每一个数据块进行相同的加密操作。</td>
<td>相同的明文块会加密成相同的密文块，容易受到模式识别攻击。</td>
</tr>
</tbody></table>
<h3 id="安全的加密模式"><a href="#安全的加密模式" class="headerlink" title="安全的加密模式"></a>安全的加密模式</h3><p>以下是一些推荐的加密模式以及它们的安全性分析：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
<th>优点</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CBC (密码分组链接模式)</strong></td>
<td>通过将前一个密文块与当前明文块结合进行加密。</td>
<td>防止模式识别攻击，广泛应用于加密任务。</td>
<td>数据加密，尤其是数据存储和通信。</td>
</tr>
<tr>
<td><strong>GCM (Galois&#x2F;Counter Mode)</strong></td>
<td>结合了加密和认证功能的模式，提供了加密和完整性验证。</td>
<td>高效且提供认证功能，广泛用于现代加密应用。</td>
<td>高安全要求的加密场景，如加密网络通信。</td>
</tr>
<tr>
<td><strong>CCM (Counter with CBC-MAC)</strong></td>
<td>结合计数器模式和 CBC-MAC 进行加密和消息认证。</td>
<td>提供加密和完整性验证，适用于高安全要求的场景。</td>
<td>高安全性的数据加密和认证。</td>
</tr>
</tbody></table>
<h3 id="推荐使用的加密模式"><a href="#推荐使用的加密模式" class="headerlink" title="推荐使用的加密模式"></a>推荐使用的加密模式</h3><p>对于大多数应用程序，<strong>CBC</strong>、<strong>GCM</strong> 和 <strong>CCM</strong> 是推荐的加密模式。以下是每种模式的详细介绍和使用示例：</p>
<h4 id="1-CBC-Cipher-Block-Chaining-Mode"><a href="#1-CBC-Cipher-Block-Chaining-Mode" class="headerlink" title="1. CBC (Cipher Block Chaining Mode)"></a>1. <strong>CBC (Cipher Block Chaining Mode)</strong></h4><p><strong>CBC</strong> 是一种常用的加密模式，通过将前一个密文块与当前明文块结合来进行加密。使用 <strong>CBC</strong> 模式时，必须使用初始化向量（IV），并且 IV 需要是随机生成的。</p>
<div class="tabs" id="tab-first-cbc"><ul class="nav-tabs"><li class="tab active"><a class="#first-cbc-1">Java 示例</a></li><li class="tab"><a class="#first-cbc-2">Python 示例</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-cbc-1"><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CBCModeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成密钥</span></span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">keyGen</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        keyGen.init(<span class="number">256</span>);  <span class="comment">// 选择 128, 192 或 256 位的密钥长度</span></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyGen.generateKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Cipher 对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化向量 (IV)</span></span><br><span class="line">        <span class="type">byte</span>[] iv = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];  <span class="comment">// AES 块大小为 16 字节</span></span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">ivSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(iv);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 Cipher 对象</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);</span><br><span class="line">        <span class="type">byte</span>[] encrypted = cipher.doFinal(<span class="string">&quot;Hello, World!&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解密过程</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);</span><br><span class="line">        <span class="type">byte</span>[] decrypted = cipher.doFinal(encrypted);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decrypted));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="first-cbc-2"><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密钥</span></span><br><span class="line">key = get_random_bytes(<span class="number">32</span>)  <span class="comment"># 256 位密钥</span></span><br><span class="line">iv = get_random_bytes(<span class="number">16</span>)  <span class="comment"># 生成一个随机 IV</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC, iv)  <span class="comment"># 使用 CBC 模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充数据</span></span><br><span class="line">plaintext = <span class="string">b&#x27;Hello, World!&#x27;</span></span><br><span class="line">pad_len = <span class="number">16</span> - <span class="built_in">len</span>(plaintext) % <span class="number">16</span></span><br><span class="line">padded_plaintext = plaintext + <span class="built_in">bytes</span>([pad_len] * pad_len)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">ciphertext = cipher.encrypt(padded_plaintext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密过程</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC, iv)  <span class="comment"># 需要使用相同的IV进行解密</span></span><br><span class="line">decrypted_padded_plaintext = cipher.decrypt(ciphertext)</span><br><span class="line">pad_len = decrypted_padded_plaintext[-<span class="number">1</span>]</span><br><span class="line">plaintext = decrypted_padded_plaintext[:-pad_len]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(plaintext.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure></div></div></div></div>

<h4 id="2-GCM-Galois-Counter-Mode"><a href="#2-GCM-Galois-Counter-Mode" class="headerlink" title="2. GCM (Galois&#x2F;Counter Mode)"></a>2. <strong>GCM (Galois&#x2F;Counter Mode)</strong></h4><p><strong>GCM</strong> 是一种认证加密模式，结合了加密和认证，提供了完整性验证和加密功能。它适用于需要加密和数据完整性的应用场景。</p>
<div class="tabs" id="tab-first-gcm"><ul class="nav-tabs"><li class="tab active"><a class="#first-gcm-1">Java 示例</a></li><li class="tab"><a class="#first-gcm-2">Python 示例</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-gcm-1"><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.AEADBadTagException;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.GCMParameterSpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCMModeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成密钥</span></span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">keyGen</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        keyGen.init(<span class="number">256</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyGen.generateKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Cipher 对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/GCM/NoPadding&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成随机 IV 和 Tag Length</span></span><br><span class="line">        <span class="type">byte</span>[] iv = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">12</span>];  <span class="comment">// 12 字节的 IV 是 GCM 的推荐长度</span></span><br><span class="line">        <span class="type">GCMParameterSpec</span> <span class="variable">gcmSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GCMParameterSpec</span>(<span class="number">128</span>, iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 Cipher 对象</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey, gcmSpec);</span><br><span class="line">        <span class="type">byte</span>[] plaintext = <span class="string">&quot;Hello, World!&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">byte</span>[] encrypted = cipher.doFinal(plaintext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解密过程</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec);</span><br><span class="line">        <span class="type">byte</span>[] decrypted = cipher.doFinal(encrypted);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decrypted));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="first-gcm-2"><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密钥</span></span><br><span class="line">key = get_random_bytes(<span class="number">32</span>)  <span class="comment"># 256 位密钥</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_GCM)  <span class="comment"># 使用 GCM 模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">plaintext = <span class="string">b&#x27;Hello, World!&#x27;</span></span><br><span class="line">ciphertext, tag = cipher.encrypt_and_digest(plaintext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密过程</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_GCM, nonce=cipher.nonce)  <span class="comment"># 使用相同的 nonce 进行解密</span></span><br><span class="line">decrypted = cipher.decrypt_and_verify(ciphertext, tag)</span><br><span class="line"><span class="built_in">print</span>(decrypted.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure></div></div></div></div>

<h4 id="3-CCM-Counter-with-CBC-MAC-Mode"><a href="#3-CCM-Counter-with-CBC-MAC-Mode" class="headerlink" title="3. CCM (Counter with CBC-MAC Mode)"></a>3. <strong>CCM (Counter with CBC-MAC Mode)</strong></h4><p><strong>CCM</strong> 结合了计数器模式和 CBC-MAC 进行加密和消息认证。它适用于需要认证加密的场景。</p>
<div class="tabs" id="tab-first-ccm"><ul class="nav-tabs"><li class="tab active"><a class="#first-ccm-1">Java 示例</a></li><li class="tab"><a class="#first-ccm-2">Python 示例</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-ccm-1"><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.GCMParameterSpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CCMModeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成密钥</span></span><br><span class="line">        <span class="type">KeyGenerator</span> <span class="variable">keyGen</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        keyGen.init(<span class="number">256</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyGen.generateKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Cipher 对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CCM/NoPadding&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成随机 IV 和 Tag Length</span></span><br><span class="line">        <span class="type">byte</span>[] iv = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">12</span>];  <span class="comment">// 12 字节的 IV 是 CCM 的推荐长度</span></span><br><span class="line">        <span class="type">GCMParameterSpec</span> <span class="variable">gcmSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GCMParameterSpec</span>(<span class="number">128</span>, iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 Cipher 对象</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey, gcmSpec);</span><br><span class="line">        <span class="type">byte</span>[] plaintext = <span class="string">&quot;Hello, World!&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">byte</span>[] encrypted = cipher.doFinal(plaintext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解密过程</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec);</span><br><span class="line">        <span class="type">byte</span>[] decrypted = cipher.doFinal(encrypted);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decrypted));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="first-ccm-2"><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密钥</span></span><br><span class="line">key = get_random_bytes(<span class="number">32</span>)  <span class="comment"># 256 位密钥</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_CCM, nonce=get_random_bytes(<span class="number">12</span>))  <span class="comment"># 使用 CCM 模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">plaintext = <span class="string">b&#x27;Hello, World!&#x27;</span></span><br><span class="line">ciphertext, tag = cipher.encrypt_and_digest(plaintext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密过程</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_CCM, nonce=cipher</span><br><span class="line"></span><br><span class="line">.nonce)  <span class="comment"># 使用相同的 nonce 进行解密</span></span><br><span class="line">decrypted = cipher.decrypt_and_verify(ciphertext, tag)</span><br><span class="line"><span class="built_in">print</span>(decrypted.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure></div></div></div></div>

<h2 id="如何避免不安全的加密模式"><a href="#如何避免不安全的加密模式" class="headerlink" title="如何避免不安全的加密模式"></a>如何避免不安全的加密模式</h2><h3 id="1-避免使用-ECB-模式"><a href="#1-避免使用-ECB-模式" class="headerlink" title="1. 避免使用 ECB 模式"></a>1. <strong>避免使用 ECB 模式</strong></h3><p>在选择加密模式时，应该避免使用 <strong>ECB</strong> 模式，因为它不能防止模式识别攻击，可能导致加密数据的安全性受到威胁。</p>
<h3 id="2-选择合适的模式和填充方案"><a href="#2-选择合适的模式和填充方案" class="headerlink" title="2. 选择合适的模式和填充方案"></a>2. <strong>选择合适的模式和填充方案</strong></h3><p>根据应用场景选择合适的加密模式。如果需要数据完整性和认证，推荐使用 <strong>GCM</strong> 或 <strong>CCM</strong> 模式。如果只需要加密而不涉及认证，<strong>CBC</strong> 是一个常用的选择。</p>
<h3 id="3-正确管理初始化向量-IV"><a href="#3-正确管理初始化向量-IV" class="headerlink" title="3. 正确管理初始化向量 (IV)"></a>3. <strong>正确管理初始化向量 (IV)</strong></h3><p>无论使用哪种加密模式，都必须正确管理 IV。IV 应该是随机生成的，并且每次加密操作都应使用不同的 IV。对于 <strong>GCM</strong> 和 <strong>CCM</strong> 模式，IV 也被称为 nonce，必须保证唯一性。</p>
<h3 id="4-使用安全的填充方案"><a href="#4-使用安全的填充方案" class="headerlink" title="4. 使用安全的填充方案"></a>4. <strong>使用安全的填充方案</strong></h3><p>选择安全的填充方案，如 <strong>PKCS7</strong>，以确保加密数据的块大小满足算法的要求。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a class="link"   href="https://csrc.nist.gov/publications/detail/sp/800-38a/rev-1/final" >NIST Cryptographic Algorithm Modes<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://owasp.org/www-community/vulnerabilities/Encryption_Weakness" >OWASP: Encryption Cheat Sheet<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Cipher" >Java Cryptography Architecture (JCA) Reference Guide<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://cryptography.io/en/latest/" >Python Cryptography Documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>SonarLint 的 <code>Use a secure cipher mode</code> 警告是为了确保你在加密操作中选择了安全的加密模式。通过选择如 <strong>CBC</strong>、<strong>GCM</strong> 和 <strong>CCM</strong> 这样的安全模式，你可以提升加密的安全性，确保数据的机密性和完整性。同时，正确地选择填充方案和管理初始化向量也是实现安全加密的重要步骤。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
        <category>SonarLint</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SonarLint</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean 注入方式</title>
    <url>/2025/12/22/Spring-Bean-%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>Spring 容器把“对象”变成“Bean”再塞进你类里，总共只有 <strong>4 条官方通道</strong> + <strong>1 个边角料</strong>。<br>记住口诀：<br>“构造必备，Setter 补，字段图快，注解玩花，接口冷门。”</p>
<hr>
<ol>
<li>构造器注入（Constructor Injection）<br>Spring 官方从 4.x 起喊“首选”，强依赖不可空，一次把对象构造到合法状态。  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;   <span class="comment">// final 更安心</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(UserService userService)</span> &#123; <span class="comment">// 一个构造器可省 @Autowired</span></span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
多构造器时用 <code>@Autowired</code> 指明哪个被 Spring 调用。</li>
</ol>
<hr>
<ol start="2">
<li>Setter &#x2F; 方法注入（Setter Injection）<br>可选依赖、运行期可能重新设值、方便单元测试 mock。  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<hr>
<ol start="3">
<li>字段注入（Field Injection）<br>写起来最爽，直接在属性上贴注解，代码少。  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
缺点：  <ul>
<li>无法把字段设为 <code>final</code>  </li>
<li>单元测试必须用反射或 Spring 测试容器  </li>
<li>隐藏依赖，阅读时要跳来跳去<br>⇒ Spring 官方文档不推荐，但项目里最常见。</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li>注解“玩法”分支（本质还是上面三种，只是换标签）  <ul>
<li><code>@Autowired</code>：按类型注入，required&#x3D;false 可空  </li>
<li><code>@Resource(name=&quot;xxx&quot;)</code>：JSR-250，按名字先走，再走类型  </li>
<li><code>@Inject</code>：JSR-330（javax.inject），功能≈<code>@Autowired</code>，只是完全标准注解<br>三者可以混用，但一个项目最好统一风格。</li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li>接口回调注入（冷门）<br>实现 <code>BeanFactoryAware</code>、<code>ApplicationContextAware</code>、<code>EnvironmentAware</code> 等 <code>*Aware</code> 接口，Spring 启动后会主动把容器本身回调给你。  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolBox</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext ctx;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext ac)</span> &#123; ctx = ac; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
属于“我要容器本身”而不是“要另一个 Bean”，日常业务代码基本用不到。</li>
</ol>
<hr>
<p>速查表  </p>
<table>
<thead>
<tr>
<th>方式</th>
<th>是否推荐</th>
<th>依赖可否空</th>
<th>单元测试便利</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>构造器</td>
<td>★★★★★</td>
<td>否</td>
<td>好</td>
<td>官方首选，支持 <code>final</code></td>
</tr>
<tr>
<td>Setter</td>
<td>★★★☆☆</td>
<td>可</td>
<td>中</td>
<td>可选依赖场景</td>
</tr>
<tr>
<td>字段</td>
<td>★★☆☆☆</td>
<td>可</td>
<td>差</td>
<td>写起来快，维护哭</td>
</tr>
<tr>
<td>@Inject 等</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>只是注解换皮，归到前三类</td>
</tr>
<tr>
<td>*Aware 接口</td>
<td>★☆☆☆☆</td>
<td>—</td>
<td>—</td>
<td>拿容器工具，非常规业务注入</td>
</tr>
</tbody></table>
<p>一句话结论<br><strong>“强依赖用构造器，可选依赖用 Setter，字段注入能不用就不用；Aware 接口只在你需要 Spring 容器本身时才碰。”</strong></p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring @Around - Join Point Return Value Will Be Lost</title>
    <url>/2024/07/19/Spring-Around-Join-Point-Return-Value-Will-Be-Lost/</url>
    <content><![CDATA[<p>在使用 Spring AOP 进行面向切面编程时，可能会遇到 <strong>“Join point return value will be lost”</strong> 这个问题。这个问题通常是由于切面（Aspect）方法中的 <code>@Around</code> 通知没有正确处理目标方法的返回值造成的。以下是对这个问题的详细解析、解决方案和最佳实践。</p>
<h2 id="1-什么是“Join-Point-Return-Value-Will-Be-Lost”？"><a href="#1-什么是“Join-Point-Return-Value-Will-Be-Lost”？" class="headerlink" title="1. 什么是“Join Point Return Value Will Be Lost”？"></a>1. <strong>什么是“Join Point Return Value Will Be Lost”？</strong></h2><p>在 Spring AOP 中，<strong>Join Point</strong> 是指程序执行的某个点，例如方法调用时。<code>@Around</code> 通知可以在方法执行的前后进行操作，通常会涉及到目标方法的返回值。<strong>“Join point return value will be lost”</strong> 的意思是，在 <code>@Around</code> 通知中，如果没有正确处理目标方法的返回值，可能会导致这个返回值丢失，从而影响程序的正确性和功能。</p>
<h2 id="2-如何产生“Join-Point-Return-Value-Will-Be-Lost”问题"><a href="#2-如何产生“Join-Point-Return-Value-Will-Be-Lost”问题" class="headerlink" title="2. 如何产生“Join Point Return Value Will Be Lost”问题"></a>2. <strong>如何产生“Join Point Return Value Will Be Lost”问题</strong></h2><p>这个问题主要出现在 <code>@Around</code> 通知方法中，当我们没有正确地从 <code>ProceedingJoinPoint</code> 中获取目标方法的返回值时，就会导致这个问题。</p>
<h3 id="示例代码演示问题"><a href="#示例代码演示问题" class="headerlink" title="示例代码演示问题"></a>示例代码演示问题</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 这里没有处理目标方法的返回值</span></span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的代码中，<code>aroundAdvice</code> 方法调用了 <code>joinPoint.proceed()</code> 来执行目标方法，但没有处理目标方法的返回值。这就会导致目标方法的返回值丢失，可能会影响调用该方法的地方的结果。</p>
<h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. <strong>解决方案</strong></h2><p>为了解决 <strong>“Join Point Return Value Will Be Lost”</strong> 问题，你需要在 <code>@Around</code> 通知中正确地处理目标方法的返回值。你应该使用 <code>joinPoint.proceed()</code> 的返回值并在需要时进行处理或修改。</p>
<h3 id="正确的-Around-通知实现"><a href="#正确的-Around-通知实现" class="headerlink" title="正确的 @Around 通知实现"></a>正确的 <code>@Around</code> 通知实现</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 记录方法调用前的信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Method &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; is called with arguments &quot;</span> + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行目标方法并获取返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录方法调用后的信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Method &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; returned &quot;</span> + result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以对返回值进行修改</span></span><br><span class="line">        <span class="comment">// result = modifyResult(result);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 将返回值返回给调用者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个正确的实现中，我们：</p>
<ul>
<li>**调用 <code>joinPoint.proceed()</code> 并将返回值赋给 <code>result</code>**。</li>
<li><strong>记录目标方法的返回值信息</strong>。</li>
<li><strong>返回目标方法的结果</strong>，确保返回值不会丢失。</li>
</ul>
<h3 id="如果需要对返回值进行修改"><a href="#如果需要对返回值进行修改" class="headerlink" title="如果需要对返回值进行修改"></a>如果需要对返回值进行修改</h3><p>如果你需要在通知中对目标方法的返回值进行修改，你可以在 <code>return result;</code> 之前进行处理。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 记录方法调用前的信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Method &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; is called with arguments &quot;</span> + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行目标方法并获取返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对返回值进行修改</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            result = ((String) result).toUpperCase();  <span class="comment">// 示例：将返回值转换为大写</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录方法调用后的信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Method &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; returned &quot;</span> + result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回修改后的结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. <strong>最佳实践</strong></h2><h3 id="4-1-确保通知方法有正确的返回类型"><a href="#4-1-确保通知方法有正确的返回类型" class="headerlink" title="4.1 确保通知方法有正确的返回类型"></a>4.1 确保通知方法有正确的返回类型</h3><p><code>@Around</code> 通知必须有一个返回值类型为 <code>Object</code> 的方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 代码逻辑</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-2-始终调用-joinPoint-proceed"><a href="#4-2-始终调用-joinPoint-proceed" class="headerlink" title="4.2 始终调用 joinPoint.proceed()"></a>4.2 始终调用 <code>joinPoint.proceed()</code></h3><p>在 <code>@Around</code> 通知中，<strong>必须调用 <code>joinPoint.proceed()</code></strong> 来执行目标方法。如果你不调用 <code>proceed</code>，目标方法不会被执行，这会导致意外的行为。</p>
<h3 id="4-3-处理异常"><a href="#4-3-处理异常" class="headerlink" title="4.3 处理异常"></a>4.3 处理异常</h3><p>在 <code>@Around</code> 通知中处理目标方法的异常，可以进行日志记录、重试机制等：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 记录异常信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Method &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; threw an exception &quot;</span> + e);</span><br><span class="line">        <span class="keyword">throw</span> e;  <span class="comment">// 重新抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-4-适当使用切点表达式"><a href="#4-4-适当使用切点表达式" class="headerlink" title="4.4 适当使用切点表达式"></a>4.4 适当使用切点表达式</h3><p>使用合适的切点表达式来限制 <code>@Around</code> 通知的范围，避免不必要的性能开销：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-5-清晰的日志记录"><a href="#4-5-清晰的日志记录" class="headerlink" title="4.5 清晰的日志记录"></a>4.5 清晰的日志记录</h3><p>记录足够的日志信息可以帮助你了解方法调用的状态和结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Method &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; is called with arguments &quot;</span> + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">System.out.println(<span class="string">&quot;Method &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; returned &quot;</span> + result);</span><br></pre></td></tr></table></figure></div>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><p><strong>“Join point return value will be lost”</strong> 是一个常见的问题，通常是由于在 <code>@Around</code> 通知中没有正确处理目标方法的返回值。通过确保在 <code>@Around</code> 通知中正确地处理和返回目标方法的返回值，我们可以解决这个问题。</p>
<h3 id="关键点总结："><a href="#关键点总结：" class="headerlink" title="关键点总结："></a>关键点总结：</h3><ul>
<li><strong><code>@Around</code> 通知必须有一个返回值类型为 <code>Object</code> 的方法</strong>。</li>
<li><strong>必须调用 <code>joinPoint.proceed()</code></strong> 执行目标方法。</li>
<li><strong>处理目标方法的返回值和可能的异常</strong>。</li>
<li><strong>在通知中进行适当的日志记录</strong> 和 <strong>修改返回值</strong>。</li>
</ul>
<p>遵循以上最佳实践，能够帮助你更好地处理 AOP 相关的问题，并提升你的编程技巧和项目质量。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a class="link"   href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop" >Spring AOP Documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.baeldung.com/spring-aop-around-advice" >Spring AOP @Around Annotation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997" >Effective Java<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> - Joshua Bloch</li>
<li><a class="link"   href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#aop" >Spring Framework Reference Documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>在 Spring AOP 的 <code>@Around</code> 通知中，如果你不需要执行目标方法的代码（即你希望跳过目标方法的实际执行），可以选择返回一个自定义的结果或者是一个默认的结果。这种情况通常发生在你想对方法进行拦截但不执行它的原始逻辑时。</p>
<h3 id="1-不执行目标方法时的返回值选择"><a href="#1-不执行目标方法时的返回值选择" class="headerlink" title="1. 不执行目标方法时的返回值选择"></a>1. <strong>不执行目标方法时的返回值选择</strong></h3><p>如果你决定在 <code>@Around</code> 通知中不执行目标方法，你需要明确地返回一个适当的值。以下是一些常见的选择和示例代码：</p>
<h4 id="1-1-返回固定的结果"><a href="#1-1-返回固定的结果" class="headerlink" title="1.1 返回固定的结果"></a>1.1 <strong>返回固定的结果</strong></h4><p>如果你不需要执行目标方法，可以返回一个固定的结果。这是最简单的方式，但适用于你有一个明确的结果需要返回的场景。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 自定义返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fixed Result&quot;</span>;  <span class="comment">// 例如，返回一个固定的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-2-返回-null"><a href="#1-2-返回-null" class="headerlink" title="1.2 返回 null"></a>1.2 <strong>返回 <code>null</code></strong></h4><p>如果目标方法的返回类型允许 <code>null</code> 值，并且你希望不执行目标方法，可以选择返回 <code>null</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 选择不执行目标方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-3-返回默认值"><a href="#1-3-返回默认值" class="headerlink" title="1.3 返回默认值"></a>1.3 <strong>返回默认值</strong></h4><p>你可以根据目标方法的返回类型来返回合适的默认值。例如，对于 <code>int</code> 类型可以返回 <code>0</code>，对于 <code>boolean</code> 类型可以返回 <code>false</code>，对于 <code>List</code> 类型可以返回一个空的 <code>List</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 根据目标方法的返回类型选择适当的默认值</span></span><br><span class="line">        <span class="keyword">if</span> (joinPoint.getSignature().getReturnType() == String.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Default String&quot;</span>;  <span class="comment">// 对于 String 类型，返回一个默认的字符串</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (joinPoint.getSignature().getReturnType() == <span class="type">int</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 对于 int 类型，返回默认值 0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (joinPoint.getSignature().getReturnType() == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 对于 boolean 类型，返回默认值 false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (joinPoint.getSignature().getReturnType() == List.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();  <span class="comment">// 对于 List 类型，返回一个空的 List</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他类型处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 默认返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-如何决定返回什么值"><a href="#2-如何决定返回什么值" class="headerlink" title="2. 如何决定返回什么值"></a>2. <strong>如何决定返回什么值</strong></h3><p>决定在不执行目标方法时应该返回什么值，通常取决于以下几个因素：</p>
<h4 id="2-1-目标方法的返回类型"><a href="#2-1-目标方法的返回类型" class="headerlink" title="2.1 目标方法的返回类型"></a>2.1 <strong>目标方法的返回类型</strong></h4><ul>
<li><strong><code>void</code> 类型</strong>：如果目标方法没有返回值，可以不返回任何值，直接进行逻辑处理。</li>
<li><strong>非 <code>void</code> 类型</strong>：必须返回一个与目标方法返回类型相匹配的值。</li>
</ul>
<h4 id="2-2-业务需求"><a href="#2-2-业务需求" class="headerlink" title="2.2 业务需求"></a>2.2 <strong>业务需求</strong></h4><ul>
<li><strong>业务逻辑</strong>：根据业务需求决定返回什么结果。例如，是否需要替代目标方法的功能、是否需要返回错误信息等。</li>
<li><strong>默认行为</strong>：如果你需要实现某种默认行为，比如返回固定的值或默认值来模拟目标方法的行为。</li>
</ul>
<h4 id="2-3-测试目的"><a href="#2-3-测试目的" class="headerlink" title="2.3 测试目的"></a>2.3 <strong>测试目的</strong></h4><ul>
<li><strong>测试目的</strong>：在测试中，可能会通过 AOP 切面来跳过目标方法的实际执行，并返回一些固定的值以验证其他逻辑。</li>
</ul>
<h3 id="3-示例：不同类型的返回值处理"><a href="#3-示例：不同类型的返回值处理" class="headerlink" title="3. 示例：不同类型的返回值处理"></a>3. <strong>示例：不同类型的返回值处理</strong></h3><p>以下是一些常见的示例代码，展示了如何根据目标方法的返回类型返回不同的结果。</p>
<h4 id="3-1-处理-void-返回类型"><a href="#3-1-处理-void-返回类型" class="headerlink" title="3.1 处理 void 返回类型"></a>3.1 <strong>处理 <code>void</code> 返回类型</strong></h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 对于 void 类型的方法，不需要返回值</span></span><br><span class="line">        <span class="comment">// 例如，执行前的处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before execution&quot;</span>);</span><br><span class="line">        <span class="comment">// 跳过目标方法的执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-2-处理-String-返回类型"><a href="#3-2-处理-String-返回类型" class="headerlink" title="3.2 处理 String 返回类型"></a>3.2 <strong>处理 <code>String</code> 返回类型</strong></h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 对于 String 类型的方法，返回一个固定的字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Intercepted Result&quot;</span>;  <span class="comment">// 返回自定义的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-3-处理-int-返回类型"><a href="#3-3-处理-int-返回类型" class="headerlink" title="3.3 处理 int 返回类型"></a>3.3 <strong>处理 <code>int</code> 返回类型</strong></h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 对于 int 类型的方法，返回 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回 int 类型的默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-4-处理-boolean-返回类型"><a href="#3-4-处理-boolean-返回类型" class="headerlink" title="3.4 处理 boolean 返回类型"></a>3.4 <strong>处理 <code>boolean</code> 返回类型</strong></h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 对于 boolean 类型的方法，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 返回 boolean 类型的默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-处理复杂对象"><a href="#4-处理复杂对象" class="headerlink" title="4. 处理复杂对象"></a>4. <strong>处理复杂对象</strong></h3><p>对于复杂对象，你可以返回一个模拟对象，或者是一个简单的实现。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 对于复杂对象，返回一个简单的模拟对象</span></span><br><span class="line">        <span class="keyword">if</span> (joinPoint.getSignature().getReturnType() == MyComplexObject.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyComplexObject</span>();  <span class="comment">// 返回一个简单的对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 默认返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="5-推荐的处理方法"><a href="#5-推荐的处理方法" class="headerlink" title="5. 推荐的处理方法"></a>5. <strong>推荐的处理方法</strong></h3><p>在实际项目中，推荐的处理方法通常是根据目标方法的返回类型选择合适的默认值或模拟结果，以确保你的 AOP 逻辑符合业务需求并保持代码的健壮性和可维护性。</p>
<h3 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. <strong>参考文献</strong></h3><ul>
<li><a class="link"   href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-advice" >Spring AOP - Around Advice<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.baeldung.com/spring-aop-tutorial" >Spring AOP Examples<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.baeldung.com/spring-aop-best-practices" >Spring AOP Best Practices<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997" >Effective Java<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> - Joshua Bloch</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway 4种接口放行方式</title>
    <url>/2024/07/08/Spring-Cloud-Gateway-4%E7%A7%8D%E6%8E%A5%E5%8F%A3%E6%94%BE%E8%A1%8C%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="4种接口过滤方式"><a href="#4种接口过滤方式" class="headerlink" title="4种接口过滤方式"></a>4种接口过滤方式</h2><h3 id="使用Spring-Cloud-Gateway的路由规则，在application-yml文件中定义predicates和filters"><a href="#使用Spring-Cloud-Gateway的路由规则，在application-yml文件中定义predicates和filters" class="headerlink" title="使用Spring Cloud Gateway的路由规则，在application.yml文件中定义predicates和filters"></a>使用Spring Cloud Gateway的路由规则，在application.yml文件中定义predicates和filters</h3><div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/login</span> <span class="comment"># 只放行/user/login接口</span></span><br></pre></td></tr></table></figure></div>

<h3 id="使用Spring-Security的配置，在application-yml文件中定义ignoreUrls"><a href="#使用Spring-Security的配置，在application-yml文件中定义ignoreUrls" class="headerlink" title="使用Spring Security的配置，在application.yml文件中定义ignoreUrls"></a>使用Spring Security的配置，在application.yml文件中定义ignoreUrls</h3><div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">ignoreUrls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/user/login</span> <span class="comment"># 放行/user/login接口</span></span><br></pre></td></tr></table></figure></div>

<h3 id="使用自定义过滤器，在GatewayFilterFactory中实现自己的逻辑"><a href="#使用自定义过滤器，在GatewayFilterFactory中实现自己的逻辑" class="headerlink" title="使用自定义过滤器，在GatewayFilterFactory中实现自己的逻辑"></a>使用自定义过滤器，在GatewayFilterFactory中实现自己的逻辑</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;AuthGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> exchange.getRequest().getURI().getPath();</span><br><span class="line">            <span class="keyword">if</span> (path.equals(<span class="string">&quot;/user/login&quot;</span>)) &#123; <span class="comment">// 放行/user/login接口</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他逻辑...</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="comment">// 配置属性...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用自定义路由仓库，在RouteDefinitionRepository中实现自己的逻辑"><a href="#使用自定义路由仓库，在RouteDefinitionRepository中实现自己的逻辑" class="headerlink" title="使用自定义路由仓库，在RouteDefinitionRepository中实现自己的逻辑"></a>使用自定义路由仓库，在RouteDefinitionRepository中实现自己的逻辑</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisRouteDefinitionRepository</span> <span class="keyword">implements</span> <span class="title class_">RouteDefinitionRepository</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;RouteDefinition&gt; <span class="title function_">getRouteDefinitions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从Redis中获取路由定义，并根据需要放行接口...</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">save</span><span class="params">(Mono&lt;RouteDefinition&gt; route)</span> &#123;</span><br><span class="line">        <span class="comment">// 保存路由定义到Redis中...</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">delete</span><span class="params">(Mono&lt;String&gt; routeId)</span> &#123;</span><br><span class="line">        <span class="comment">// 从Redis中删除路由定义...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="四种方式的优缺点"><a href="#四种方式的优缺点" class="headerlink" title="四种方式的优缺点"></a>四种方式的优缺点</h2><ul>
<li>使用Spring Cloud Gateway的路由规则，优点是简单方便，可以在配置文件中定义多种路由条件和过滤器，支持动态刷新和自定义扩展；缺点是可能不够灵活，需要遵循Spring Cloud Gateway的规范和约束。</li>
<li>使用Spring Security的配置，优点是可以利用Spring Security提供的强大的安全功能，如认证、授权、加密等；缺点是需要额外引入Spring Security依赖，并且可能与其他过滤器冲突或重复。</li>
<li>使用自定义过滤器，优点是可以实现自己的业务逻辑和需求，有更高的灵活性和可定制性；缺点是需要编写更多的代码，并且可能需要考虑性能、异常处理、兼容性等问题。</li>
<li>使用自定义路由仓库，优点是可以实现自己的路由存储和管理方式，如使用Redis或数据库等；缺点是需要编写更多的代码，并且可能需要考虑数据同步、缓存、事务等问题。</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 文件上传大小设置</title>
    <url>/2024/07/06/Spring-Boot-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">20MB</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">200MB</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring  Boot  Cloud 前世今生</title>
    <url>/2024/07/17/Spring-Boot-Cloud-%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
    <content><![CDATA[<p>2004年3月24日，Spring官网发布了Spring Framework的1.0版本，在一定程度上颠覆了Java开发的模式。Spring Framework提供的控制反转和依赖注入，这两个概念的提出也是受到了JNDI和EJB的容器注入的影响。换句话说，Spring Framework其实也是在J2EE的基础上又建了一个轮子而已。从当时的分层来看，Struts为web表示层、Hibernate为持久层，而Spring Framework就是把大家伙整合到一起的那么个作用。此时的Spring Framework还有一个致命的问题，Spring Framework需要随着Java容器的启动而装载。<br>那么在Spring Framework4.0发布的时候，Spring还同时发布了Spring Boot。官方是这么定义Spring Boot的。</p>
<blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p>
<p>We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration.</p>
</blockquote>
<p>Spring Boot使构建独立的Spring生产级别的项目变得简单，同时提供了固化视图来固化Spring Boot所依赖的Spring平台库和第三方类库，从而减少管理类库的烦恼。大多数Spring Boot项目只需要少量的Spring配置。</p>
<ol>
<li>Create stand-alone Spring applications</li>
<li>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</li>
<li>Provide opinionated ‘starter’ dependencies to simplify your build configuration</li>
<li>Automatically configure Spring and 3rd party libraries whenever possible</li>
<li>Provide production-ready features such as metrics, health checks, and externalized configuration</li>
<li>Absolutely no code generation and no requirement for XML configuration</li>
</ol>
<p>官网中也同时给出了Spring Boot的特性，分别是：</p>
<ol>
<li>创建独立的Spring应用, 使用 Spring 项目引导页面可以在几秒构建一个项目</li>
<li>支持运行期内嵌容器, 直接嵌入Tomcat、Jetty或Undertow（不需要部署WAR文件）；</li>
<li>提供固化的“Starter”依赖，简化构建的配置步骤；</li>
<li>自动装配Spring或第三方类库；</li>
<li>提供运维特性，比如指标信息、健康检查和配置外部化, 自动管理依赖, 自带应用监控</li>
<li>绝无代码生成，而且不需要配置XML文件, 非常简洁的策略集成</li>
</ol>
<p>从官网的说明中，我们不难看出，Spring Boot的优点：</p>
<blockquote>
<p>使编码变的简单</p>
<p>使配置变的简单</p>
<p>使部署变的简单</p>
<p>使监控变的简单</p>
</blockquote>
<h2 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h2><h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><p>时间回到2002年，当时正是 Java EE 和 EJB 大行其道的时候，很多知名公司都是采用此技术方案进行项目开发。 EJB 太过臃肿，并不是所有的项目都需要使用 EJB 这种大型框架，应该会有一种更好的方案来解决这个问题。</p>
<p>做Spring项目开发时，程序员要知道配置哪些类来让Hibernate和Spring一起工作，还要知道如何配置view resolver来控制哪个模版进行视图层的展示。写了一大堆代码其实只是在处理Spring框架本身的配置，此时一行业务逻辑都没有写。开发完成之后，还要考虑部署的问题，比如如何配置容器，如何修改配置文件等等。而且在多应用部署到同一个Tomcat的时候，经常会出现冲突。就算花了很大力气解决了这些问题，程序部署成功之后，也很难去了解这个程序的运行状态。那么还要配置第三方工具来了解应用程序运行状态，参数，环境变量。</p>
<p>尽管Spring帮我们解决了依赖注入的问题，简化了MVC的流程，但是Spring框架本身集成了越来越多东西，导致其越来越难配置，维护成本成直线上升。</p>
<h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>Spring Boot使用“约定优于配置”的理念让项目快速运行起来。简单描述就是项目中存在大量的配置，此外还内置一个习惯性的配置，让我们无须手动进行配置。使用Spring Boot 很容易创建一个独立运行、准生产级别的Spring项目，而且我们几乎不用怎么进行配置。</p>
<p>当然 Spring Boot 不是为了取代 Spring ,Spring Boot 基于 Spring 开发，是为了让人们更容易的使用 Spring。看到 Spring Boot 的市场反应，Spring 官方也非常重视 Spring Boot 的后续发展，已经将 Spring Boot 作为公司最顶级的项目来推广，放到了官网上第一的位置，因此后续 Spring Boot 的持续发展也被看好。</p>
<h2 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h2><p>约定优于配置（Convention Over Configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量、获得简单的好处，而又不失灵活性。</p>
<p>本质上说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为 User 的类，那么数据库中对应的表就会默认命名为 user。只有在偏离这一约定时，例如将该表命名为“legal_user”，才需写有关这个名字的配置。</p>
<p>我们可以按照这个思路来设想，我们约定 Controller 层就是 Web 请求层可以省略 MVC 的配置；我们约定在 Service 结尾的类自动注入事务，就可以省略了 Spring 的切面事务配置。</p>
<p>在 Spring 体系中，Spring Boot JPA 就是约定优于配置最佳实现之一，不需要关注表结构，我们约定类名即是表名，属性名即是表的字段，String 对应 varchar，long 对应 bigint，只有需要一些特殊要求的属性，我们再单独进行配置，按照这个约定我们可以将以前的工作大大简化。<br>Spring Boot 体系将约定优于配置的思想展现得淋漓尽致，小到配置文件、中间件的默认配置，大到内置容器、生态中的各种 Starters 无不遵循此设计规则。Spring Boot 鼓励各软件组织方创建自己的 Starter，创建 Starter 的核心组件之一就是 autoconfigure 模块，也是 Starter 的核心功能，在启动的时候进行自动装配，属性默认化配置。</p>
<p>可以说正是因为 Spring Boot 简化了配置和众多的 Starters 才让 Spring Boot 变得简单、易用、快速上手。Spring Boot 约定优于配置的思想让 Spring Boot 项目非常容易上手。</p>
<h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h3><ol>
<li>项目结构约定<ul>
<li><code>src.main.java</code> 存放源代码文件</li>
<li><code>src.main.resource</code> 存放资源文件</li>
<li><code>src.test.java</code> 测试代码</li>
<li><code>src.test.resource</code> 测试资源文件</li>
<li><code>target</code> 编译后的 class 文件和 jar 文件</li>
</ul>
</li>
<li>内置了嵌入式的 Web 容器, 支持四种嵌入式的 Web 容器<ul>
<li>Tomcat</li>
<li>Jetty</li>
<li>Undertow</li>
<li>Reactor</li>
</ul>
</li>
<li>自动装配<ul>
<li>自动装配的核心是 <code>@EnableAutoConfiguration</code> 注解，它会自动扫描和导入符合条件的依赖</li>
<li>自动装配的核心是 <code>@ComponentScan</code> 注解，它会扫描和导入符合条件的组件</li>
</ul>
</li>
<li>默认提供了两种配置文件<ul>
<li><code>application.properties</code> 项目的默认配置文件</li>
<li><code>application.yml</code> 项目的默认配置文件</li>
</ul>
</li>
<li>内置了多种 Starter<ul>
<li>Spring Boot 项目中默认包含了大量的 Starter，我们可以直接使用这些 Starter 来简化 Spring Boot 的配置</li>
</ul>
</li>
</ol>
<h2 id="Spring-Boot-都市传说"><a href="#Spring-Boot-都市传说" class="headerlink" title="Spring Boot 都市传说"></a>Spring Boot 都市传说</h2><h3 id="一切一切的起点"><a href="#一切一切的起点" class="headerlink" title="一切一切的起点"></a>一切一切的起点</h3><p>说起 Spring Boot 我们不得不先了解一下 Spring 这个企业，不仅因为 Spring Boot 来源于 Spirng 大家族，而且 Spring Boot 的诞生和 Sping 框架的发展息息相关。</p>
<p>2002 年 10 月，Rod Johnson 撰写了一本名为 Expert One-on-One J2EE 设计和开发的书。本书当时由 Wrox出版社出版，介绍了当时 Java 企业应用程序开发的情况，并指出了 Java EE 和 EJB 组件框架中的存在的一些主要缺陷。在这本书中，他提出了一个基于普通 Java 类和依赖注入的更简单的解决方案。（这里就对应了我们开篇讲到的，依赖注入并不是Spring发明的，而是在J2EE原来的基础上做了优化改进）</p>
<p>在书中，他展示了如何在不使用 EJB 的情况下构建高质量，可扩展的在线座位预留系统。为了构建应用程序，他编写了超过 30,000 行的基础结构代码。包含许多可重用的 Java 接口和类，如 <code>ApplicationContext和BeanFactory</code> 。由于java接口是依赖注入的基本构建块，因此他将这些类的根包命名为<code>com.interface21</code>。所以人们最初称这套开源框架为 interface21，也就是 Spring 的前身。</p>
<p>Rod Johnson 在悉尼大学不仅获得了计算机学位，同时还获得了音乐学位，更令人吃惊的是在回到软件开发领域之前，他还获得了音乐学的博士学位。现在 Rod Johnson 已经离开了 Spring ，成为了一个天使投资人，同时也是多个公司的董事，早已走上人生巅峰。</p>
<h3 id="Spring-诞生"><a href="#Spring-诞生" class="headerlink" title="Spring 诞生"></a>Spring 诞生</h3><p>在本书发布后不久，开发者 Juergen Hoeller 和 Yann Caroff 说服 Rod Johnson 创建一个基于基础结构代码的开源项目。Rod，Juergen 和 Yann 于 2003 年 2 月左右开始合作开发该项目 。Yann 为新框架创造了“Spring”的名字。</p>
<p>2004 年 3 月，1.0 版发布。有趣的是，在1.0发布之前，spring 就被开发人员广泛采用。2004 年 8 月，Rod Johnson，Juergen Hoeller，Keith Donald 和Colin Sampaleanu 共同创立了一家专注于 Spring 咨询，培训和支持的公司： interface21。</p>
<p>Yann Caroff 在很早离开了团队，Rod Johnson 在 2012 年离开，Juergen Hoeller 目前仍然还在团队中进行开发工作。自 2004 年 1.0 版本发布以来，Spring 框架迅速发展。Spring 2.0 于 2006 年 10 月发布，Spring的下载量超过了 100 万。Spring 2.0 具有可扩展的 XML 配置功能，用于简化 XML 配置，支持 Java 5，额外的 IoC 容器扩展点，支持动态语言。</p>
<p>在 Rod 领导下管理 Interface21 项目于 2007 年 11 月更名为 SpringSource。同时发布了 Spring 2.5。Spring 2.5 中的主要新功能包括支持 Java 6 &#x2F; Java EE 5，支持注释配置，classpath 中的组件自动检测和兼容 OSGi 的 bundle。</p>
<p>2007 年，SpringSource 从基准资本获得了 A 轮融资（1000万美元）。SpringSource 在此期间收购了多家公司，如Hyperic，G2One 等。2009年8月，SpringSource 以 4.2 亿美元被 VMWare 收购。SpringSource 在几周内收购了云代工厂，这是一家云 PaaS 提供商。2015 年，云代工厂转型成了非营利云代工厂。</p>
<p>2009 年 12 月，Spring 3.0 发布。Spring 3.0 具有许多重要特性，如重组模块系统，支持 Spring 表达式语言，基于 Java 的 bean 配置（JavaConfig），支持嵌入式数据库（如 HSQL，H2 和 Derby），模型验证&#x2F; REST 支持和对 Java EE 的支持。</p>
<p>2011 年和 2012 年发布了许多 3.x 系列的小版本。2012 年 7 月，Rod Johnson 离开了团队。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/spring/20240717130324.png"
                     
                ></p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">mermaid</span><br><span class="line">timeline</span><br><span class="line"><span class="code">    title Spring TL</span></span><br><span class="line"><span class="code">    2002 : 2002 年 10 月 : Rod Johnson 撰写《Expert One-on-One J2EE》一书，介绍了 Spring 框架的早期思想</span></span><br><span class="line"><span class="code">    2003 : 2003 年 2 月 : Juergen Hoeller 和 Yann Caroff 说服 Rod Johnson 创建一个基于基础结构代码的开源项目 : Yann 为新框架创造了“Spring”的名字</span></span><br><span class="line"><span class="code">    2004 : 2004 年 3 月 : Spring 1.0 版发布</span></span><br><span class="line"><span class="code">    2004 : 2004 年 8 月 : Rod Johnson、Juergen Hoeller、Keith Donald 和 Colin Sampaleanu 共同创立了一家专注于 Spring 咨询、培训和支持的公司 `interface21`</span></span><br><span class="line"><span class="code">    2006 : 2006 年 10 月 : Spring 2.0 发布</span></span><br><span class="line"><span class="code">    2007 : 2007 年 11 月 : Interface21 项目更名为 SpringSource</span></span><br><span class="line"><span class="code">    2009 : 2009 年 12 月 : Spring 3.0 发布</span></span><br><span class="line"><span class="code">    2011 : 2011 年 : 发布了许多 3.x 系列的小版本</span></span><br><span class="line"><span class="code">    2012 : 2012 年 7 月 : Rod Johnson 离开了团队</span></span><br><span class="line"><span class="code">    2014 : 2014 年 12 月 : Pivotal 宣布发布 Spring 4.0</span></span><br><span class="line"><span class="code">    2017 : 2017 年 09 月 : Spring 5.0 发布</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Spring-Boot诞生"><a href="#Spring-Boot诞生" class="headerlink" title="Spring Boot诞生"></a>Spring Boot诞生</h3><p>2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求 ， 要求在 Spring 框架中支持无容器 Web 应用程序体系结构。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。（画重点，Spring Boot 的苗头发生了）</p>
<p>2013 年 4月，VMware 和 EMC 通过 GE 投资创建了一家名为 Pivotal 的合资企业。所有的 Spring 应用项目都转移到了 Pivotal。</p>
<p>2013 年 12 月，Pivotal 宣布发布 Spring 框架 4.0。Spring 4.0 是 Spring 框架的一大进步，它包含了对Java 8 的全面支持，更高的第三方库依赖性（groovy 1.8+，ehcache 2.1+，hibernate 3.6+等），Java EE 7 支持，groovy DSL for bean 定义，对 websockets 的支持以及对泛型类型的支持作为注入 bean 的限定符。</p>
<p>2014 年 4 月，Spring Boot 1.0.0 发布。改进的模板支持，gemfire 支持，Elastic Search 和 Apache Solr 的自动配置。</p>
<p>2015 年 3 月，Spring Boot 1.2 发布。升级到 servlet 3.1 &#x2F; tomcat 8 &#x2F; jetty 9，spring 4.1 升级，支持 banner &#x2F; jms &#x2F; SpringBootApplication 注解。</p>
<p>2016 年 12 月，Spring Boot 1.3发布新的 spring-boot-devtools，用于缓存技术（ehcache，hazelcast，redis 和 infinispan）的自动配置以及完全可执行的 jar 支持。于此同时，Spring 4.2 升级。</p>
<p>2017年1月，Spring Boot 1.4 支持 couchbase &#x2F; neo4j，分析启动失败和RestTemplateBuilder。于此同时Spring 4.3 升级。</p>
<p>2017年2月，Spring Boot 1.5 支持 kafka &#x2F; ldap，第三方库升级，弃用 CRaSH 支持和执行器记录器端点以动态修改应用程序日志级别。</p>
<p>2014 年至 2017 年期间发布了许多 Spring 框架 4.xx 系列版本。Spring 4.3.8 于 2017 年 4 月发布，并成为 4.x 系列中的最后一个。</p>
<p>2018 年 03 月，Spring Boot 2.0 基于 Java 8，支持 Java 9，支持 Quartz ，调度程序大大简化了安全自动配置，支持嵌入式 Netty。于此同时，Spring 5.0发布。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/spring/20240717130241.png"
                     
                ></p>
<div class="code-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">mermaid</span><br><span class="line">timeline</span><br><span class="line"><span class="code">    title Spring Boot TL</span></span><br><span class="line"><span class="code">    2012 : 2012 年 10 月 : Mike Youngstrom 在 Spring jira 中创建了一个功能请求 : Spring Boot 的苗头发生了</span></span><br><span class="line"><span class="code">    2013 : 2013 年 4月 : VMware 和 EMC 通过 GE 投资创建了一家名为 Pivotal 的合资企业。所有的 Spring 应用项目都转移到了 Pivotal</span></span><br><span class="line"><span class="code">    2013 : 2013 年 12 月 : Pivotal 宣布发布 Spring 框架 4.0</span></span><br><span class="line"><span class="code">    2014 : 2014 年 4 月 : Spring Boot 1.0.0 发布</span></span><br><span class="line"><span class="code">    2015 : 2015 年 3 月 : Spring Boot 1.2 发布</span></span><br><span class="line"><span class="code">    2016 : 2016 年 12 月 : Spring Boot 1.3 发布 : 同时 Spring 4.2 升级</span></span><br><span class="line"><span class="code">    2017 : 2017 年 1 月 : Spring Boot 1.4 支持 Couchbase / Neo4j</span></span><br><span class="line"><span class="code">    2017 : 2017 年 2 月 : Spring Boot 1.5 支持 Kafka / LDAP</span></span><br><span class="line"><span class="code">    2017 : 2017 年 4 月 : Spring 4.3.8 发布，并成为 4.x 系列中的最后一个</span></span><br><span class="line"><span class="code">    2018 : 2018 年 3 月 : Spring Boot 2.0 基于 Java 8，支持 Java 9，支持 Quartz : 同时 Spring 5.0 发布</span></span><br><span class="line"><span class="code">    2022 : 2022 年 11 月 : Spring Boot 3.0 支持 Java 17 : 升级到 Spring 6.0</span></span><br></pre></td></tr></table></figure></div>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.jianshu.com/p/c3e57bb974f4" >Spring Boot的前世今生<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway: An expected CSRF token cannot be found</title>
    <url>/2024/07/06/Spring-Cloud-Gateway-An-expected-CSRF-token-cannot-be-found/</url>
    <content><![CDATA[<blockquote>
<p>An expected CSRF token cannot be found</p>
</blockquote>
<p>因为mvc和gateway冲突，而配置了：<code>spring.main.web-application-type=reactive</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityWebFilterChain <span class="title function_">springSecurityFilterChain</span><span class="params">(ServerHttpSecurity http)</span> &#123;</span><br><span class="line">    http.csrf(ServerHttpSecurity.CsrfSpec::disable);</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC 控制反转</title>
    <url>/2024/06/21/Spring-IoC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="Spring-IoC-控制反转"><a href="#Spring-IoC-控制反转" class="headerlink" title="Spring IoC 控制反转"></a>Spring IoC 控制反转</h1><h2 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h2><blockquote>
<p>在传统的 Java 应用中，一个类想要调用另一个类中的属性或方法，通常会先在其代码中通过 new Object() 的方式将后者的对象创建出来，然后才能实现属性或方法的调用。为了方便理解和描述，我们可以将前者称为“调用者”，将后者称为“被调用者”。也就是说，调用者掌握着被调用者对象创建的控制权。</p>
</blockquote>
<p>但在 Spring 应用中，Java 对象创建的控制权是掌握在 IoC 容器手里的，其大致步骤如下。</p>
<ol>
<li>开发人员通过 XML 配置文件、注解、Java 配置类等方式，对 Java 对象进行定义，例如在 XML 配置文件中使用 <bean> 标签、在 Java 类上使用 @Component 注解等。</li>
<li>Spring 启动时，IoC 容器会自动根据对象定义，将这些对象创建并管理起来。这些被 IoC 容器创建并管理的对象被称为 Spring Bean。</li>
<li>当我们想要使用某个 Bean 时，可以直接从 IoC 容器中获取（例如通过 ApplicationContext 的 getBean() 方法），而不需要手动通过代码（例如 new Obejct() 的方式）创建。</li>
</ol>
<p>IoC 带来的最大改变不是代码层面的，而是从思想层面上发生了“主从换位”的改变。原本调用者是主动的一方，它想要使用什么资源就会主动出击，自己创建；但在 Spring 应用中，IoC 容器掌握着主动权，调用者则变成了被动的一方，被动的等待 IoC 容器创建它所需要的对象（Bean）。</p>
<p>这个过程在职责层面发生了控制权的反转，把原本调用者通过代码实现的对象的创建，反转给 IoC 容器来帮忙实现，因此我们将这个过程称为 Spring 的“控制反转”。</p>
<h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><p>在了解了 IoC 之后，我们还需要了解另外一个非常重要的概念：依赖注入。</p>
<p>依赖注入（Denpendency Injection，简写为 DI）是 Martin Fowler 在 2004 年在对“控制反转”进行解释时提出的。Martin Fowler 认为“控制反转”一词很晦涩，无法让人很直接的理解“到底是哪里反转了”，因此他建议使用“依赖注入”来代替“控制反转”。</p>
<p>在面向对象中，对象和对象之间是存在一种叫做“依赖”的关系。简单来说，依赖关系就是在一个对象中需要用到另外一个对象，即对象中存在一个属性，该属性是另外一个类的对象。</p>
<p>例如，有一个名为 B 的 Java 类，它的代码如下。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从代码可以看出，B 中存在一个 A 类型的对象属性 a，此时我们就可以说 B 的对象依赖于对象 a。而依赖注入就是就是基于这种“依赖关系”而产生的。</p>
<p>我们知道，控制反转核心思想就是由 Spring 负责对象的创建。在对象创建过程中，Spring 会自动根据依赖关系，将它依赖的对象注入到当前对象中，这就是所谓的“依赖注入”。</p>
<p>依赖注入本质上是 Spring Bean 属性注入的一种，只不过这个属性是一个对象属性而已。</p>
<h2 id="IoC-的工作原理"><a href="#IoC-的工作原理" class="headerlink" title="IoC 的工作原理"></a>IoC 的工作原理</h2><p>在 Java 软件开发过程中，系统中的各个对象之间、各个模块之间、软件系统和硬件系统之间，或多或少都存在一定的耦合关系。</p>
<p>若一个系统的耦合度过高，那么就会造成难以维护的问题，但完全没有耦合的代码几乎无法完成任何工作，这是由于几乎所有的功能都需要代码之间相互协作、相互依赖才能完成。因此我们在程序设计时，所秉承的思想一般都是在不影响系统功能的前提下，最大限度的降低耦合度。</p>
<p>IoC 底层通过工厂模式、Java 的反射机制、XML 解析等技术，将代码的耦合度降低到最低限度，其主要步骤如下。</p>
<ol>
<li>在配置文件（例如 Bean.xml）中，对各个对象以及它们之间的依赖关系进行配置；</li>
<li>我们可以把 IoC 容器当做一个工厂，这个工厂的产品就是 Spring Bean；</li>
<li>容器启动时会加载并解析这些配置文件，得到对象的基本信息以及它们之间的依赖关系；</li>
<li>IoC 利用 Java 的反射机制，根据类名生成相应的对象（即 Spring Bean），并根据依赖关系将这个对象注入到依赖它的对象中。</li>
</ol>
<p>由于对象的基本信息、对象之间的依赖关系都是在配置文件中定义的，并没有在代码中紧密耦合，因此即使对象发生改变，我们也只需要在配置文件中进行修改即可，而无须对 Java 代码进行修改，这就是 Spring IoC 实现解耦的原理。</p>
<h2 id="IoC-容器的两种实现"><a href="#IoC-容器的两种实现" class="headerlink" title="IoC 容器的两种实现"></a>IoC 容器的两种实现</h2><p>IoC 思想基于 IoC 容器实现的，IoC 容器底层其实就是一个 Bean 工厂。Spring 框架为我们提供了两种不同类型 IoC 容器，它们分别是 BeanFactory 和 ApplicationContext。</p>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory 是 IoC 容器的基本实现，也是 Spring 提供的最简单的 IoC 容器，它提供了 IoC 容器最基本的功能，由 org.springframework.beans.factory.BeanFactory 接口定义。</p>
<p>BeanFactory 采用懒加载（lazy-load）机制，容器在加载配置文件时并不会立刻创建 Java 对象，只有程序中获取（使用）这个对对象时才会创建。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;helloWorld&quot;</span>, HelloWorld.class);</span><br><span class="line">    obj.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>ApplicationContext 是 BeanFactory 接口的子接口，是对 BeanFactory 的扩展。ApplicationContext 在 BeanFactory 的基础上增加了许多企业级的功能，例如 AOP（面向切面编程）、国际化、事务支持等。</p>
<p>ApplicationContext 接口有两个常用的实现类，具体如下表。</p>
<table>
<thead>
<tr>
<th align="center">实现类</th>
<th align="center">描述</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ClassPathXmlApplicationContext</td>
<td align="center">加载类路径 ClassPath 下指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作</td>
<td align="center">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(String configLocation);</td>
</tr>
<tr>
<td align="center">FileSystemXmlApplicationContext</td>
<td align="center">加载指定的文件系统路径中指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作</td>
<td align="center">ApplicationContext applicationContext &#x3D; new FileSystemXmlApplicationContext(String configLocation);</td>
</tr>
</tbody></table>
<blockquote>
<p>在上表的示例代码中，参数 configLocation 用于指定 Spring 配置文件的名称和位置，如 Beans.xml。</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//使用 FileSystemXmlApplicationContext 加载指定路径下的配置文件 Bean.xml</span></span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\\eclipe workspace\\spring workspace\\HelloSpring\\src\\Beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;helloWorld&quot;</span>, HelloWorld.class);</span><br><span class="line">    obj.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring HttpMessageConverter</title>
    <url>/2024/07/27/Spring-HttpMessageConverter/</url>
    <content><![CDATA[<p><code>HttpMessageConverter</code> 是 Spring 框架中用于处理 HTTP 请求和响应的机制。它的作用是将 HTTP 请求体转换为 Java 对象，或将 Java 对象转换为 HTTP 响应体。这一机制使得 Spring 能够轻松地处理不同的数据格式，如 JSON、XML、表单数据等。</p>
<h2 id="以下是一些常见的-HttpMessageConverter-类型及其作用"><a href="#以下是一些常见的-HttpMessageConverter-类型及其作用" class="headerlink" title="以下是一些常见的 HttpMessageConverter 类型及其作用"></a>以下是一些常见的 <code>HttpMessageConverter</code> 类型及其作用</h2><h3 id="1-MappingJackson2HttpMessageConverter"><a href="#1-MappingJackson2HttpMessageConverter" class="headerlink" title="1. MappingJackson2HttpMessageConverter"></a>1. <strong><code>MappingJackson2HttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：将 JSON 数据转换为 Java 对象，或将 Java 对象转换为 JSON 数据。</p>
</li>
<li><p><strong>常用场景</strong>：处理 JSON 格式的数据，通常与 RESTful Web 服务一起使用。</p>
</li>
<li><p><strong>配置</strong>：Spring Boot 默认配置了这个转换器。可以通过 <code>ObjectMapper</code> 自定义其行为。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MappingJackson2HttpMessageConverter <span class="title function_">mappingJackson2HttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    converter.setObjectMapper(objectMapper()); <span class="comment">// 使用自定义的 ObjectMapper</span></span><br><span class="line">    <span class="keyword">return</span> converter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-MappingJackson2XmlHttpMessageConverter"><a href="#2-MappingJackson2XmlHttpMessageConverter" class="headerlink" title="2. MappingJackson2XmlHttpMessageConverter"></a>2. <strong><code>MappingJackson2XmlHttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：将 XML 数据转换为 Java 对象，或将 Java 对象转换为 XML 数据。</p>
</li>
<li><p><strong>常用场景</strong>：处理 XML 格式的数据。</p>
</li>
<li><p><strong>配置</strong>：需要 Jackson XML 模块来支持 XML 处理。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MappingJackson2XmlHttpMessageConverter <span class="title function_">mappingJackson2XmlHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MappingJackson2XmlHttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 可以设置 ObjectMapper 和其他配置</span></span><br><span class="line">    <span class="keyword">return</span> converter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="3-GsonHttpMessageConverter"><a href="#3-GsonHttpMessageConverter" class="headerlink" title="3. GsonHttpMessageConverter"></a>3. <strong><code>GsonHttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：将 JSON 数据转换为 Java 对象，或将 Java 对象转换为 JSON 数据，使用 Google 的 Gson 库。</p>
</li>
<li><p><strong>常用场景</strong>：如果项目中使用 Gson 作为 JSON 处理库。</p>
</li>
<li><p><strong>配置</strong>：需要添加 Gson 依赖。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GsonHttpMessageConverter <span class="title function_">gsonHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">GsonHttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonHttpMessageConverter</span>();</span><br><span class="line">    converter.setGson(<span class="keyword">new</span> <span class="title class_">Gson</span>()); <span class="comment">// 使用自定义的 Gson 实例</span></span><br><span class="line">    <span class="keyword">return</span> converter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="4-XmlMapper-和-Jaxb2RootElementHttpMessageConverter"><a href="#4-XmlMapper-和-Jaxb2RootElementHttpMessageConverter" class="headerlink" title="4. XmlMapper 和 Jaxb2RootElementHttpMessageConverter"></a>4. <strong><code>XmlMapper</code> 和 <code>Jaxb2RootElementHttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：将 XML 数据转换为 Java 对象，或将 Java 对象转换为 XML 数据，通常与 JAXB (Java Architecture for XML Binding) 一起使用。</p>
</li>
<li><p><strong>常用场景</strong>：处理 XML 格式的数据，特别是在使用 JAXB 进行 XML 绑定时。</p>
</li>
<li><p><strong>配置</strong>：可以通过添加 <code>jaxb2</code> 依赖来启用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Jaxb2RootElementHttpMessageConverter <span class="title function_">jaxb2RootElementHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jaxb2RootElementHttpMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="5-FormHttpMessageConverter"><a href="#5-FormHttpMessageConverter" class="headerlink" title="5. FormHttpMessageConverter"></a>5. <strong><code>FormHttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：将表单数据（<code>application/x-www-form-urlencoded</code>）转换为 Java 对象，或将 Java 对象转换为表单数据。</p>
</li>
<li><p><strong>常用场景</strong>：处理表单提交数据。</p>
</li>
<li><p><strong>配置</strong>：Spring Boot 默认配置了这个转换器，通常无需自定义。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FormHttpMessageConverter <span class="title function_">formHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FormHttpMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="6-ByteArrayHttpMessageConverter"><a href="#6-ByteArrayHttpMessageConverter" class="headerlink" title="6. ByteArrayHttpMessageConverter"></a>6. <strong><code>ByteArrayHttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：将字节数组（<code>byte[]</code>）数据转换为 Java 对象，或将 Java 对象转换为字节数组。</p>
</li>
<li><p><strong>常用场景</strong>：处理二进制数据，如文件上传或下载。</p>
</li>
<li><p><strong>配置</strong>：Spring Boot 默认配置了这个转换器，通常无需自定义。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ByteArrayHttpMessageConverter <span class="title function_">byteArrayHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ByteArrayHttpMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="7-StringHttpMessageConverter"><a href="#7-StringHttpMessageConverter" class="headerlink" title="7. StringHttpMessageConverter"></a>7. <strong><code>StringHttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：将字符串（<code>String</code>）数据转换为 Java 对象，或将 Java 对象转换为字符串。</p>
</li>
<li><p><strong>常用场景</strong>：处理文本数据，如普通的文本或 HTML 内容。</p>
</li>
<li><p><strong>配置</strong>：Spring Boot 默认配置了这个转换器，通常无需自定义。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> StringHttpMessageConverter <span class="title function_">stringHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringHttpMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="8-ResourceHttpMessageConverter"><a href="#8-ResourceHttpMessageConverter" class="headerlink" title="8. ResourceHttpMessageConverter"></a>8. <strong><code>ResourceHttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：将资源（如文件）转换为 Java 对象，或将 Java 对象转换为资源。</p>
</li>
<li><p><strong>常用场景</strong>：处理资源文件的上传或下载。</p>
</li>
<li><p><strong>配置</strong>：Spring Boot 默认配置了这个转换器，通常无需自定义。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ResourceHttpMessageConverter <span class="title function_">resourceHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>HttpMessageConverter</code> 在 Spring 中发挥着至关重要的作用，通过不同的转换器处理各种数据格式的转换。根据你的应用需求，可能需要配置或自定义这些转换器，以确保数据的正确处理和传递。</p>
<h2 id="除了常见的-HttpMessageConverter-类型，Spring-还提供了其他一些特定的-HttpMessageConverter-类型，处理更特殊的场景或需求。"><a href="#除了常见的-HttpMessageConverter-类型，Spring-还提供了其他一些特定的-HttpMessageConverter-类型，处理更特殊的场景或需求。" class="headerlink" title="除了常见的 HttpMessageConverter 类型，Spring 还提供了其他一些特定的 HttpMessageConverter 类型，处理更特殊的场景或需求。"></a>除了常见的 <code>HttpMessageConverter</code> 类型，Spring 还提供了其他一些特定的 <code>HttpMessageConverter</code> 类型，处理更特殊的场景或需求。</h2><h3 id="1-ResourceRegionHttpMessageConverter"><a href="#1-ResourceRegionHttpMessageConverter" class="headerlink" title="1. ResourceRegionHttpMessageConverter"></a>1. <strong><code>ResourceRegionHttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：用于将 <code>ResourceRegion</code> 处理为 HTTP 响应，通常用于分段传输大文件。这种转换器可以支持从一个大文件中读取特定的部分（即分段）并将其传输给客户端。</p>
</li>
<li><p><strong>常用场景</strong>：实现大文件的分段下载，特别是在需要支持 HTTP Range 请求时。</p>
</li>
<li><p><strong>配置</strong>：通常与 <code>Resource</code> 和 <code>ResourceRegion</code> 类一起使用。Spring Boot 默认不配置这个转换器，因此如果需要，你可能需要自定义配置它。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ResourceRegionHttpMessageConverter <span class="title function_">resourceRegionHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourceRegionHttpMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="2-AllEncompassingFormHttpMessageConverter"><a href="#2-AllEncompassingFormHttpMessageConverter" class="headerlink" title="2. AllEncompassingFormHttpMessageConverter"></a>2. <strong><code>AllEncompassingFormHttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：处理表单数据（<code>application/x-www-form-urlencoded</code>）和多部分表单数据（<code>multipart/form-data</code>）。这个转换器能够处理提交的表单数据，并将其转换为 Java 对象或处理文件上传。</p>
</li>
<li><p><strong>常用场景</strong>：当你需要处理复杂的表单提交，包括文件上传和多部分数据时，<code>AllEncompassingFormHttpMessageConverter</code> 会提供全面的支持。</p>
</li>
<li><p><strong>配置</strong>：这是一个比较特殊的转换器，通常需要在特定场景下使用，并且可能需要自定义配置以满足需求。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> AllEncompassingFormHttpMessageConverter <span class="title function_">allEncompassingFormHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AllEncompassingFormHttpMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="3-SourceHttpMessageConverter"><a href="#3-SourceHttpMessageConverter" class="headerlink" title="3. SourceHttpMessageConverter"></a>3. <strong><code>SourceHttpMessageConverter</code></strong></h3><ul>
<li><p><strong>作用</strong>：将 <code>Source</code> 类型的数据转换为 HTTP 响应。<code>Source</code> 是一个接口，通常用于处理 XML 数据源，它代表一个可以被处理的 XML 数据源。</p>
</li>
<li><p><strong>常用场景</strong>：处理 XML 数据的场景，特别是在需要将 XML 数据以原始的 <code>Source</code> 类型进行处理或传输时。</p>
</li>
<li><p><strong>配置</strong>：通常在需要处理 XML 数据源时使用，默认配置中可能不会启用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SourceHttpMessageConverter&lt;Source&gt; <span class="title function_">sourceHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SourceHttpMessageConverter</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="说明与用途"><a href="#说明与用途" class="headerlink" title="说明与用途"></a>说明与用途</h3><ul>
<li>**<code>ResourceRegionHttpMessageConverter</code>**：用于处理大文件的分段传输，特别适用于支持 Range 请求的场景。</li>
<li>**<code>AllEncompassingFormHttpMessageConverter</code>**：处理复杂的表单数据，包括文件上传和多部分表单数据，适用于需要全面表单支持的情况。</li>
<li>**<code>SourceHttpMessageConverter</code>**：用于处理 XML 数据源，适合需要以 <code>Source</code> 类型传输和处理 XML 数据的应用。</li>
</ul>
<p>这些转换器通常是针对特定的使用场景或需求设计的，如果你的应用场景需要它们，可以根据需要进行配置和使用。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 异步注解 @Async</title>
    <url>/2024/06/23/Spring-%E5%BC%82%E6%AD%A5%E6%B3%A8%E8%A7%A3-Async/</url>
    <content><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>在 Java 中，当我们需要执行异步操作时，往往会去创建一个新线程去执行，如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：异步任务&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Spring 3.0 之 后提供了一个 <code>@Async</code>注解，使用 <code>@Async</code> 注解进行优雅的异步调用。<br>其实，<code>@Async</code>注解本质上还是通过线程池创建线程去异步执行任务</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="开启-Async"><a href="#开启-Async" class="headerlink" title="开启 @Async"></a>开启 <code>@Async</code></h3><p>使用 <code>@Async</code> 注解步骤：</p>
<ol>
<li>添加 <code>@EnableAsync</code> 注解。在主类上或者 某个类上，否则，异步方法不会生效</li>
<li>添加 <code>@Async</code> 注解。在异步方法上添加此注解。异步方法不能被 <code>static</code> 修饰</li>
<li>需要自定义线程池，则可以配置线程池（下文有）</li>
</ol>
<h3 id="使用-Async"><a href="#使用-Async" class="headerlink" title="使用@Async"></a>使用<code>@Async</code></h3><p><code>@Async</code>注解可以应用于任何Spring Bean（通常是Service层的方法）的方法声明上，指示该方法应该在一个单独的线程中异步执行：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这个方法将在一个独立的线程中执行</span></span><br><span class="line">        <span class="comment">// 执行耗时的操作，如数据库查询、网络请求等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>❗ 注意，被<code>@Async</code>标注的方法必须是void类型的，且不能有返回值，除非返回类型是Future，这样可以通过Future获取异步操作的结果。</p>
</blockquote>
<h3 id="Async方法的异常处理"><a href="#Async方法的异常处理" class="headerlink" title="@Async方法的异常处理"></a><code>@Async</code>方法的异常处理</h3><p>由于异步方法是在后台线程中执行的，因此抛出的异常不会立即中断主线程的执行。为了捕获和处理这些异常，可以利用<code>@Async</code>注解所在方法所在的类上的<code>@AsyncExceptionHandler</code>方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 可能抛出异常的异步代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AsyncExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAsyncException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理异步方法中抛出的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>综上所述，Spring的<code>@Async</code>注解极大地简化了异步编程模型，使得开发者能够方便地实现异步任务调度，提高系统并发处理能力和用户体验。同时，合理配置线程池并妥善处理异步任务中可能出现的异常，也是保障系统稳定性和健壮性的重要环节。</p>
<h2 id="自定义-Async-注解的线程池"><a href="#自定义-Async-注解的线程池" class="headerlink" title="自定义@Async 注解的线程池"></a>自定义<code>@Async</code> 注解的线程池</h2><h3 id="方法-1-使用AsyncConfigurer指定线程池"><a href="#方法-1-使用AsyncConfigurer指定线程池" class="headerlink" title="方法 1 使用AsyncConfigurer指定线程池"></a>方法 1 使用<code>AsyncConfigurer</code>指定线程池</h3><p><code>AsyncConfigurer</code>接口是Spring框架用于全局配置异步执行器（即线程池）的核心接口。当我们的Spring应用需要统一管理所有异步任务的执行环境时，可以选择实现此接口。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@EnableAsync</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalAsyncConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">5</span>); <span class="comment">// 核心线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>); <span class="comment">// 最大线程数</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">20</span>); <span class="comment">// 队列容量</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;global-&quot;</span>); <span class="comment">// 线程名称前缀</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在此示例中，<code>GlobalAsyncConfig</code>类实现了<code>AsyncConfigurer</code>接口，并在<code>getAsyncExecutor()</code>方法中配置了一个全局的线程池。这意味着，对于应用中所有标记为<code>@Async</code>的方法，默认都会使用这个配置好的线程池执行异步任务。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeGlobalTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此方法将使用GlobalAsyncConfig中配置的线程池执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="方法-2-指定使用自定义的线程池-Excutor-实例-Bean"><a href="#方法-2-指定使用自定义的线程池-Excutor-实例-Bean" class="headerlink" title="方法 2 指定使用自定义的线程池 Excutor 实例 Bean"></a>方法 2 指定使用自定义的线程池 <code>Excutor</code> 实例 Bean</h3><p>在Spring容器中注册一个线程池Bean，这种方式允许你根据业务需求更加灵活地管理和分配不同的线程池资源。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadPoolConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name = &quot;customExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">customExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">5</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">10</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;custom-&quot;</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>现在，我们可以明确地将特定的线程池Bean与某个异步方法关联起来：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Async(&quot;customExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCustomTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此方法将使用CustomThreadPoolConfig中名为customExecutor的线程池执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过在<code>@Async</code>注解中指定<code>customExecutor</code>，系统将优先使用这个名字注册在Spring容器中的线程池，而不是全局配置的线程池。</p>
<h3 id="Spring-的默认线程池配置"><a href="#Spring-的默认线程池配置" class="headerlink" title="Spring 的默认线程池配置"></a>Spring 的默认线程池配置</h3><ol>
<li>注意早期版本的Spring Boot环境中，如果用户没有自定义配置异步执行器（Async Executor），并且没有实现<code>AsyncConfigurer</code>接口来提供一个自定义的执行器，那么Spring Boot会使用一个默认的异步执行器，而在某些早期版本或特定配置下，这个默认执行器可能是<code>SimpleAsyncTaskExecutor</code>，这是个不重用线程、无界并发的执行器。每个提交的任务创建一个新的线程来执行。这意味着每次调用都会创建新的线程资源，而不从固定大小的线程池中获取可用线程。</li>
<li>在后期版本中，如果没有 <code>Executor</code> 的实例 Spring Boot将会使用其默认配置的线程池（名称为 taskExecutor）来执行被<code>@Async</code>注解修饰的异步方法。</li>
<li>在Spring Boot如果不存在 Excutor Bean 会通过<code>TaskExecutionAutoConfiguration</code>，它会自动配置一个基于<code>ThreadPoolTaskExecutor</code>的默认线程池，取名为<code>applicationTaskExecutor</code> 和 <code>taskExecutor</code> 进行自动配置。如果已经自定义了Executor bean 那么<code>applicationTaskExecutor</code>将不会自动配置。</li>
<li>这个默认线程池的相关配置通常基于Spring Boot的默认属性这些属性可以根据应用的具体需求，在<code>application.properties</code>或<code>application.yml</code>文件中进行调整。例如：<br>  a. <code>spring.task.execution.pool.core-size</code>：核心线程数，默认值可能依赖于具体版本，一般较小。<br>  b. <code>spring.task.execution.pool.max-size</code>：最大线程数，默认值也可能因版本不同而变化。<br>  c. <code>spring.task.execution.pool.queue-capacity</code>：线程池的工作队列容量。<br>  d. <code>spring.task.execution.pool.keep-alive</code>：空闲线程的存活时间。</li>
</ol>
<h2 id="失效场景"><a href="#失效场景" class="headerlink" title="失效场景"></a>失效场景</h2><blockquote>
<p>💡 <code>@Async</code>注解基于 Spring AOP 动态代理实现</p>
</blockquote>
<h3 id="调用者与被调用者在同一个类中"><a href="#调用者与被调用者在同一个类中" class="headerlink" title="调用者与被调用者在同一个类中"></a>调用者与被调用者在同一个类中</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>当调用 <code>@Async</code>注解 的方法的类和被调用的方法在同一个类中时，<code>@Async</code> 注解不会生效。因为 Spring 的 AOP 代理是基于接口的，对于同一个类中的方法调用，不会经过代理，因此 <code>@Async</code> 注解不会被处理。例如：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 模拟耗时操作  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Async method executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callAsyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        asyncMethod(); <span class="comment">// 直接调用，不会异步执行  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>确保异步方法和调用它的方法不在同一个类中。可以将异步方法提取到一个单独的 Service 中，并在需要的地方注入这个 Service。</li>
<li>确保异步方法的执行类（即包含 <code>@Async</code> 注解方法的类）被 Spring 容器管理，比如通过 <code>@Service</code>、<code>@Component</code> 等注解标注</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一定使用@Service、@Component 等注解标注，确保执行类被Spring管理，</span></span><br><span class="line"><span class="comment">// 因为异步线程是通过动态代理实现的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 模拟耗时操作  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Async method executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="配置类未启用异步支持"><a href="#配置类未启用异步支持" class="headerlink" title="配置类未启用异步支持"></a>配置类未启用异步支持</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>如果配置类中没有启用异步支持，即没有使用 <code>@EnableAsync</code> 注解，那么 <code>@Async</code> 注解同样不会生效。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有使用 @EnableAsync 注解，因此不会启用异步支持  </span></span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 其他配置 ...  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 模拟耗时操作  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Async method executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>在配置类上使用 <code>@EnableAsync</code> 注解，启用异步支持。<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 其他配置 ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="方法不是-public-的"><a href="#方法不是-public-的" class="headerlink" title="方法不是 public 的"></a>方法不是 public 的</h3><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p><code>@Async</code> 注解的方法必须是 <code>public</code> 的，否则不会被 Spring AOP 代理捕获，导致异步执行不生效。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 但这个方法不是 public 的，所以 @Async 不会生效  </span></span><br><span class="line">    <span class="meta">@Async</span> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 模拟耗时操作  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Async method executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callAsyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        asyncMethod(); <span class="comment">// 直接调用，但由于 asyncMethod 不是 public 的，因此不会异步执行  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>● 确保异步方法是 <code>public</code> 的</p>
<h3 id="线程池未正确配置"><a href="#线程池未正确配置" class="headerlink" title="线程池未正确配置"></a>线程池未正确配置</h3><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><p>在使用 <code>@Async</code> 注解时，如果没有正确配置线程池，可能会遇到异步任务没有按预期执行的情况。例如，线程池被配置为只有一个线程，且该线程一直被占用，那么新的异步任务就无法执行。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@EnableAsync</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 创建一个只有一个线程的线程池，这会导致并发问题  </span></span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();  </span><br><span class="line">        executor.setCorePoolSize(<span class="number">1</span>);  </span><br><span class="line">        executor.setMaxPoolSize(<span class="number">1</span>);  </span><br><span class="line">        executor.setQueueCapacity(<span class="number">10</span>);  </span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;Async-&quot;</span>);  </span><br><span class="line">        executor.initialize();  </span><br><span class="line">        <span class="keyword">return</span> executor;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ... 其他配置 ...  </span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 模拟耗时操作  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Async method executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>● 正确配置线程池：确保线程池配置合理，能够处理预期的并发任务量</p>
<h3 id="异常处理不当"><a href="#异常处理不当" class="headerlink" title="异常处理不当"></a>异常处理不当</h3><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><p>如果在异步方法中抛出了异常，并且没有妥善处理，那么这个异常可能会导致任务失败，而调用者可能无法感知到异常的发生。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 模拟一个可能会抛出异常的耗时操作  </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Async method exception&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用者  </span></span><br><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallerService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> MyService myService;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callAsyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        myService.asyncMethod(); <span class="comment">// 调用异步方法，但如果该方法抛出异常，调用者不会立即感知到  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>● 合理处理异常：在异步方法中妥善处理异常，可以通过 <code>Future</code> 对象来捕获异步任务执行过程中抛出的异常。</p>
<h3 id="Spring代理未生效"><a href="#Spring代理未生效" class="headerlink" title="Spring代理未生效"></a>Spring代理未生效</h3><h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><p>如果通过 <code>new</code> 关键字直接创建了服务类的实例，而不是通过 Spring 容器来获取，那么 Spring 的 AOP 代理将不会生效，导致 <code>@Async</code> 注解无效。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 模拟耗时操作  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Async method executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeNonSpringClass</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 直接通过 new 创建 MyService 实例，不会经过 Spring 代理  </span></span><br><span class="line">        <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyService</span>(); </span><br><span class="line">        myService.asyncMethod(); <span class="comment">// 这里 `@Async` 不会生效  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>● 合理利用依赖注入：始终通过 Spring 容器来获取服务类的实例，而不是直接通过 <code>new</code> 关键字创建</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 模拟耗时操作  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Async method executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeNonSpringClass</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> MyService myService;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;   </span><br><span class="line">        myService.asyncMethod(); <span class="comment">// 这里 `@Async` 会生效  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用-Transactional-与-Async-同时注解方法，导致事务失效"><a href="#使用-Transactional-与-Async-同时注解方法，导致事务失效" class="headerlink" title="使用 @Transactional 与 @Async 同时注解方法，导致事务失效"></a>使用 <code>@Transactional</code> 与 <code>@Async</code> 同时注解方法，导致事务失效</h3><h4 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h4><p>在同一个方法上同时使用 <code>@Transactional</code> 和 <code>@Async</code> 注解可能会导致问题。由于 <code>@Async</code> 会导致方法在一个新的线程中执行，而 <code>@Transactional</code> 通常需要在一个由 Spring 管理的事务代理中执行，这两个注解的结合使用可能会导致事务管理失效或行为不可预测。此种场景不会导致<code>@Async</code>注解失效，但是会导致<code>@Transactional</code>注解失效，也就是事务失效。例如：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 错误的用法：同时使用了 @Transactional 和 `@Async`  </span></span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncTransactionalMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 模拟一个数据库操作  </span></span><br><span class="line">        myRepository.save(<span class="keyword">new</span> <span class="title class_">MyEntity</span>());  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 模拟可能抛出异常的代码  </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Database operation failed!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Repository</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;MyEntity, Long&gt; &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Entity</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEntity</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 实体类的属性和映射 ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码，在抛出异常的时候，我们期望的是回滚前面的数据库保存操作，但是因为事务失效，会导致错误数据成功保存进数据库。</p>
<h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p>● 正确配置事务，比如单独提取事务执行的逻辑到一个新的Service里，事务执行方法单独使用<code>@Transactional</code>标识</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> MyTransactionalService myTransactionalService;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> AsyncExecutor asyncExecutor;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callAsyncTransactionalMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 在事务中执行数据库操作  </span></span><br><span class="line">        <span class="type">MyEntity</span> <span class="variable">entity</span> <span class="operator">=</span> myTransactionalService.transactionalMethod();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 异步执行其他操作  </span></span><br><span class="line">        asyncExecutor.execute(() -&gt; &#123;  </span><br><span class="line">            <span class="comment">// 这里执行不需要事务管理的异步操作  </span></span><br><span class="line">            <span class="comment">// ...  </span></span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTransactionalService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="keyword">public</span> MyEntity <span class="title function_">transactionalMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 在事务中执行数据库操作  </span></span><br><span class="line">        <span class="keyword">return</span> myRepository.save(<span class="keyword">new</span> <span class="title class_">MyEntity</span>());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExecutor</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;  </span><br><span class="line">        task.run();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 状态机</title>
    <url>/2024/06/21/Spring-%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="Spring-状态机"><a href="#Spring-状态机" class="headerlink" title="Spring 状态机"></a>Spring 状态机</h1><h2 id="什么是状态机"><a href="#什么是状态机" class="headerlink" title="什么是状态机"></a>什么是状态机</h2><blockquote>
<p>先来解释什么是”状态”（ State ）。现实事物是有不同状态的，例如一个自动门，就有 open 和 closed 两种状态。我们通常所说的状态机是有限状态机，也就是被描述的事物的状态的数量是有限个，例如自动门的状态就是两个 open 和 closed 。</p>
</blockquote>
<p>状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学模型。<br>说白了，一般就是指一张状态转换图。例如，根据自动门的运行规则，我们可以抽象出下面这么一个图。<br>自动门有两个状态，open 和 closed ，closed 状态下，如果读取开门信号，那么状态就会切换为 open 。<br>open 状态下如果读取关门信号，状态就会切换为 closed 。<br>状态机的全称是有限状态自动机，自动两个字也是包含重要含义的。<br>给定一个状态机，同时给定它的当前状态以及输入，那么输出状态时可以明确的运算出来的。例如对于自动门，给定初始状态 closed ，给定输入”开门”，那么下一个状态时可以运算出来的。<br>重复一下：状态机是有限状态自动机的简称，是现实事物运行规则抽象而成的一个数学模型。</p>
<h2 id="四大概念"><a href="#四大概念" class="headerlink" title="四大概念"></a>四大概念</h2><ul>
<li>状态 : 一个状态机至少要包含两个状态。例如上面自动门的例子，有 open 和 closed 两个状态。</li>
<li>事件 : 事件就是执行某个操作的触发条件或者口令。对于自动门，”按下开门按钮”就是一个事件。</li>
<li>动作 : 事件发生以后要执行动作。例如事件是”按开门按钮”，动作是”开门”。编程的时候，一个 Action一般就对应一个函数。</li>
<li>转变 : 也就是从一个状态变化为另一个状态。例如”开门过程”就是一个变换。</li>
</ul>
<p>有限状态机（Finite-state machine,FSM），又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。<br>FSM是一种算法思想，简单而言，有限状态机由一组状态、一个初始状态、输入和根据输入及现有状态转换为下一个状态的转换函数组成。<br>其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。</p>
<p>①现态：是指当前所处的状态。待支付<br>②条件：又称为”事件”，当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。支付事件<br>③动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。状态转换为待发货<br>④次态：条件满足后要迁往的新状态。”次态”是相对于”现态”而言的，”次态”一旦被激活，就转变成新的”现态”了。待发货 注意事项</p>
<p><a class="link"   href="https://mp.weixin.qq.com/s/PNYpCWw_7HIDevMLv4-QxA" >Spring状态机<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot MyBatis 缓存关闭</title>
    <url>/2024/07/05/SpringBoot-MyBatis-%E7%BC%93%E5%AD%98%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<p>在 Spring Boot 中使用 MyBatis，并且想要关闭缓存，可以通过以下几种方法来实现：</p>
<h2 id="方法一：在-MyBatis-配置文件中关闭缓存"><a href="#方法一：在-MyBatis-配置文件中关闭缓存" class="headerlink" title="方法一：在 MyBatis 配置文件中关闭缓存"></a>方法一：在 MyBatis 配置文件中关闭缓存</h2><p>在 MyBatis 的 XML 配置文件(通常是 <code>mybatis-config.xml</code>)中配置关闭缓存的选项。</p>
<p>创建或编辑 MyBatis 配置文件</p>
<p>如果项目中没有 <code>mybatis-config.xml</code> 文件，可以创建一个。示例配置如下：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关闭缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在 <code>&lt;settings&gt;</code> 下添加 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;</code>，这将关闭所有 MyBatis 映射器的缓存。</p>
<p>在 Spring Boot 中引入 MyBatis 配置</p>
<p>如果在 Spring Boot 中使用 <code>application.properties</code> 或 <code>application.yml</code> 进行 MyBatis 配置，需要在配置文件中指定 MyBatis 配置文件的位置：</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">config-location:</span> <span class="string">classpath:mybatis-config.xml</span></span><br></pre></td></tr></table></figure></div>

<p>或者在 Java 配置中指定：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sessionFactory.setDataSource(dataSource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 MyBatis 配置文件路径</span></span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        sessionFactory.setConfigLocation(resource);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="方法二：在-Mapper-接口中禁用缓存"><a href="#方法二：在-Mapper-接口中禁用缓存" class="headerlink" title="方法二：在 Mapper 接口中禁用缓存"></a>方法二：在 Mapper 接口中禁用缓存</h2><p>另一种方法是在具体的 Mapper 接口或方法上禁用缓存。</p>
<p>在 Mapper 接口中配置</p>
<p>在需要禁用缓存的 Mapper 接口方法上添加 <code>@Options(useCache = false)</code> 注解。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Options(useCache = false)</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样做会针对该方法禁用缓存。</p>
<h2 id="方法三：在-application-properties-或-application-yml-中配置"><a href="#方法三：在-application-properties-或-application-yml-中配置" class="headerlink" title="方法三：在 application.properties 或 application.yml 中配置"></a>方法三：在 application.properties 或 application.yml 中配置</h2><p>如果使用 Spring Boot 的自动配置，可以在 <code>application.properties</code> 或 <code>application.yml</code> 文件中配置全局的 MyBatis 属性，包括缓存配置。</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">        <span class="attr">cache-enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></div>

<p>这种方法会在全局范围内禁用 MyBatis 的缓存。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>缓存的作用：MyBatis 的缓存能够显著提高查询效率，因此在关闭缓存之前，请确保了解其对系统性能的影响。<br>多种方法选择：根据实际需求选择合适的方法，可以是全局禁用、局部禁用或配置文件中配置禁用。<br>通过以上方法，可以在 Spring Boot 中关闭 MyBatis 的缓存功能。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Java</category>
        <category>ORM</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Mybaits</tag>
      </tags>
  </entry>
  <entry>
    <title>TOTP 动态口令</title>
    <url>/2024/06/27/TOTP-%E5%8A%A8%E6%80%81%E5%8F%A3%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="OTP-HOTP-TOTP"><a href="#OTP-HOTP-TOTP" class="headerlink" title="OTP&#x2F;HOTP&#x2F;TOTP"></a>OTP&#x2F;HOTP&#x2F;TOTP</h2><h3 id="OTP-One-time-Password"><a href="#OTP-One-time-Password" class="headerlink" title="OTP (One-time Password)"></a>OTP (One-time Password)</h3><p>OTP 是一次性密码，又称动态密码或单次有效密码，是指计算机系统或其他数字设备上只能使用一次的密码，有效期为只有一次登录会话或交易。</p>
<h3 id="HOTP-HMAC-based-One-time-Password"><a href="#HOTP-HMAC-based-One-time-Password" class="headerlink" title="HOTP (HMAC-based One-time Password)"></a>HOTP (HMAC-based One-time Password)</h3><p>HOTP 是一种基于散列消息验证码(HMAC)的一次性密码算法。</p>
<h3 id="TOTP-Time-based-One-Time-Password"><a href="#TOTP-Time-based-One-Time-Password" class="headerlink" title="TOTP (Time-based One-Time Password)"></a>TOTP (Time-based One-Time Password)</h3><p>TOTP 是一种根据预共享的密钥与当前时间计算一次性密码的算法。它已被互联网工程任务组接纳为RFC 6238标准，成为主动开放认证(OATH)的基石，并被用于众多多重要素验证系统当中。</p>
<p>TOTP基于HOTP实现，它结合一个私钥与当前时间戳，使用一个密码散列函数来生成一次性密码。由于网络延迟与时钟不同步可能导致密码接收者不得不尝试多次遇到正确的时间来进行身份验证，时间戳通常以30秒为间隔，从而避免反复尝试。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a class="link"   href="https://medium.com/@rakesh.open.source/time-based-one-time-password-totp-java-implementation-82a472bd6bf9" >Time-Based One-Time Password (TOTP) — Java Implementation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/641587128" >基于 TOTP 实现多重身份(Multi-factor)认证<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://stytch.com/blog/what-is-totp/" >What is TOTP and why does it matter?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://allthingsauth.com/2018/04/20/a-medium-dive-on-the-totp-spec/" >A medium dive on the Time-based One-time Passwords (TOTP) spec<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.twilio.com/docs/glossary/totp" >What is a Time-based One-time Password (TOTP)?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>密码</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>VIA: 客制化键盘工具</title>
    <url>/2025/04/25/VIA-%E5%AE%A2%E5%88%B6%E5%8C%96%E9%94%AE%E7%9B%98%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote>
<p>VIA 是一款开源的键盘配置工具，全称为 Virtual Keyboard Interface，主要用于客制化键盘的自定义设置。它允许用户通过图形化界面轻松地自定义键盘的按键映射、灯光效果以及其他功能。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_11-23-40.png"
                     
                ></p>
<h3 id="VIA-的主要功能"><a href="#VIA-的主要功能" class="headerlink" title="VIA 的主要功能"></a>VIA 的主要功能</h3><ol>
<li><strong>按键映射自定义</strong>：用户可以根据自己的使用习惯，将键盘上的任意按键重新映射为其他按键。例如，将“Q”键改为“A”键。</li>
<li><strong>宏定义</strong>：可以设置复杂的按键组合或序列，通过一个按键触发多个操作。比如将某个按键设置为复制（Alt+C）操作。</li>
<li><strong>多层设置</strong>：支持多层按键布局，用户可以在不同层上设置完全不同的按键功能。</li>
<li><strong>灯光效果调整</strong>：对于支持 VIA 的键盘，用户可以自定义键盘的灯光效果，包括颜色、亮度和动态效果。</li>
<li><strong>Any 键功能</strong>：允许用户将任意按键设置为特殊功能键，如“Ctrl”或“Shift”。</li>
</ol>
<h3 id="使用-VIA-的步骤"><a href="#使用-VIA-的步骤" class="headerlink" title="使用 VIA 的步骤"></a>使用 VIA 的步骤</h3><ol>
<li><strong>确认键盘支持</strong>：确保你的客制化键盘支持 VIA 功能，并获取对应的 <code>.json</code> 文件。</li>
<li><strong>安装 VIA</strong>：从 GitHub 下载 VIA 软件，或通过网页版直接访问。</li>
<li><strong>导入配置文件</strong>：打开 VIA 软件后，导入键盘对应的 <code>.json</code> 文件。</li>
<li><strong>自定义设置</strong>：在 VIA 的图形化界面中，根据需要进行按键映射、宏定义等设置。</li>
<li><strong>保存并应用</strong>：完成设置后，保存配置并应用到键盘上。</li>
</ol>
<h3 id="VIA-的优势"><a href="#VIA-的优势" class="headerlink" title="VIA 的优势"></a>VIA 的优势</h3><ul>
<li><strong>简单易用</strong>：通过图形化界面，即使是新手也能快速上手。</li>
<li><strong>高度自定义</strong>：提供了丰富的自定义选项，满足不同用户的需求。</li>
<li><strong>开源免费</strong>：VIA 是一个开源项目，用户可以免费使用。</li>
</ul>
<p>VIA 为客制化键盘爱好者提供了一个强大的工具，可以轻松实现个性化设置，提升键盘的使用体验。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><a class="link"   href="https://usevia.app/" >VIA 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="http://doiokb.com/index.php?m=home&c=Lists&a=index&tid=191" >QMK架构VIA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<blockquote>
<p>VIA 本版不统一 需要甄别使用</p>
</blockquote>
<h3 id="设备授权"><a href="#设备授权" class="headerlink" title="设备授权"></a>设备授权</h3><h4 id="链接设备-依次点击-Authorize-device-keyboard-连接"><a href="#链接设备-依次点击-Authorize-device-keyboard-连接" class="headerlink" title="链接设备: 依次点击 Authorize device + &gt; keyboard &gt; 连接"></a>链接设备: 依次点击 <code>Authorize device +</code> &gt; <code>keyboard</code> &gt; <code>连接</code></h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_13-23-38.png"
                     
                ></p>
<h4 id="开启设计模式-依次点击-SETTINGS-Show-Design-tab-ON"><a href="#开启设计模式-依次点击-SETTINGS-Show-Design-tab-ON" class="headerlink" title="开启设计模式: 依次点击 SETTINGS &gt; Show Design tab &gt; ON"></a>开启设计模式: 依次点击 <code>SETTINGS</code> &gt; <code>Show Design tab</code> &gt; <code>ON</code></h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_13-27-05.png"
                     
                ></p>
<h4 id="导入json文件-依次点击-DESIGN-Load-json文件"><a href="#导入json文件-依次点击-DESIGN-Load-json文件" class="headerlink" title="导入json文件: 依次点击 DESIGN &gt; Load &gt; .json文件"></a>导入json文件: 依次点击 <code>DESIGN</code> &gt; <code>Load</code> &gt; <code>.json文件</code></h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_13-27-28.png"
                     
                ></p>
<h4 id="成功识别设备"><a href="#成功识别设备" class="headerlink" title="成功识别设备"></a>成功识别设备</h4><div style="display: flex; justify-content: space-between;">
    <figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_11-25-29.png"
                      alt="DOIO 左手" style="width: 90%;"
                ><figcaption>DOIO 左手</figcaption></figure>
    <figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_11-25-09.png"
                      alt="DOIO 右手" style="width: 90%;"
                ><figcaption>DOIO 右手</figcaption></figure>
</div>

<h2 id="改键"><a href="#改键" class="headerlink" title="改键"></a>改键</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/1-23112G343591A.jpg"
                     
                ></p>
<h3 id="基础键位"><a href="#基础键位" class="headerlink" title="基础键位"></a>基础键位</h3><p>左侧 <code>KEYMAP</code> 菜单修改键位 点击上方设计键位槽 然后点击下方选择目标键修改</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_11-25-29.png"
                     
                ></p>
<h3 id="层-Layer"><a href="#层-Layer" class="headerlink" title="层 (Layer)"></a>层 (Layer)</h3><ol>
<li>在 <code>layer0</code> 层按下 <code>5</code> 就输入一个 <code>5</code></li>
<li>在 <code>layer5</code> 层按下 <code>5</code> 就是调亮灯光 <code>RGB SPI</code></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_14-00-10.png"
                     
                ></p>
<blockquote>
<p>不同设备层切换方式不同 最常用的是 <code>MO</code> 和 <code>TO</code></p>
</blockquote>
<ol>
<li><code>MO(*)</code>：该键为组合按键，当按下该键，当前键盘键值即可临时切换为对应层键盘键值，同时按下对应层按键，即可实现对应层键值功能输入。</li>
<li><code>TO(*)</code>：该键为层切换按钮，按下即可切换到目标层键盘键值。</li>
<li><code>OSL(*)</code>：当按下该键后，键盘键值会切换为目标层键值，点击目标曾某一按键后，即恢复原键盘键值。</li>
<li><code>TG(*)</code>：该键为层按键切换按钮，按下即可将当前键盘键值切换为目标键盘键值，再按下即可恢复到原键盘键值。</li>
<li><code>TT(*)</code>：<ul>
<li>按下即可将当前键盘键值临时切换为对应层键盘键值，同时按下对应层按键，即可实现对应层键值功能输入</li>
<li>连续点击5下，当前键盘键值即可切换至目标层键值。</li>
</ul>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_14-00-39.png"
                     
                ></p>
<blockquote>
<p><em>如果是三模的键盘，务必要保留有线功能的切换，否则再您切换到无线功能之后，将无法切回至有线功能，也就无法使用VIA，只能进行键盘重置才可以切回</em></p>
</blockquote>
<h3 id="功能键"><a href="#功能键" class="headerlink" title="功能键"></a>功能键</h3><blockquote>
<p>除了层级切换功能键意外还包含更多功能键设置</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_14-00-57.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_14-01-10.png"
                     
                ></p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/via/Snipaste_2025-04-25_14-01-34.png"
                     
                ></p>
<blockquote>
<p>To be continued</p>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>无法识别设备<ul>
<li>检查设备是否支持VIA</li>
<li>检查设备是否连接正确</li>
<li>检查设备是否开启设计模式</li>
<li>桌面版无法识别 可以尝试使用网页版链接后正常识别</li>
</ul>
</li>
<li>导入json文件 VIA不能识别键盘的问题<ul>
<li>在 <code>DESIGN</code> 页面，打开或关闭 <code>Use V2/3 definitions</code> 按钮，然后返回 <code>CONFIGURE</code> 页面，就可以看到键盘被识别了。</li>
</ul>
</li>
<li>为什么VIA没有any键<ul>
<li>有些汉化版via没有any键 使用网页版或者英文原版via</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a class="link"   href="https://www.caniusevia.com/docs/specification" >VIA Doc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/651406695" >VIA 改键基础教程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/599850387" >客制化键盘VIA改键进阶教程及ANY键初入门<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>VIA</category>
      </categories>
      <tags>
        <tag>VIA</tag>
        <tag>Keyboard</tag>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>Version 版本</title>
    <url>/2024/06/22/Version-%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h1><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/version.png"
                      alt="version"
                ><figcaption>version</figcaption></figure></p>
<blockquote>
<p>语义化版本 : 版本格式 -&gt; 主版本号.次版本号.修订号</p>
</blockquote>
<ul>
<li>主版本号：当你做了不兼容的API 修改。</li>
<li>次版本号：当你做了向下兼容的功能性新增。</li>
<li>修订号：当你做了向下兼容的问题修正。</li>
</ul>
<blockquote>
<p>在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的套件越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。</p>
</blockquote>
<p>在依赖高的系统中发布新版本套件可能很快会成为恶梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个相依套件改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你专案的进展因为版本相依被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。<br>作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共API。这可以透过文件定义或代码强制要求来实现。无论如何，这套API 的清楚明了是十分重要的。一旦你定义了公共API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：XYZ （主版本号.次版本号.修订号）修复问题但不影响API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。<br>这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。</p>
<h2 id="语义化版本控制规范-SemVer"><a href="#语义化版本控制规范-SemVer" class="headerlink" title="语义化版本控制规范(SemVer)"></a>语义化版本控制规范(SemVer)</h2><p>以下关键词MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照RFC 2119 的叙述解读。（译注：为了保持语句顺畅， 以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。）</p>
<ol>
<li>使用语义化版本控制的软件“必须MUST”定义公共API。该API可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。</li>
<li>标准的版本号“必须MUST”采用XYZ的格式， 其中X、Y和Z为非负的整数，且“禁止MUST NOT”在数字前方补零。X是主版本号、Y是次版本号、而Z为修订号。每个元素“必须MUST”以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</li>
<li>标记版本号的软件发行后，“禁止MUST NOT”改变该版本软件的内容。任何修改都“必须MUST”以新版本发行。</li>
<li>主版本号为零（0.yz）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共API 不应该被视为稳定版。</li>
<li>1.0.0 的版本号用于界定公共API 的形成。这一版本之后所有的版本号更新都基于公共API 及其修改内容。</li>
<li>修订号Z（xyZ | x &gt; 0）“必须MUST”在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。</li>
<li>次版本号Y（xYz | x &gt; 0）“必须MUST”在有向下兼容的新功能出现时递增。在任何公共API的功能被标记为弃用时也“必须MUST”递增。也“可以MAY”在内部程序有大量新功能或改进被加入时递增，其中“可以MAY”包括修订级别的改变。每当次版本号递增时，修订号“必须MUST”归零。</li>
<li>主版本号X（Xyz | X &gt; 0）“必须MUST”在有任何不兼容的修改被加入公共API时递增。其中“可以MAY”包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号“必须MUST”归零。</li>
<li>先行版本号“可以MAY”被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符号来修饰。标识符号“必须MUST”由ASCII码的英数字和连接号[0-9A-Za-z-]组成，且“禁止MUST NOT”留白。数字型的标识符号“禁止MUST NOT”在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法达到兼容的需求。范例：1.0.0-alpha、1.0.0-alpha.1、 1.0.0-0.3.7、1.0.0-x.7.z.92。</li>
<li>版本编译信息“可以MAY”被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符号来修饰。标识符号“必须MUST”由ASCII的英数字和连接号[0-9A-Za-z-]组成，且“禁止MUST NOT”留白。当判断版本的优先层级时，版本编译信息“可SHOULD”被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、 1.0.0-beta+exp.sha.5114f85。</li>
<li>版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，“必须MUST”把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。由左到右依序比较每个标识符号，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级“必须MUST”透过由左到右的每个被句点分隔的标识符号来比较，直到找到一个差异值后决定：只有数字的标识符号以数值高低比较，有字母或连接号时则逐字以ASCII的排序来比较。数字的标识符号比非数字的标识符号优先层级低。若开头的标识符号都相同时，栏 位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0- rc.1 &lt; 1.0.0。</li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Version</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Wallpaper Engine 壁纸提取</title>
    <url>/2025/11/26/Wallpaper-Engine-%E5%A3%81%E7%BA%B8%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h2 id="提取步骤"><a href="#提取步骤" class="headerlink" title="提取步骤"></a>提取步骤</h2><h3 id="下载提取工具"><a href="#下载提取工具" class="headerlink" title="下载提取工具"></a>下载提取工具</h3><p>访问GitHub上的项目<a class="link"   href="https://github.com/notscuffed/repkg" >notscuffed&#x2F;repkg<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>,下载最新版本的压缩包(zip文件)并解压缩</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/wallpaper/Snipaste_2025-11-26_13-36-33.png"
                     
                ></p>
<h3 id="找到壁纸文件"><a href="#找到壁纸文件" class="headerlink" title="找到壁纸文件"></a>找到壁纸文件</h3><p>在Wallpaper Engine中,选择你想提取的壁纸,右键点击并选择”在资源管理器中打开”这将打开包含该壁纸所有文件的文件夹</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/wallpaper/Snipaste_2025-11-26_13-37-52.png"
                     
                ></p>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>找到名为scene.pkg的文件,将其复制到提取工具的文件夹中</p>
<h3 id="运行提取命令"><a href="#运行提取命令" class="headerlink" title="运行提取命令"></a>运行提取命令</h3><p>在提取工具的文件夹中,打开命令行窗口(在文件夹中按住Shift键并右键点击空白处,选择”在此处打开命令窗口”),输入以下命令：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">.\RePKG.exe extract .\scene.pkg</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/wallpaper/Snipaste_2025-11-26_13-39-09.png"
                     
                ></p>
<p>这将生成一个名为output的新文件夹,提取出的图像文件将位于该文件夹中的materials子文件夹中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/wallpaper/Snipaste_2025-11-26_13-40-39.png"
                     
                ></p>
]]></content>
      <tags>
        <tag>Wallpaper Engine</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC 概念</title>
    <url>/2026/01/09/WebRTC-%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/webrtc/webrtc7.png"
                     
                ></p>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>WebRTC 技术已经广泛在各个行业及场景中被应用，但对多数开发者来说，实时音视频及相关技术却是比较不常接触到的。</p>
<p>做为一名 Web 开发者，WebRTC 这块的概念着实花了不少时间才搞明白，一是 WebRTC 本身有较多的独有概念，二是虽然带“Web”字样，但依赖底层概念和网络却是 Web 开发很少接触到的；</p>
<p>本篇文章以 0 经验音视频开发者 视角，类比常用的 Web 技术，期望帮助您简单入门 WebRTC 技术，耐心看完本篇文章，你将：</p>
<ol>
<li>了解什么是 WebRTC</li>
<li>掌握 WebRTC 通话原理</li>
<li>利用 Chrome debug WebRTC 应用</li>
</ol>
<p>适合阅读对象：Web开发，有 js 基础，对 WebRTC 感兴趣的同学</p>
<h2 id="二、使用示例"><a href="#二、使用示例" class="headerlink" title="二、使用示例"></a>二、使用示例</h2><p>在进入正文之前，让我们先对它有个基本的印象吧！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/webrtc/webrtc0.png"
                     
                ></p>
<h2 id="三、简单介绍"><a href="#三、简单介绍" class="headerlink" title="三、简单介绍"></a>三、简单介绍</h2><p>有必要再了解一下技术的发展历史、应用场景等，这些能让我们知道它为什么优秀，哪方面优秀，有哪些缺点等。</p>
<p>程序员经常用到 5W1H 分析法，那么本文就按照这个思路给大家做一下介绍：</p>
<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>WebRTC（Web Real-Time Communication），一个可以让用户用自己流量 实现音视频实时通信的框架（APIs），支持浏览器（Firefox、Chrome、safari）以及 iOS、Android 原生系统。</p>
<h3 id="When"><a href="#When" class="headerlink" title="When"></a>When</h3><p>2017 年 12 月成为 W3C 草案，国内微信浏览器 19 年下半年才支持，国内手机自带浏览器目前还有不少兼容问题，2021 年 1 月 26 日，成为 W3C 正式标准。</p>
<h3 id="Who"><a href="#Who" class="headerlink" title="Who"></a>Who</h3><p>2011年 Google 收购多个子项目（GIPS，On2，VPx），成立了现在的 WebRTC 项目，目前是 Google 的一个开源项目。</p>
<h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><p>可应用在社交&#x2F;娱乐&#x2F;教育&#x2F;工具 等需要实时音视频高效沟通的场景，例如：最近很火的元宇宙。</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>W3C 标准，开源，插件化，整体效果佳。</p>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>也是本文重中之中，最终的目的也是让大家能知道如何使用。</p>
<p>在正式代码讲解之前，有一些概念需要先普及一下</p>
<p><strong>MediaStream：</strong> 流媒体对象，音&#x2F;视频数据的一种封装格式，挂载到 video 或 audio 标签上播放；<br><strong>RTCPeerConnection：</strong> 会话控制，网络和媒体信息收发，作用类似 http 对象；<br><strong>SDP ：</strong> 主要用于两个会话实体之间的媒体协商，作用类似 http 中的配置项。</p>
<p>结合下图类比会更容易理解：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/webrtc/webrtc2.png"
                     
                ></p>
<h2 id="四、前置思考问题"><a href="#四、前置思考问题" class="headerlink" title="四、前置思考问题"></a>四、前置思考问题</h2><p>在讲解代码前，还需要思考以下几个问题，否则会不清楚为什么代码中需要交换 SDP，cadidate等（您也可以先看完代码后，再回来看这个段落，加深理解）。</p>
<p>双方使用浏览器通信，浏览器能力，网络情况等不一致会对通信有很大影响，一起思考下下面 2 个问题：</p>
<h3 id="1、视频编码能力不一样？"><a href="#1、视频编码能力不一样？" class="headerlink" title="1、视频编码能力不一样？"></a>1、视频编码能力不一样？</h3><p>peer-A 和 peer-B 是视频互动的两边浏览器，他们通讯前必须在视频编码能力上先达成一致，如下图，最终协商出共同的H264，如果无法达成一致，则通讯失败。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/webrtc/webrtc3.png"
                     
                ></p>
<h3 id="2-电脑之间，大多数是在某个局域网中，需要-NAT（Network-Address-Translation，网络地址转换），因此并不能直接通信"><a href="#2-电脑之间，大多数是在某个局域网中，需要-NAT（Network-Address-Translation，网络地址转换），因此并不能直接通信" class="headerlink" title="2 电脑之间，大多数是在某个局域网中，需要 NAT（Network Address Translation，网络地址转换），因此并不能直接通信"></a>2 电脑之间，大多数是在某个局域网中，需要 NAT（Network Address Translation，网络地址转换），因此并不能直接通信</h3><p>显示情况如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/webrtc/webrtc4.png"
                     
                ></p>
<p>通俗一点比喻： 阿宅今年 30 了（不是我，不要乱猜）被父母逼婚，他只能求助媒婆，才可能被另一个阿宅认识。</p>
<p>媒婆解决阿宅社恐问题，NAT 也需要一种方式绕过，双方才能建立通信，我们需要用到 STUN 和 TURN。</p>
<h2 id="五、代码讲解"><a href="#五、代码讲解" class="headerlink" title="五、代码讲解"></a>五、代码讲解</h2><p>终于到我们的代码讲解部分了，下面的代码会按照推流段顺序，分阶段讲解每个步骤所需要用到的API（如果你是直接看代码，建议看完后再回去看第三、四 Part 的介绍，理解会更加深刻）。</p>
<h3 id="步骤一：创建数据源"><a href="#步骤一：创建数据源" class="headerlink" title="步骤一：创建数据源"></a>步骤一：创建数据源</h3><p>localStream 作为发送端本地预览画面：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建数据源</span></span><br><span class="line"><span class="keyword">const</span> localStream = <span class="keyword">await</span> navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(&#123;</span><br><span class="line"><span class="attr">video</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">audio</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 显示数据源，localVideo 是 html 中的 video 标签</span></span><br><span class="line">localVideo.<span class="property">srcObject</span> = localStream;</span><br></pre></td></tr></table></figure></div>

<h3 id="步骤二：创建发送数据实例"><a href="#步骤二：创建发送数据实例" class="headerlink" title="步骤二：创建发送数据实例"></a>步骤二：创建发送数据实例</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地实例</span></span><br><span class="line"><span class="keyword">const</span> pc1 = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>();</span><br><span class="line"><span class="comment">// 对端实例</span></span><br><span class="line"><span class="keyword">const</span> pc2 = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>();</span><br></pre></td></tr></table></figure></div>

<h3 id="步骤三：配置实例"><a href="#步骤三：配置实例" class="headerlink" title="步骤三：配置实例"></a>步骤三：配置实例</h3><p>做这一步的目的是为了交换两端的信息<strong>：icecandidate</strong> 和 SDP</p>
<ol>
<li>icecandidate：包含通信协议(TCP&#x2F;UDP)和通信IP，STUN和TURN协议中描述网络信息的格式规范，解决双方网络链接问题；</li>
<li>SDP：浏览器能力，包括不限于音视频编码格式，带宽，流控策略等；解决前置思考中，双方能力不匹配问题，通过交换双方 SDP 浏览器会自动选择双方都支持的视频编码格式。</li>
</ol>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 告诉对端，本端地址</span></span><br><span class="line">pc1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;icecandidate&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line"><span class="comment">// 发送给对端</span></span><br><span class="line"><span class="comment">// 对端添加本端地址</span></span><br><span class="line"><span class="keyword">if</span> (e.<span class="property">candidate</span>) &#123;</span><br><span class="line"><span class="keyword">await</span> pc2.<span class="title function_">addIceCandidate</span>(e.<span class="property">candidate</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pc2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;icecandidate&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line"><span class="comment">// 发送给本端</span></span><br><span class="line"><span class="comment">// 本端添加对端地址</span></span><br><span class="line"><span class="keyword">if</span> (e.<span class="property">candidate</span>) &#123;</span><br><span class="line"><span class="keyword">await</span> pc1.<span class="title function_">addIceCandidate</span>(e.<span class="property">candidate</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建本端SDP,告诉本端浏览器支持哪些能力</span></span><br><span class="line"><span class="keyword">const</span> offer = <span class="keyword">await</span> pc1.<span class="title function_">createOffer</span>();</span><br><span class="line">pc1.<span class="title function_">setLocalDescription</span>(offer);</span><br><span class="line"><span class="comment">// 创建远端SDP,告诉远端浏览器支持哪些能力</span></span><br><span class="line"><span class="keyword">const</span> answer = <span class="keyword">await</span> pc2.<span class="title function_">createAnswer</span>();</span><br><span class="line">pc2.<span class="title function_">setLocalDescription</span>(answer);</span><br><span class="line"><span class="comment">// 。。。。发送远端SDP给本端</span></span><br><span class="line"><span class="comment">// 接收远端sdp,告诉远端浏览器支持哪些能力</span></span><br><span class="line">pc1.<span class="title function_">setRemoteDescription</span>(answer);</span><br><span class="line"><span class="comment">// 接收客户端sdp,告诉远端浏览器支持哪些能力</span></span><br><span class="line">pc2.<span class="title function_">setRemoteDescription</span>(offer);</span><br></pre></td></tr></table></figure></div>

<h3 id="步骤四：发送数据"><a href="#步骤四：发送数据" class="headerlink" title="步骤四：发送数据"></a>步骤四：发送数据</h3><div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">localStream.<span class="title function_">getTracks</span>().<span class="title function_">forEach</span>(</span><br><span class="line"><span class="function">(<span class="params">track</span>) =&gt;</span> pc1.<span class="title function_">addTrack</span>(track, localStream)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h3 id="步骤五：完整精简版Typescript代码"><a href="#步骤五：完整精简版Typescript代码" class="headerlink" title="步骤五：完整精简版Typescript代码"></a>步骤五：完整精简版Typescript代码</h3><p>注意，这里使用的 typescript 编写，实际运行需要先转成 js。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pc1 = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>();</span><br><span class="line">pc1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;icecandidate&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (e.<span class="property">candidate</span>) &#123;</span><br><span class="line"><span class="keyword">await</span> pc2.<span class="title function_">addIceCandidate</span>(e.<span class="property">candidate</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">pc1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;iceconnectionstatechange&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pc1: iceconnectionstatechange&#x27;</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pc2 = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>();</span><br><span class="line">pc2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;icecandidate&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (e.<span class="property">candidate</span>) &#123;</span><br><span class="line"><span class="keyword">await</span> pc1.<span class="title function_">addIceCandidate</span>(e.<span class="property">candidate</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pc2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;iceconnectionstatechange&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pc2: iceconnectionstatechange&#x27;</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pc2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;track&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (e.<span class="property">streams</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">remoteVideo.<span class="property">srcObject</span> = e.<span class="property">streams</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> remoteVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#remoteVideo&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLVideoElement</span>;</span><br><span class="line"><span class="keyword">const</span> localVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#localVideo&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLVideoElement</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pushStream</span>(<span class="params">answer: RTCSessionDescriptionInit</span>) &#123;</span><br><span class="line">pc1.<span class="title function_">setRemoteDescription</span>(answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">pullStream</span>(<span class="params">offer: RTCSessionDescriptionInit</span>): <span class="title class_">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">pc2.<span class="title function_">setRemoteDescription</span>(offer);</span><br><span class="line"><span class="keyword">const</span> answer = <span class="keyword">await</span> pc2.<span class="title function_">createAnswer</span>();</span><br><span class="line">pc2.<span class="title function_">setLocalDescription</span>(answer);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;answer&#x27;</span>, answer);</span><br><span class="line"><span class="title function_">pushStream</span>(answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> localStream = <span class="keyword">await</span> navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(&#123;</span><br><span class="line"><span class="attr">video</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">audio</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">localVideo.<span class="property">srcObject</span> = localStream;</span><br><span class="line">localStream.<span class="title function_">getTracks</span>().<span class="title function_">forEach</span>(<span class="function">(<span class="params">track</span>) =&gt;</span> pc1.<span class="title function_">addTrack</span>(track, localStream));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> offer = <span class="keyword">await</span> pc1.<span class="title function_">createOffer</span>();</span><br><span class="line">pc1.<span class="title function_">setLocalDescription</span>(offer);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;pc1 offer&#x27;</span>, offer);</span><br><span class="line"><span class="title function_">pullStream</span>(offer);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="步骤六：应用举例"><a href="#步骤六：应用举例" class="headerlink" title="步骤六：应用举例"></a>步骤六：应用举例</h3><p>学习完理论知识，接下来我们一起再实践下，加深对知识的理解 —— 通过 Chrome浏览器 debug WebRTC应用。学会 debug 既可以加深理解，也是后续写代码必不可少的技能，千万不少跳过这一步哦：</p>
<ol>
<li>点击打开示例DEMO</li>
<li>另打开一个tab页面，输入: chrome:&#x2F;&#x2F;webrtc-internals&#x2F;</li>
<li>DEMO 中输入相关信息开始直播, 切回到 2 中的 tab 页面，如下图：<br> 蓝色部分：对应的是代码中SDP的处理过程<br> 绿色部分：对应的是网络链接情况<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/webrtc/webrtc5.png"
                     
                ></li>
<li>继续下来，可以看到推流中实时数据变化：<br> 蓝色部分：拉流实时数据，包括分辨率，码率，丢包率等<br> 绿色部分：推流实时数据，包括分辨率，码率，丢包率等<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/webrtc/webrtc6.png"
                     
                ><br>(Identifiers for WebRTC’s Statistics API)<br>更多字段理解，可戳这里进行深入学习： <a class="link"   href="https://www.w3.org/TR/webrtc-stats/" >Identifiers for WebRTC’s Statistics API<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ol>
<h2 id="七、结尾"><a href="#七、结尾" class="headerlink" title="七、结尾"></a>七、结尾</h2><p>随着硬件网络的更新换代，我们经历了由文字-&gt;图片-&gt;视频 载体变更的过程。随着 5G 的普及，音视频技术融于无形正在成为现实，WebRTC 作为其中最重要框架之一，浏览器的支持成熟度也在快速完善当中</p>
<p>附下作者常用的工具，推荐收藏：</p>
<ol>
<li><a class="link"   href="https://webrtc.github.io/samples/" >WebRTC samples.<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> google 官网 demo，包含最新功能</li>
<li><a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices" >MediaDevices - Web APIs | MDN<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 具体接口介绍</li>
<li><a class="link"   href="https://w3c.github.io/webrtc-pc/#bib-WEBRTC-STATS" >WebRTC 1.0: Real-Time Communication Between Browsers<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> W3C标准介绍</li>
</ol>
<hr>
<h2 id="入门补充"><a href="#入门补充" class="headerlink" title="入门补充"></a>入门补充</h2><p>下面给出一份“理论速览 + 场景落地”的 WebRTC 入门全景图，全部信息来自 2025-2026 年最新资料，方便你 10 分钟内建立知识框架。</p>
<hr>
<ol>
<li>它到底是什么</li>
</ol>
<hr>
<p>WebRTC（Web Real-Time Communication）&#x3D; 一套 <strong>由 W3C 与 IETF 联合制定的开放标准</strong> + <strong>Google 开源的音视频引擎</strong>，目标只有一句话：<br><strong>“让浏览器或移动端不装插件就能实现低延迟、加密、点对点的音视频&#x2F;数据互通。”</strong></p>
<hr>
<ol start="2">
<li>解决了哪些老问题</li>
</ol>
<hr>
<table>
<thead>
<tr>
<th>痛点</th>
<th>传统方案</th>
<th>WebRTC 解法</th>
</tr>
</thead>
<tbody><tr>
<td>需装插件&#x2F;客户端</td>
<td>Flash、SIP 软电话</td>
<td>浏览器原生 API，零安装</td>
</tr>
<tr>
<td>延迟高</td>
<td>RTMP 1-3 s</td>
<td>端到端 &lt; 500 ms，典型 100-200 ms</td>
</tr>
<tr>
<td>穿 NAT&#x2F;防火墙难</td>
<td>固定端口+中继</td>
<td>内置 ICE+STUN+TURN，自动打洞</td>
</tr>
<tr>
<td>移动端碎片化</td>
<td>各厂 SDK 不兼容</td>
<td>同一套标准，Android&#x2F;iOS&#x2F;Web 共用</td>
</tr>
<tr>
<td>数据裸奔</td>
<td>自定义协议常未加密</td>
<td>强制 SRTP+DTLS，端到端加密</td>
</tr>
</tbody></table>
<hr>
<ol start="3">
<li>三大核心概念（面试常问）</li>
</ol>
<hr>
<ol>
<li><p><strong>媒体协商</strong> —— SDP（Session Description Protocol）<br>双方互相“自我介绍”能编什么码、分辨率多少，分 Offer&#x2F;Answer 两次握手。</p>
</li>
<li><p><strong>网络协商</strong> —— ICE（Interactive Connectivity Establishment）<br>收集所有可访问地址（本地 LAN、NAT 映射后公网、TURN 中继），通过 STUN 打洞，失败就转 TURN 中继。</p>
</li>
<li><p><strong>连接抽象</strong> —— RTCPeerConnection<br>把“编解码、加密、拥塞控制、丢包重传”全部封装，开发者只需调 <code>addTrack</code>&#x2F;<code>createOffer</code> 等 6 个 API 就能建链。</p>
</li>
</ol>
<hr>
<ol start="4">
<li>适用场景（2026 主流落地）</li>
</ol>
<hr>
<ul>
<li>1 对 1 通话：Zoom Web 客户端、Google Meet、微信视频号直播连麦  </li>
<li>多人会议：SFU 架构（mediasoup、Janus）支撑 1000 人会议室  </li>
<li>云游戏：浏览器远程渲染，把手柄输入通过 DataChannel 上行  </li>
<li>物联网：Web 端直接查看家用摄像头，无需装 App  </li>
<li>文件&#x2F;屏幕共享：配合 DataChannel 走 P2P，省 30-50% 服务器带宽  </li>
<li>低延时直播：电商直播、在线教育，端到端 200 ms 内，秒杀 RTMP</li>
</ul>
<hr>
<ol start="5">
<li>业界已有“开箱即用”的实现</li>
</ol>
<hr>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>libwebrtc</strong></td>
<td>官方 C++ 库</td>
<td>Chrome&#x2F;Edge 内核同款，全功能但体积大</td>
</tr>
<tr>
<td><strong>Pion WebRTC</strong></td>
<td>Go 语言开源</td>
<td>云原生友好，二进制 20 MB，适合写 SFU 边缘节点</td>
</tr>
<tr>
<td><strong>mediasoup</strong></td>
<td>Node.js SFU</td>
<td>单进程可扛 500 路 720p，支持 SVC 分层</td>
</tr>
<tr>
<td><strong>Janus</strong></td>
<td>C 语言 SFU</td>
<td>插件架构，内置录音、SIP 网关</td>
</tr>
<tr>
<td><strong>Flutter-WebRTC</strong></td>
<td>移动端插件</td>
<td>一套代码跑 Android&#x2F;iOS，与 Web 端互通</td>
</tr>
<tr>
<td><strong>GStreamer</strong></td>
<td>多媒体框架</td>
<td>含 webrtcbin 插件，嵌入式&#x2F;机顶盒常用</td>
</tr>
</tbody></table>
<hr>
<p>一句话总结<br>WebRTC &#x3D; <strong>“浏览器里的 TCP&#x2F;IP + 编解码器 + 加密机”</strong>，把实时通信的 90% 脏活累活封装好，让你只写业务逻辑就能做出 Zoom、Discord、云游戏、远程医疗等任何“低延迟互动”产品。</p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
        <tag>Peer-to-Peer</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>WebP intro</title>
    <url>/2024/07/17/WebP-intro/</url>
    <content><![CDATA[<p>WebP 是一种现代图片格式，可为网络上的图片提供出色的无损和有损压缩。使用 WebP，网站站长和 Web 开发者可以创建更小、更丰富的图片，从而提高网页加载速度。</p>
<p>与 PNG 相比，WebP 无损图片的尺寸**缩小了 26%<strong>。WebP 有损图片比采用等效 <strong>SSIM</strong> 质量指数的同等 JPEG 图片</strong>小 25-34%**。</p>
<p>无损 WebP 支持透明度（也称为 Alpha 通道），但只需<strong>额外增加 22% 的字节</strong>。对于可以接受有损 RGB 压缩的情况，有损 WebP 也支持透明度，其文件大小通常比 PNG 小 3 倍。</p>
<p>动画 WebP 图片支持有损、无损和透明度，与 GIF 和 APNG 相比，此类图片可缩减大小。</p>
<ul>
<li><a class="link"   href="https://developers.google.com/speed/webp/faq?hl=zh-cn#how_can_i_detect_browser_support_for_webp" >面向网站站长的更多信息<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<h2 id="WebP-的关键特点"><a href="#WebP-的关键特点" class="headerlink" title="WebP 的关键特点"></a>WebP 的关键特点</h2><ol>
<li>高效的图像压缩<ul>
<li>有损压缩：WebP 的有损压缩使用现代的压缩算法，通常可以比 JPEG 更小的文件尺寸来保持类似的图像质量。</li>
<li>无损压缩：WebP 的无损压缩算法通常比 PNG 更高效，能够在不损失图像质量的情况下减少文件大小。</li>
<li>动图支持：WebP 可以用于创建动画图像，类似于 GIF，但文件大小通常比 GIF 小得多。</li>
</ul>
</li>
<li>高质量的图像<ul>
<li>支持透明度：WebP 支持 alpha 通道，允许图像具有透明区域，类似于 PNG。</li>
<li>丰富的颜色支持：WebP 支持 24 位 RGB 颜色和 8 位 alpha 通道。</li>
</ul>
</li>
<li>现代的图像格式<ul>
<li>支持现代技术：WebP 支持先进的图像压缩技术，如预测编码和变换编码。</li>
<li>较小的文件大小：通常情况下，WebP 文件比 JPEG、PNG 和 GIF 小 30% 左右。</li>
</ul>
</li>
</ol>
<h2 id="WebP-与其他图像格式的对比"><a href="#WebP-与其他图像格式的对比" class="headerlink" title="WebP 与其他图像格式的对比"></a>WebP 与其他图像格式的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>WebP</th>
<th>JPEG</th>
<th>PNG</th>
<th>GIF</th>
</tr>
</thead>
<tbody><tr>
<td><strong>压缩类型</strong></td>
<td>有损 &#x2F; 无损</td>
<td>有损</td>
<td>无损</td>
<td>有损 &#x2F; 动画</td>
</tr>
<tr>
<td><strong>文件大小</strong></td>
<td>较小</td>
<td>较大</td>
<td>较大</td>
<td>较大 &#x2F; 动画大</td>
</tr>
<tr>
<td><strong>透明度</strong></td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>动画</strong></td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>质量</strong></td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<h2 id="WebP-的应用场景"><a href="#WebP-的应用场景" class="headerlink" title="WebP 的应用场景"></a>WebP 的应用场景</h2><ul>
<li><strong>网页优化</strong>：WebP 的高压缩率使其在网页设计中非常有用，可以减少页面加载时间，提高用户体验。</li>
<li><strong>移动应用</strong>：在移动应用中使用 WebP 可以减少数据传输量，优化应用性能。</li>
<li><strong>动态图像</strong>：WebP 的动画功能使其成为 GIF 的一个高效替代品。</li>
</ul>
<h2 id="WebP-的工具和库"><a href="#WebP-的工具和库" class="headerlink" title="WebP 的工具和库"></a>WebP 的工具和库</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h3><ul>
<li>**<a class="link"   href="https://developers.google.com/speed/webp/docs/cwebp" >cwebp<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>**：将图像转换为 WebP 格式的命令行工具。</li>
<li>**<a class="link"   href="https://developers.google.com/speed/webp/docs/dwebp" >dwebp<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>**：将 WebP 图像转换为其他格式的命令行工具。</li>
<li>**<a class="link"   href="https://developers.google.com/speed/webp/download" >WebPShop<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>**：适用于 Photoshop 的 WebP 插件。</li>
</ul>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a><strong>库</strong></h3><ul>
<li>**<a class="link"   href="https://github.com/webmproject/libwebp" >WebP 官方库<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>**：支持 WebP 图像格式的开源库，包含编码和解码功能。</li>
<li>**<a class="link"   href="https://imagemagick.org/" >ImageMagick<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>**：支持 WebP 格式的图像处理库。</li>
</ul>
<h2 id="WebP-的工作原理"><a href="#WebP-的工作原理" class="headerlink" title="WebP 的工作原理"></a>WebP 的工作原理</h2><p>有损 WebP 压缩使用预测编码对图片进行编码，这与 VP8 视频编解码器压缩视频中的关键帧的方法相同。预测编码使用相邻像素块中的值来预测块中的值，然后仅对差值进行编码。</p>
<p>无损 WebP 压缩使用已发现的图像片段来精确重建新像素。如果没有找到有趣的匹配项，它还可以使用本地调色板。</p>
<ul>
<li><a class="link"   href="https://developers.google.com/speed/webp/docs/compression?hl=zh-cn" >WebP 压缩技术详情<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>WebP 文件由 VP8 或 VP8L 图片数据以及一个基于 RIFF 的容器组成。独立的 libwebp 库可用作 WebP 规范的参考实现，可以从我们的 Git 代码库或 tarball 获取。</p>
<h3 id="WebP-格式的技术细节"><a href="#WebP-格式的技术细节" class="headerlink" title="WebP 格式的技术细节"></a>WebP 格式的技术细节</h3><h4 id="1-有损压缩"><a href="#1-有损压缩" class="headerlink" title="1. 有损压缩"></a><strong>1. 有损压缩</strong></h4><p>WebP 的有损压缩基于 VP8 视频编解码器中的技术：</p>
<ul>
<li><strong>预测编码</strong>：使用邻近像素的颜色信息来预测当前像素的颜色。</li>
<li><strong>变换编码</strong>：对像素数据进行离散余弦变换（DCT），以降低数据冗余。</li>
</ul>
<h4 id="2-无损压缩"><a href="#2-无损压缩" class="headerlink" title="2. 无损压缩"></a><strong>2. 无损压缩</strong></h4><p>WebP 的无损压缩技术基于 WebM 项目中的技术：</p>
<ul>
<li><strong>字典压缩</strong>：使用哈夫曼编码和算术编码技术来优化压缩效率。</li>
<li><strong>透明度处理</strong>：支持 8 位的 alpha 通道来处理图像的透明部分。</li>
</ul>
<h4 id="3-动画功能"><a href="#3-动画功能" class="headerlink" title="3. 动画功能"></a><strong>3. 动画功能</strong></h4><p>WebP 的动画功能：</p>
<ul>
<li><strong>时间控制</strong>：支持设置帧的显示时间，以创建动画效果。</li>
<li><strong>压缩优化</strong>：使用现代算法减少动画帧的重复数据。</li>
</ul>
<h2 id="WebP-支持"><a href="#WebP-支持" class="headerlink" title="WebP 支持"></a>WebP 支持</h2><p><code>Google Chrome</code> 、<code>Safari</code> 、<code>Firefox</code> 、<code>Edge</code> 、<code>Opera</code> 浏览器以及许多其他工具和软件库就原生支持 WebP。开发者还增加了对各种图片编辑工具的支持。</p>
<p>WebP 包含轻量级编码和解码库 libwebp、用于将图片与 WebP 格式相互转换的命令行工具 cwebp 和 dwebp，以及用于查看 WebP 图片、对图片进行多路复用并为其添加动画效果的工具。完整的源代码可在下载页面找到。</p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>支持情况</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Google Chrome</strong></td>
<td>完全支持</td>
</tr>
<tr>
<td><strong>Mozilla Firefox</strong></td>
<td>完全支持</td>
</tr>
<tr>
<td><strong>Safari</strong></td>
<td>从 macOS 11 和 iOS 14 起支持</td>
</tr>
<tr>
<td><strong>Microsoft Edge</strong></td>
<td>完全支持</td>
</tr>
<tr>
<td><strong>Opera</strong></td>
<td>完全支持</td>
</tr>
<tr>
<td><strong>Internet Explorer</strong></td>
<td>不支持</td>
</tr>
</tbody></table>
<h2 id="WebP-转换器下载"><a href="#WebP-转换器下载" class="headerlink" title="WebP 转换器下载"></a>WebP 转换器下载</h2><p>下载适用于 <a class="link"   href="https://developers.google.com/speed/webp/docs/precompiled?hl=zh-cn" >Linux、Windows 或 macOS<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 的预编译 cwebp 转换工具，将您喜爱的图片集从 PNG 和 JPEG 格式转换为 WebP 格式。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a class="link"   href="https://developers.google.com/speed/webp?hl=zh-cn" >一种适用于网络的图片格式<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://developers.google.com/speed/webp" >WebP 官方文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://developers.google.com/speed/webp/docs/tech" >WebP 技术详解<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://developers.google.com/speed/webp/download" >WebP 插件下载<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Tools</category>
        <category>Image</category>
      </categories>
      <tags>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 环境ZSH 安装 oh-my-zsh</title>
    <url>/2025/11/27/Windows-%E7%8E%AF%E5%A2%83ZSH-%E5%AE%89%E8%A3%85-oh-my-zsh/</url>
    <content><![CDATA[<h2 id="安装-oh-my-zsh-与常用插件"><a href="#安装-oh-my-zsh-与常用插件" class="headerlink" title="安装 oh-my-zsh 与常用插件"></a>安装 oh-my-zsh 与常用插件</h2><ol>
<li><p>一条命令装 oh-my-zsh  </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>装插件(示例)  </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></div>

<p>把插件名加到 <code>~/.zshrc</code> 的 <code>plugins=(git zsh-autosuggestions zsh-syntax-highlighting)</code> 一行,再 <code>source ~/.zshrc</code></p>
</li>
</ol>
<h2 id="可选-Powerlevel10k-主题"><a href="#可选-Powerlevel10k-主题" class="headerlink" title="(可选)Powerlevel10k 主题"></a>(可选)Powerlevel10k 主题</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure></div>

<p>编辑 <code>~/.zshrc</code>  </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>重新打开 Git Bash 会进入 p10k 配置向导,按提示选样式即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/terminal/Snipaste_2025-11-27_15-39-26.png"
                     
                ></p>
]]></content>
      <categories>
        <category>Terminal</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 环境Git bash 安装ZSH</title>
    <url>/2025/11/27/Windows-%E7%8E%AF%E5%A2%83Git-bash-%E5%AE%89%E8%A3%85ZSH/</url>
    <content><![CDATA[<blockquote>
<p>在 Windows 的 Git Bash 里“装” zsh 实际上就是把 MSYS2 提供的 zsh 可执行文件和相关依赖解压到 Git 安装目录,再把 Git Bash 的默认 shell 切到 zsh 即可 下面给出 2025 年仍验证可行的最小步骤,全部操作无需额外安装 MSYS2 完整环境</p>
</blockquote>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol>
<li>已装 Git for Windows(默认路径 <code>C:\Program Files\Git</code>)</li>
<li>建议先装一款 Nerd Font(后面 oh-my-zsh &#x2F; powerlevel10k 图标不会乱码)<br>下载地址：<a class="link"   href="https://www.nerdfonts.com/font-downloads" >https://www.nerdfonts.com/font-downloads<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ol>
<h3 id="下载并解压-zsh"><a href="#下载并解压-zsh" class="headerlink" title="下载并解压 zsh"></a>下载并解压 zsh</h3><ol>
<li>打开 <a class="link"   href="https://packages.msys2.org/package/zsh?repo=msys&variant=x86_64" >https://packages.msys2.org/package/zsh?repo=msys&amp;variant=x86_64<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>选一个较新的构建,例如<br><code>zsh-5.9-2-x86_64.pkg.tar.zst</code>   </li>
<li>用能解压 <code>*.zst</code> 的工具(PeaZip &#x2F; 7-Zip 21+ &#x2F; WinRAR 6.2+)把包解开<br>得到两个文件夹：<code>etc</code> 和 <code>usr</code></li>
<li>把这两个文件夹直接复制到<br><code>C:\Program Files\Git</code><br>遇到文件冲突时选“覆盖”即可,不会破坏 Git 原有功能</li>
</ol>
<h3 id="首次启动并生成默认配置"><a href="#首次启动并生成默认配置" class="headerlink" title="首次启动并生成默认配置"></a>首次启动并生成默认配置</h3><ol>
<li>打开 Git Bash,执行  <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">zsh</span><br></pre></td></tr></table></figure></div>
第一次会进入 zsh 新用户配置向导,按提示选 1 2 3 或直接 q 退出</li>
<li>完成后退出 Git Bash 再重新打开,确认能正常进入 zsh</li>
</ol>
<h3 id="可选-把-zsh-设为-Git-Bash-默认-shell"><a href="#可选-把-zsh-设为-Git-Bash-默认-shell" class="headerlink" title="(可选)把 zsh 设为 Git Bash 默认 shell"></a>(可选)把 zsh 设为 Git Bash 默认 shell</h3><p>不想每次手动敲 <code>zsh</code>,就在 <code>~/.bashrc</code> 末尾加一段自动跳转：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.bashrc</span></span><br><span class="line"><span class="keyword">if</span> [ -t 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exec</span> zsh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>保存后重启 Git Bash,即默认进入 zsh</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/terminal/_20251127144715_105_18.png"
                     
                ></p>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><h4 id="输入-zsh-无反应"><a href="#输入-zsh-无反应" class="headerlink" title="输入 zsh 无反应"></a>输入 zsh 无反应</h4><ol>
<li><p>先确认 <code>zsh.exe</code> 真的存在<br>在 Git Bash 里执行  </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> <span class="string">&quot;/c/Program Files/Git/usr/bin/zsh.exe&quot;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果提示 <strong>No such file</strong> → 你第二步解压&#x2F;复制时漏了,把 <code>usr/bin/zsh.exe</code> 重新拷进去即可</li>
<li>如果文件存在 → 继续第 2 步</li>
</ul>
</li>
<li><p>确认 PATH 能搜得到  </p>
<p>Git Bash 启动时会把自己的 <code>/usr/bin</code> 附加到 PATH,理论上不需要手动加；但如果你改过 Windows 环境变量或者装过 scoop&#x2F;choco 之类,可能把别的同名目录顶到前面<br>在 Git Bash 执行  </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> zsh          <span class="comment"># 应该返回 /usr/bin/zsh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span> | <span class="built_in">tr</span> <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;\n&#x27;</span> | grep -i zsh</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果 <code>which</code> 什么都不输出,说明 PATH 里根本没有；  </li>
<li>如果输出的是 <strong>&#x2F;c&#x2F;WINDOWS&#x2F;system32&#x2F;zsh</strong> 之类不存在的路径,也是找不到</li>
</ul>
<p>解决：临时把 Git 自带的目录强制放到最前面,在 <code>~/.bashrc</code> 顶部加一行  </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/c/Program Files/Git/usr/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>保存后重开 Git Bash,再试 <code>zsh</code></p>
</li>
<li><p>依赖 DLL 缺失(极少见)<br>双击 <code>C:\Program Files\Git\usr\bin\zsh.exe</code> 如果弹出 “<strong>无法找到 msys-2.0.dll</strong>” 等提示,说明你还缺 MSYS2 运行库<br>把下面两个包同样下载→解压→覆盖到 Git 根目录即可(同第 2 步操作)：  </p>
<ul>
<li>msys2-runtime-3.4.x-xxxx-x86_64.pkg.tar.zst  </li>
<li>ncurses-6.4-xxxx-x86_64.pkg.tar.zst<br>下载地址还是 <a class="link"   href="https://packages.msys2.org/base/msys2-runtime" >https://packages.msys2.org/base/msys2-runtime<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 和 &#x2F;base&#x2F;ncurses</li>
</ul>
</li>
<li><p>64 位 &#x2F; 32 位搞错<br>如果你装的是 <strong>32 位 Git for Windows</strong>,却下载了 <strong>x86_64</strong> 的 zsh 包,也会闪退<br>确认位数：  </p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$MSYSTEM</span>        <span class="comment"># 看到 MINGW32 说明是 32 位</span></span><br></pre></td></tr></table></figure></div>

<p>如果是 MINGW32,请回到 MSYS2 官网下载 <strong>i686</strong> 版本的 zsh 包重新覆盖</p>
</li>
<li><p>防病毒&#x2F;公司策略拦截<br>某些 AV 会把 <code>zsh.exe</code> 当外来程序直接拦截,日志里却没有任何提示<br>临时把 <code>C:\Program Files\Git\usr\bin\zsh.exe</code> 加入白名单,或者关掉 AV 再试一次即可验证</p>
</li>
</ol>
<h3 id="缺失依赖下载"><a href="#缺失依赖下载" class="headerlink" title="缺失依赖下载"></a>缺失依赖下载</h3><h4 id="“zsh-exe-无法找到入口”"><a href="#“zsh-exe-无法找到入口”" class="headerlink" title="“zsh.exe - 无法找到入口”"></a>“zsh.exe - 无法找到入口”</h4><p>dll 版本太旧<br>你下的 <code>zsh-5.9-...pkg.tar.zst</code> 包里带的 <code>msys-zsh-5.9.dll</code> 是 2023 年以后的版本,需要同版本 <code>msys2-runtime</code>(也就是 <code>msys-2.0.dll</code>)里导出 setproctitle 符号<br>而 Git for Windows 自带的 runtime 还是 2022 年甚至更老,没有 setproctitle,于是加载时报入口缺失</p>
<blockquote>
<p>把 msys2-runtime、ncurses、zsh 三个包同时更新成 2023+ 同批次(x86_64 或 i686 统一),一起解压到 Git 根目录</p>
</blockquote>
<ol>
<li>打开 <a class="link"   href="https://packages.msys2.org/package/zsh" >https://packages.msys2.org/package/zsh<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br> 选 zsh-5.9-2-x86_64.pkg.tar.zst(2023-12-15 构建)</li>
<li>同页 Dependencies 里把<br> <code>msys2-runtime-3.4.9-2-x86_64.pkg.tar.zst</code><br> <code>ncurses-6.4-1-x86_64.pkg.tar.zst</code><br> 也下载下来</li>
<li>三个包一起解压,得到 <code>usr/bin/*.dll</code> 等文件,全部覆盖到<br> <code>C:\Program Files\Git</code><br> (遇到冲突选“替换”)</li>
<li>重新打开 Git Bash → zsh 即可正常进入,弹窗消失</li>
</ol>
<blockquote>
<p><code>Dependencies 里没有 msys2-runtime</code><br><code>msys2-runtime</code> 属于 “底层 C 运行库”,MSYS2 官网把它单独放在 <code>msys</code> 仓库而不是 <code>mingw64/mingw32</code>,所以在 zsh 页面是看不到的<br>打开 <a class="link"   href="https://packages.msys2.org/package/msys2-runtime?repo=msys&variant=x86_64" >https://packages.msys2.org/package/msys2-runtime?repo=msys&amp;variant=x86_64<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Terminal</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 环境ZSH 安装 zsh-autosuggestions 插件</title>
    <url>/2025/11/27/Windows-%E7%8E%AF%E5%A2%83ZSH-%E5%AE%89%E8%A3%85-zsh-autosuggestions-%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>zsh-autosuggestions 是一个命令提示插件, 自动推测你可能需要输入的命令,按右键可以快速采用建议</p>
</blockquote>
<h3 id="安装-zsh-autosuggestions-插件"><a href="#安装-zsh-autosuggestions-插件" class="headerlink" title="安装 zsh-autosuggestions 插件"></a>安装 zsh-autosuggestions 插件</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></div>

<h3 id="启用插件"><a href="#启用插件" class="headerlink" title="启用插件"></a>启用插件</h3><p>编辑 <code>~/.zshrc</code> 文件, 找到 <code>plugins</code> 行, 添加 <code>zsh-autosuggestions</code> 插件</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">    git</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/terminal/Snipaste_2025-11-27_15-46-13.png"
                     
                ></p>
]]></content>
      <categories>
        <category>Terminal</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/02/09/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Hello World</p>
</blockquote>

  <div class="note p-4 mb-4 rounded-small markdown-body primary">
    <p>笔记</p>

  </div>
]]></content>
  </entry>
  <entry>
    <title>npm 后台运行脚本</title>
    <url>/2024/07/09/npm-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>在 Windows 系统上，如果你想要通过 npm 运行脚本并且让其在后台运行，可以借助一些工具或命令来实现。以下是几种常见的方法：</p>
<h3 id="1-使用-npm-命令"><a href="#1-使用-npm-命令" class="headerlink" title="1. 使用 npm 命令"></a>1. 使用 <code>npm</code> 命令</h3><p>通常情况下，<code>npm</code> 命令运行脚本时会在当前命令行窗口中执行，并且不会自动后台运行。但可以通过以下方法尝试：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm run your-script-name &amp;</span><br></pre></td></tr></table></figure></div>

<p>在 Windows 中，<code>&amp;</code> 符号可以用来将命令放入后台运行。请注意，某些 npm 脚本可能会要求特定的终端支持。</p>
<h3 id="2-使用-start-命令"><a href="#2-使用-start-命令" class="headerlink" title="2. 使用 start 命令"></a>2. 使用 <code>start</code> 命令</h3><p>在 Windows 中，<code>start</code> 命令可以启动一个新的命令行窗口并执行命令，允许命令在后台运行。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">start npm run your-script-name</span><br></pre></td></tr></table></figure></div>

<p>这将在一个新的命令行窗口中启动 npm 脚本，并使其在后台运行。</p>
<h3 id="3-使用第三方工具"><a href="#3-使用第三方工具" class="headerlink" title="3. 使用第三方工具"></a>3. 使用第三方工具</h3><p>如果以上方法无法满足需求，可以考虑使用第三方工具来将 npm 脚本或任何命令行进程后台运行，例如：</p>
<ul>
<li><p><strong><code>pm2</code></strong>: 是一个强大的进程管理工具，可以用来管理和监控 Node.js 应用程序，也可以用来运行 npm 脚本，并且支持后台运行。</p>
  <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span><br><span class="line">pm2 start npm -- run your-script-name</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>screen</code></strong>: 是一个在 Unix 和类 Unix 系统上运行命令的工具，但也有 Windows 版本或类似工具。它可以创建和管理多个虚拟控制台，并且可以在其中运行命令并将其保持在后台运行。</p>
</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>在使用 <code>start</code> 命令或其他工具时，可能需要根据具体的 npm 脚本和环境进行适当的调整和配置。</li>
<li>在后台运行命令时，要确保能够方便地查看输出和管理进程。</li>
<li>对于长期运行的服务或进程，建议使用专门的进程管理工具，以便进行监控和管理。</li>
</ul>
<p>选择合适的方法取决于你的具体需求和环境。</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>NPM</category>
      </categories>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title>webp 转换工具 cwebp</title>
    <url>/2024/07/01/webp-%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7-cwebp/</url>
    <content><![CDATA[<blockquote>
<p>webp是Google推出的一种新式图片格式、相比于常用的jpg、png和gif格式，最大的优势就是同等质量下压缩率更高、图片文件更小、利于节约存储空间和网络带宽。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a class="link"   href="https://storage.googleapis.com/downloads.webmproject.org/releases/webp/index.html" >cwebp<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>下载完成后解压至某个路径下,然后将其中的<code>bin</code>目录路径添加至环境变量<code>path</code>下即可</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">cwebp -version</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">1.4.0</span><br><span class="line">libsharpyuv: 0.4.0</span><br></pre></td></tr></table></figure></div>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">cwebp input.png -o output.webp</span><br></pre></td></tr></table></figure></div>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">680K -rw-r--r-- 1 Windows 197121 677K  7月  1 09:52  maven.png</span><br><span class="line"> 36K -rw-r--r-- 1 Windows 197121  34K  7月  1 10:21  maven.webp</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Program</category>
        <category>Tools</category>
        <category>Image</category>
      </categories>
      <tags>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title>不用很麻烦很累的CodeReview入门</title>
    <url>/2024/06/22/%E4%B8%8D%E7%94%A8%E5%BE%88%E9%BA%BB%E7%83%A6%E5%BE%88%E7%B4%AF%E7%9A%84CodeReview%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/code/code1.png"
                     
                ></p>
<blockquote>
<p>注：本文仅关注 Code Review 的实行，不讨论 “为什么要 Code Review” 或 “Code Review 是否有价值” 这类话题。</p>
</blockquote>
<p>通过 Code Review 来保证项目代码质量、提高团队的技术水平，已经是很多公司的常规操作，大多数人也已经认可了进行 Code Review 的必要性。然而，现实是这样的：</p>
<p>”伴随着号召和口号，大家热情高涨，一顿操作花式输出，目指用洞察世界的双眼来拯救这个腐朽的Repo，而待多巴胺褪去，热情难以为继，全都恢复成了没有感情的 Coder，三天打鱼两天晒网，再到最后完全流于形式，直至热情再一次被唤醒……“</p>
<p>陷入循环中，我们不禁要呐喊：</p>
<h2 id="“为什么Code-Review这么麻烦这么累”"><a href="#“为什么Code-Review这么麻烦这么累”" class="headerlink" title="“为什么Code Review这么麻烦这么累”"></a>“为什么Code Review这么麻烦这么累”</h2><h3 id="1-错的不是我，是这个PR"><a href="#1-错的不是我，是这个PR" class="headerlink" title="1. 错的不是我，是这个PR"></a>1. 错的不是我，是这个PR</h3><p>Code Review 会让人觉得麻烦、代码看起来很累，很多情况下确实是因为这个 PR 并不易于 Review，本身存在一些问题：</p>
<ul>
<li>PR 太大：动辄几千行代码、几十个文件修改，打开一看就怕了怕了，没有做好心理建设、没有两三个小时的空闲时间谁敢 Review，告辞告辞；</li>
<li>PR 要做事的太多：东边儿全局修改了变量名，西边儿重构了公用方法，南边儿调整了页面样式，北边儿还顺便修了一个陈年老 bug……嚯，好家伙，一个迭代的需求一个 PR 就提上来了，也就 Author 勉强在当天还能搞清楚哪段是哪段，Reviewer 一路看下来就得怀疑人生；</li>
<li>PR 没有上下文：“为什么要删除这段代码？为什么要加这么多分支逻辑？这么多类似的方法真的是必须的吗？这种场景没有判断，是遗漏了还是业务需求？”你是否有很多问号？？？总会有很多问题，在缺乏上下文时，是很难给出解答的，不写任何 Description，想要让 Reviewer 自己主动去搞清楚业务背景实在是不厚道，所以也别怪没人肯 Review 了；</li>
<li>PR 代码质量太差：不遵守既定规范、格式乱七八糟、命名天马行空、逻辑晦涩难懂，整篇代码毫无“可读性”可言，对于这种 PR，Review 两眼是情分，直接Request Change才是本分。</li>
</ul>
<h3 id="2-即使我有错，也是有原因的"><a href="#2-即使我有错，也是有原因的" class="headerlink" title="2. 即使我有错，也是有原因的"></a>2. 即使我有错，也是有原因的</h3><p>如果，PR 确实不存在问题，代码整洁、逻辑清晰，Description 安排地明明白白，却还是没能得到回应，那的确应该是 Reviewer 的问题，不过为他们考虑考虑，可能也是有原因的：</p>
<ul>
<li>工作量过于饱和：再简洁明了的 PR，Review 起来还是需要时间的，忙得已经没有喝水的时间，哪还有工夫去做 Code Review；</li>
<li>道不同不相为谋：你有你的原则，我有我的风格，既然谁也说服不了谁，那就这样吧；</li>
<li>技术领域不同：“我说另请高明吧，我实在也不是谦虚，我一个后端开发怎么就点进前端PR了呢？”；</li>
<li>看不出问题：虽然说起来有点尴尬，但确实是一个很普遍的情况，没有掌握方法、相关技术储备不足、Review 角度不同等等，一篇 PR 读下来，似乎觉得哪里不对，又似乎也有道理，Comment 憋不出来、Approve 又不放心，那就跳过跳过，等其他大牛出手吧。</li>
</ul>
<p>那么，有这么多严峻的问题存在，你看，我们还有机会吗？</p>
<p>问得好！还记得文章的标题吗：</p>
<h2 id="“我们不用很麻烦很累就可以-Code-Review”"><a href="#“我们不用很麻烦很累就可以-Code-Review”" class="headerlink" title="“我们不用很麻烦很累就可以 Code Review”"></a>“我们不用很麻烦很累就可以 Code Review”</h2><h3 id="1-作为-Author"><a href="#1-作为-Author" class="headerlink" title="1. 作为 Author"></a>1. 作为 Author</h3><ul>
<li>PR 尽可能小<ul>
<li>创建 Draft PR：便于获得早期反馈，避免在代码成型后出现大规模的修改返工</li>
<li>PR 只关注一件事：降低阅读 PR 时的认知成本、更易于确定合理的 Assignee、Rollback 的可行性更高、开发更具计划性</li>
<li>严格执行 Rebase：避免引入不必要的修改或造成 Review 的返工</li>
</ul>
</li>
<li>添加关键的上下文<ul>
<li>不可缺少的 Description（必要时可尝试使用Github PR template辅助规范化），可以主要关注以下几点：<ul>
<li>这段代码改动的目的是？（通常情况下提供需求 Ticket 标题及链接即可）</li>
<li>能预料可能会提出的问题，请提前说明（如存在多种近似解决方案，选择当前方案的原因）</li>
<li>（若存在）特定逻辑需要特定 Reviewer 关注，请提前说明</li>
<li>（若存在）批量修改，请提前说明</li>
<li>（若存在）UI 修改，请提供屏幕截图或可查看到实际效果的链接</li>
</ul>
</li>
<li>易于理解的 Commit Message，严厉抵制 ”fix bug“ 这种偷懒 message</li>
<li>代码中添加必要的注释</li>
</ul>
</li>
<li>Assign给正确的人<ul>
<li>Assign组内成员</li>
<li>期望能给出反馈的人:<ul>
<li>擅长&#x2F;熟识该业务领域的人；</li>
<li>擅长&#x2F;熟识该技术领域的人；</li>
</ul>
</li>
<li>期望能知晓该 PR 的人：<ul>
<li>会受到该代码改动影响的人；</li>
<li>近期正在学习该业务&#x2F;技术领域的人；</li>
</ul>
</li>
</ul>
</li>
<li>收到Comment及时跟进<ul>
<li>修改后及时回复 comment 或 refresh assignee，不要指望其他人能一直蹲守你的更新或修改</li>
<li>出现意见分歧，避免过度依赖 Comment 交流，线下沟通优先，其次是 IM</li>
<li>若因时间或计划问题无法在当前 PR 中完成修改，达成一致后创建 Tech Debt Ticket 备忘</li>
<li>尽可能避免在已经Approve的PR上进行无关修改，以免给Reviewer造成不必要的重复工作</li>
</ul>
</li>
</ul>
<p>一句话总结：对自己提出的每一个 PR 负责</p>
<h3 id="2-作为Reviewer"><a href="#2-作为Reviewer" class="headerlink" title="2. 作为Reviewer"></a>2. 作为Reviewer</h3><ul>
<li>主动阅读 Description<ul>
<li>作为普通 Reviewer，有必要了解 PR 的上下文</li>
<li>作为业务&#x2F;技术领域相关者，有必要了解代码及逻辑变更情况</li>
</ul>
</li>
<li>得当的 Comment<ul>
<li>表述简洁清晰无歧义</li>
<li>通常应具有目的性：明确知道自己想要的回复是哪一种，是希望 Author 改正问题？补充上下文？解答疑惑？或是说明计划？目的不明的 Comment 只会造成不必要的反复沟通</li>
<li>不仅可以指出问题，同样可以请教问题</li>
<li>给出肯定或表扬的 Comment</li>
<li>无需过于正式：Comment 的数量并不会用于反映工作量，因而任何形式不会对双方工作造成影响的 Comment 都是可行且值得鼓励的</li>
</ul>
</li>
<li>Comment 后及时跟进<ul>
<li>及时回复 Author 的追问</li>
<li>Author 修改后及时 Resolve 或 Approve</li>
</ul>
</li>
<li>及时给出反馈<ul>
<li>根据实际情况，给出 Approve，Comment 或 Request Change</li>
<li>谨慎给出 Approve：Review 代码后，若有足够把握，可以给出 Approve；若存在疑虑（不了解相关业务、底层逻辑），也应给出 Comment 表明 Review 完成，不应让 Author 无止尽的空等</li>
</ul>
</li>
<li>不要成为 Blocker<ul>
<li>仅有的 Repo Code Owner、点名指定的 Reviewer（业务&#x2F;技术领域相关者），必须要给出反馈</li>
<li>Request Change 的 Reviewer，必须要即使跟进</li>
</ul>
</li>
</ul>
<p>一句话总结：对自己给出的每一个 Comment 和 Approve 负责</p>
<h3 id="3-参与者应有的共识"><a href="#3-参与者应有的共识" class="headerlink" title="3. 参与者应有的共识"></a>3. 参与者应有的共识</h3><ul>
<li>Code Review 的主要目的不应是为了发现 Bug，也不应是为了检查代码风格和规范</li>
<li>Code Review 是沟通的一种形式，作用是相互的</li>
<li>Code Review 时不要吝啬你的赞美之词</li>
<li>Code Review 时不可固执己见</li>
<li>Code Review 时应正面且友善</li>
</ul>
<p>最后，</p>
<h2 id="还有几句要说："><a href="#还有几句要说：" class="headerlink" title="还有几句要说："></a>还有几句要说：</h2><p>看到这儿大家应该都能感觉到，Author 要做的事情和 Reviewer 要做的事情基本都是相辅相成，两边缺一不可，说到底，推动 Code Review 需要整个 Team 甚至公司一起努力，但需要努力，并不意味着“不用很麻烦很累”是 Fake News，只要 Code Review 成为公司的一种文化、一种习惯，所有的一切都会变得理所当然，且有趣。</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CodeReview</tag>
        <tag>代码质量</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2017/04/03/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<blockquote>
<p>为什么会存在十六进制并且广泛使用？</p>
</blockquote>
<p>我的理解是十进制描述的是纯数值型，十六进制是标称型+数值型，标称型用于处理状态机。人有十个手指，这可能是十进制最早起源的原因，但是无法表示状态。我们如何记录正负，甚至是虚数、复数。如果不加入额外标识无法表示吧，那机器呢，他可是只能运算二进制信号，所以最合适的描述载体有两个必要条件：</p>
<ol>
<li>二的直系等比倍数；</li>
<li>大于十并且越小越好。</li>
</ol>
<p>那么十六是最合适的选择。</p>
<hr>
<blockquote>
<p>计算机通信的基本原理是将电信号转换为逻辑信号，其转换方式是将高低电频表示为二进制数中的1和0, 再通过不同的二进制序列来表示所有的信息。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">Pascal语言</th>
<th align="center">C语言</th>
<th align="center">Java</th>
<th align="center">Scala</th>
<th align="center">Python</th>
</tr>
</thead>
<tbody><tr>
<td align="center">按位与</td>
<td align="center">a and b</td>
<td align="center">a &amp; b</td>
<td align="center">a &amp; b</td>
<td align="center">a &amp; b</td>
<td align="center">a &amp; b</td>
</tr>
<tr>
<td align="center">按位或</td>
<td align="center">a or b</td>
<td align="center">a &brvbar; b</td>
<td align="center">a &brvbar; b</td>
<td align="center">a &brvbar; b</td>
<td align="center">a &brvbar; b</td>
</tr>
<tr>
<td align="center">按位异或</td>
<td align="center">a xor b</td>
<td align="center">a ^ b</td>
<td align="center">a ^ b</td>
<td align="center">a ^ b</td>
<td align="center">a ^ b</td>
</tr>
<tr>
<td align="center">按位取反</td>
<td align="center">not a</td>
<td align="center">~a</td>
<td align="center">~a</td>
<td align="center">~a</td>
<td align="center">~a</td>
</tr>
<tr>
<td align="center">左移</td>
<td align="center">a shl b</td>
<td align="center">a &lt;&lt; b</td>
<td align="center">a &lt;&lt; b</td>
<td align="center">a &lt;&lt; b</td>
<td align="center">a &lt;&lt; b</td>
</tr>
<tr>
<td align="center">带符号右移</td>
<td align="center">a shr b</td>
<td align="center">a &gt;&gt; b</td>
<td align="center">a &gt;&gt; b</td>
<td align="center">a &gt;&gt; b</td>
<td align="center">a &gt;&gt; b</td>
</tr>
<tr>
<td align="center">无符号右移</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">a &gt;&gt;&gt; b</td>
<td align="center">a &gt;&gt;&gt; b</td>
<td align="center">a &gt;&gt;&gt; b</td>
</tr>
</tbody></table>
<h1 id="BIN-OCT-HEX-DEC"><a href="#BIN-OCT-HEX-DEC" class="headerlink" title="BIN_OCT_HEX_DEC"></a>BIN_OCT_HEX_DEC</h1><ul>
<li><p>BIN : binary 二进制</p>
</li>
<li><p>OCT : octal 八进制</p>
</li>
<li><p>DEC : decimal 十进制</p>
</li>
<li><p>HEX : hexadecimal 十六进制</p>
<p>  位运算基于二进制</p>
</li>
</ul>
<h1 id="与-and运算"><a href="#与-and运算" class="headerlink" title="与 and运算 &amp;"></a>与 and运算 &amp;</h1><blockquote>
<p>同位同为1结果为1</p>
</blockquote>
<h3 id="5-3"><a href="#5-3" class="headerlink" title="5 &amp; 3"></a>5 &amp; 3</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">5</td>
<td align="center">0101</td>
</tr>
<tr>
<td align="center">数二</td>
<td align="center">3</td>
<td align="center">0011</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">1</td>
<td align="center">0001</td>
</tr>
</tbody></table>
<h3 id="4-1"><a href="#4-1" class="headerlink" title="4 &amp; 1"></a>4 &amp; 1</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">4</td>
<td align="center">0100</td>
</tr>
<tr>
<td align="center">数二</td>
<td align="center">1</td>
<td align="center">0001</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">0</td>
<td align="center">0000</td>
</tr>
</tbody></table>
<h1 id="或-or运算"><a href="#或-or运算" class="headerlink" title="或 or运算 |"></a>或 or运算 |</h1><blockquote>
<p>同位存在1结果为1</p>
</blockquote>
<h3 id="5-3-1"><a href="#5-3-1" class="headerlink" title="5 | 3"></a>5 | 3</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">5</td>
<td align="center">0101</td>
</tr>
<tr>
<td align="center">数二</td>
<td align="center">3</td>
<td align="center">0011</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">7</td>
<td align="center">0111</td>
</tr>
</tbody></table>
<h3 id="10-5"><a href="#10-5" class="headerlink" title="10 | 5"></a>10 | 5</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">2</td>
<td align="center">0010</td>
</tr>
<tr>
<td align="center">数二</td>
<td align="center">5</td>
<td align="center">0101</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">7</td>
<td align="center">0111</td>
</tr>
</tbody></table>
<h1 id="异或-xor运算"><a href="#异或-xor运算" class="headerlink" title="异或 xor运算 ^"></a>异或 xor运算 ^</h1><blockquote>
<p>同位不同结果为1</p>
</blockquote>
<h3 id="5-3-2"><a href="#5-3-2" class="headerlink" title="5 ^ 3"></a>5 ^ 3</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">5</td>
<td align="center">0101</td>
</tr>
<tr>
<td align="center">数二</td>
<td align="center">3</td>
<td align="center">0011</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">6</td>
<td align="center">0110</td>
</tr>
</tbody></table>
<h3 id="10-5-1"><a href="#10-5-1" class="headerlink" title="10 ^ 5"></a>10 ^ 5</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">2</td>
<td align="center">0010</td>
</tr>
<tr>
<td align="center">数二</td>
<td align="center">5</td>
<td align="center">0101</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">7</td>
<td align="center">0111</td>
</tr>
</tbody></table>
<h3 id="10-10"><a href="#10-10" class="headerlink" title="10 ^ 10"></a>10 ^ 10</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">7</td>
<td align="center">0111</td>
</tr>
<tr>
<td align="center">数二</td>
<td align="center">7</td>
<td align="center">0111</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">0</td>
<td align="center">0000</td>
</tr>
</tbody></table>
<h1 id="非-not运算"><a href="#非-not运算" class="headerlink" title="非 not运算 ~"></a>非 not运算 ~</h1><blockquote>
<p>按位取反</p>
</blockquote>
<h3 id="5"><a href="#5" class="headerlink" title="~ 5"></a>~ 5</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">5</td>
<td align="center">0101</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">-6</td>
<td align="center">1010</td>
</tr>
</tbody></table>
<h1 id="左移位-shl运算"><a href="#左移位-shl运算" class="headerlink" title="左移位 shl运算 &lt;&lt;"></a>左移位 shl运算 &lt;&lt;</h1><blockquote>
<p>左移2n位后，低位补0</p>
</blockquote>
<h3 id="5-2"><a href="#5-2" class="headerlink" title="5 &lt;&lt; 2"></a>5 &lt;&lt; 2</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">5</td>
<td align="center">0000 0101</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">10</td>
<td align="center">0000 1010</td>
</tr>
</tbody></table>
<h1 id="右移位-shr运算"><a href="#右移位-shr运算" class="headerlink" title="右移位 shr运算 &gt;&gt;"></a>右移位 shr运算 &gt;&gt;</h1><blockquote>
<p>右移2n位，高位补0</p>
</blockquote>
<h3 id="4-2"><a href="#4-2" class="headerlink" title="4 &gt;&gt; 2"></a>4 &gt;&gt; 2</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">4</td>
<td align="center">0000 0100</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">2</td>
<td align="center">0000 0010</td>
</tr>
</tbody></table>
<blockquote>
<p>易失去精度，无法恢复</p>
</blockquote>
<h3 id="5-2-1"><a href="#5-2-1" class="headerlink" title="5 &gt;&gt; 2"></a>5 &gt;&gt; 2</h3><table>
<thead>
<tr>
<th align="center">标识</th>
<th align="center">DEC</th>
<th align="center">BIN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数一</td>
<td align="center">5</td>
<td align="center">0000 0101</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">2</td>
<td align="center">0000 0010</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Think</tag>
      </tags>
  </entry>
  <entry>
    <title>剑道 基础</title>
    <url>/2024/07/02/%E5%89%91%E9%81%93-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Kamae-构"><a href="#Kamae-构" class="headerlink" title="Kamae 构"></a>Kamae 构</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/kendo/kamae.png"
                      alt="Kamae"
                ><figcaption>Kamae</figcaption></figure></p>
<h2 id="Hakama-袴"><a href="#Hakama-袴" class="headerlink" title="Hakama 袴"></a>Hakama 袴</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/kendo/hakama.jpg"
                      alt="Hakama"
                ><figcaption>Hakama</figcaption></figure></p>
<h2 id="Katana-竹剑"><a href="#Katana-竹剑" class="headerlink" title="Katana 竹剑"></a>Katana 竹剑</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/kendo/katana.jpg"
                      alt="Katana"
                ><figcaption>Katana</figcaption></figure></p>
<h2 id="间合"><a href="#间合" class="headerlink" title="间合"></a>间合</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/kendo/distance.jpg"
                      alt="Distance"
                ><figcaption>Distance</figcaption></figure></p>
]]></content>
      <categories>
        <category>Kendo 剑道</category>
      </categories>
      <tags>
        <tag>剑道</tag>
      </tags>
  </entry>
  <entry>
    <title>只做正确的事情，并持续输出价值</title>
    <url>/2017/02/24/%E5%8F%AA%E5%81%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%8C%E5%B9%B6%E6%8C%81%E7%BB%AD%E8%BE%93%E5%87%BA%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<blockquote>
<p>转载<br><a class="link"   href="http://www.nowamagic.net/librarys/veda/detail/2673" >http://www.nowamagic.net/librarys/veda/detail/2673<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 只做正确的事情，并持续输出价值</p>
</blockquote>
<p>最近经常有网友问，博客为啥更新得这么慢。这一段时间几乎都在忙一些琐事，但是任何忙都是借口，其实都是因为懒。顺便做个广告，现在博客很少更新技术类文章了，技术文章大部分都以专题的形式更新在 现代魔法学院 里。有任何意见都欢迎给我提一下～博客现在主要是发表一些自己的思考。</p>
<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>一个朋友昨天跟我聊天，说离职了，准备加入一个手游创业团队，薪酬挺高的，比之前的工作要高两倍有多。我当时敷衍过去了，但是心里却有别的想法。</p>
<p>我老婆是个重度“游戏是电子海洛因”观点坚持者，或多或少也影响了我的一些看法。我也玩游戏，但是是偶尔玩玩，玩多了绝对会被骂，之前就发过这么一条微博：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017_02_24_01.png"
                     
                ></p>
<p>前几年多玩的一个朋友内推我，后来因为老婆（那会是女朋友）的脸色，没去成，那时多玩还没上市。她说，好端端地，不要去做游戏毒害别人。我也玩游戏，我对游戏不存在偏见，也不抗拒，正是因为我也玩游戏，我深切地体会到，游戏无法给我们的人生带来多少积极的影响。我们用有限的生命时间去博无限的游戏时间，是很不值得的一件事。</p>
<p>比如现在我也有在玩“炉石传说”，周末有空也偶尔上YY、斗鱼看看直播，发现一些热门主播竟然有几万人同时在看。据说荷尔蒙经济效应很明显，一些热门的妹子主播每个月大概有几万的直播收入，甚至更高，因为每天晚上都有几万屌丝同时在线看直播。还有些人花几千上万元购买卡包，托炉石传说的福，网易上个季度的收入创了新高。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017_02_24_02.jpg"
                     
                ></p>
<p>这不是一个好的现象。屌丝们虽然会因为游戏而快乐，但到头来时间、精力还有金钱都被游戏消耗太多，以至于一事难成。大部分人是缺乏远见的，一个常见的例子就是，现在给你100块，和明年给你500块，二选一，绝大部分人会选择前者。贪图眼前的小利而看不到未来是人类的本能。比如贪图一时游戏的快乐，而忘了有更重要的事去做。而互联网，则是人类欲望的集合点。互联网经济大部分都是建立在人类的欲望之上的：</p>
<ul>
<li>我要看视频，于是有一大堆视频网站。</li>
<li>我要打游戏，于是一大堆网游。</li>
<li>我要购物，于是有一大堆电商。</li>
<li>……<br>可以说，任何互联网产品都是为了满足人类的欲望（需求）而产生的。</li>
</ul>
<h3 id="互联网有毒"><a href="#互联网有毒" class="headerlink" title="互联网有毒"></a>互联网有毒</h3><p>我们必须要注意这么一点，<strong>互联网对大部分人来说是有毒的</strong>。</p>
<p>为什么这么说呢？首先，你要知道，什么东西对你最重要，那就是时间和注意力，这两样东西是你有所成就的两个必要条件。</p>
<p>比如你看微博，关注那些八卦碎片信息，无形中你的时间、注意力还有意志力就会被消耗，看完了你也没多少精力去干活了。比如你看视频，网上的一些连续剧，同样消耗你的时间和注意力，并且还会影响你的大脑，让你去回味故事情节，占用你的大脑。游戏更不用说了，沉迷游戏基本等于荒废，这个我是有经验的。</p>
<p>文艺作品（书籍影视等）是可以改变大脑的。比如你看了一篇鸿篇巨著，有可能会影响你的一生。但是一档连续剧，可能看了没一个月你连人物都忘记了。所以优秀的文艺作品可以流芳百世，影响无数人，而快餐影视仅仅是快餐而已，甚至传播一些错误的价值观，快餐毕竟对身体不怎么好。插个小段子，我中学的时候特别喜欢《棋魂》这部动画，我那时傻傻地要像主人公全部时间花在围棋上一样把全部时间花在功课上（所谓的追求神之一身、最好的一手），其结果是，每次大考我必然是全年级第一，那会可是传说一般的存在。优秀的动漫作品对我影响真的很大很大。直到现在我也还是很喜欢棋魂，可能十年后，它还会影响着我。</p>
<p>不恰当地使用互联网，你的时间、注意力就会被投入到一个无底洞，从而让你无法发现你需要去做的那些正确的事，或者发现了又没有足够的时间与精力投入，其结果就是一事难成。</p>
<p>也就是说：</p>
<pre><code>* 如果你想在编程有很深的造诣，那么最好把游戏卸载了，不要关注那些游戏直播，也不要关注那些游戏信息，你要做的是每晚每晚都去练习编程，去Github拿一些优秀的开源项目代码回来琢磨，理解各编程大师的想法；
* 如果你想在数学有所建树，那么就不要老是刷微博、看SNS Feed流，留意那些可有可无的八卦信息，你要做的是每晚每晚努力去专研数学，体验思考的乐趣与想通问题带来的满足感与成就感；
* 如果你想钢琴弹得很好，那么就不要老是玩手机，各种娱乐应用，也不要因为想放松而去看连续剧，你要做的是每晚每晚努力去练习钢琴，因为你想把琴练得很好，那么你心里最好只有琴。
* ……
</code></pre>
<p>大家都知道，一件事情，进入状态很难。而出状态，则可能是分分秒秒的事。我们的技艺，只有在沉醉状态中才能有效提高。也许有哪个高人可以边玩LOL边写代码，但我觉得，这种人应该不多吧。</p>
<p>而站在互联网产品提供这边，我们要做的，并不是要去做那些哗众取宠的的东西，比如什么“天天酷跑天天爱消除天天爱干嘛”，什么“美拍闪拍各种拍”，而是要专注于给用户提供价值的东西，正确的东西，比如百度前首席架构师林仕鼎从百度离职，做了“云校”，试图通过互联网和大数据，“再一次，定义教育”。我觉得，这是一件很正确、很有意义的事。同样的，网易公开课也是一个很不错的东西。</p>
<p>那么什么才是正确的事呢？这个就是我一直坚持的“普世价值观”，那些放在大部分情况都是对别人有价值的事情。比如最近我看到的“防蓝光镜片”这事，佩戴之后可以减少电子设备蓝光激发对眼睛的伤害，我觉得就是一件很正确、很有意义的事情。不要小看来自电脑手机屏幕的蓝光辐射，这个问题会越来越严重。防蓝光镜片可以缓解这个问题，那么这就是一件很有意义的事，正确的事，因为这事对别人有价值。假若这个镜片的制作发起人沉迷LOL小学生联盟，那么这个好东西就会出现得比较晚。</p>
<p>我老婆是个重度“腾讯系”用户，每天都看微信朋友圈，逛QQ空间，挂QQ然后看QQ群…… 我都说她好多次，让她注意别浪费太多时间在这些无聊的Feed上面了。她朋友圈、QQ空间无非就是一些哪个同事结婚了，哪个同学去哪玩了，哪个朋友在秀美食什么的，也看不懂她为什么如此乐此不疲。反正我觉得，腾讯的那些所谓社交产品，消耗了她很多时间和注意力。</p>
<p>而我则很少用腾讯的东西，甚至QQ都很少用，相对地，我则是“Google系”或者“阿里系”用户。阿里巴巴的产品我用得很多，比如我的网站就是放在阿里云的，网站收入虽然少但毕竟也有，而且也能对外持续输出我的价值。我的一些闲钱也放在余额宝里，收益至少比银行高，对我也是有价值的，支付宝转账到各行都是免费，这非常方便。我装修的电器、门、油漆什么的都是在聚划算买的，也帮我省钱了。所以，我认为阿里巴巴是一家让人尊敬的公司，因为它坚持做正确的事，对用户有价值的事。Google也是一家让人尊敬的公司，他做的很多产品都对用户很有价值，而且大部分是免费的。腾讯虽然口号是成为“最受尊敬的互联网企业”，但是从他的大半收入是靠游戏和社交来看，我觉得有点背道而驰。</p>
<p>一件事情，如果不适用于普世价值，再怎么美化也没用。你可以说游戏有多少好处，但是你却无法否认，他消耗了多少生命，让多少人事业踌躇不前。</p>
<p>根基建立在普世价值之上的公司可以长久，马云说，阿里巴巴要活102年，如果阿里巴巴坚持他的价值观，我觉得没问题。而一些游戏公司，很可能就会因为一款游戏的热情消退而落幕，比如第九城市。一家日本的和服店可以经营450年，你敢信？原因很简单，坚持做正确的事情，并持续输出价值。</p>
<p>我们不需要开创多么伟大的事业，只要找到你正确的事情，坚持就可以了，哪怕是一间和服店。</p>
<p>回到前面说的那个要去做手游的朋友，确实，手游是下一个引爆点，必定能够赚不少钱。但是，你做的游戏越成功，就有越多人把时间消耗在你的游戏中，你的利益来自于损害用户的利益，但如果你不介意，也没事，这样的人多了去了。前段时间在贴吧看到一个高三学生发了一个帖子，说炉石毁了他，让他分数很低，找不到学校读书什么的。嘛，沉迷游戏耽误人的事也不是很罕见了。</p>
<p>所以，假如你想做点事情，首先考虑的是，它能不能对别人产生价值，而不是能不能赚钱。如果只考虑赚钱，到头来很可能赚不到钱。而一切围绕着对用户产生价值，并且持续每天不断地输出价值，一切都会纷至沓来。</p>
]]></content>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>单元架构 (蜂窝架构) cell-based architecture</title>
    <url>/2026/01/16/%E5%8D%95%E5%85%83%E6%9E%B6%E6%9E%84-%E8%9C%82%E7%AA%9D%E6%9E%B6%E6%9E%84-cell-based-architecture/</url>
    <content><![CDATA[<ul>
<li><a class="link"   href="https://docs.aws.amazon.com/zh_cn/wellarchitected/latest/reducing-scope-of-impact-with-cell-based-architecture/what-is-a-cell-based-architecture.html" >AWS - What is a cell-based architecture?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://docs.aws.amazon.com/zh_cn/wellarchitected/latest/reducing-scope-of-impact-with-cell-based-architecture/why-to-use-a-cell-based-architecture.html" >AWS - Why use a cell-based architecture?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://docs.aws.amazon.com/zh_cn/wellarchitected/latest/reducing-scope-of-impact-with-cell-based-architecture/when-to-use-a-cell-based-architecture.html" >AWS - When to use a cell-based architecture?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<h2 id="什么是基于单元的架构？"><a href="#什么是基于单元的架构？" class="headerlink" title="什么是基于单元的架构？"></a>什么是基于单元的架构？</h2><p>A cell-based architecture comes from the concept of a bulkhead in a ship, where vertical partition walls subdivide the ship’s interior into self-contained, watertight compartments. Bulkheads reduce the extent of seawater flooding in case of damage and provide additional stiffness to the hull girder.<br>基于单元的建筑源自船舶舱壁的概念，垂直隔墙将船内分割成自成一体、防水的舱室。隔舱可以减少海水进水的程度，并在船体梁梁上提供额外的刚性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/cell-based/failure-isolation-using-bulkheads.jpg"
                     
                ></p>
<p>Isolating failures using bulkheads 利用隔板隔离故障</p>
<p>On a ship, bulkheads ensure that a hull breach is contained within one section of the ship. In complex systems, this pattern is often replicated to allow fault isolation. Fault isolated boundaries restrict the effect of a failure within a workload to a limited number of components. Components outside of the boundary are unaffected by the failure.<br>在船只上，隔舱壁确保船体破损被控制在 船。在复杂系统中，这种模式常被复制以实现故障隔离。 故障隔离边界限制了工作负载中故障的影响，仅限于有限数量的组件。边界外的组件不受失效影响。</p>
<p>Using multiple fault isolated boundaries, you can limit the impact on your workload. When provisioning a new customer or tenant, or applying a workload change, you can do this gradually, compartment by compartment, or in other words, isolation boundary by isolation boundary. This way, when a failure occurs, a smaller number of customers or resources will be impacted. On AWS, customers can use multiple Availability Zones and AWS Regions to provide fault isolation, but the concept of fault isolation can be extended to your workload’s architecture as well.<br>通过设置多个故障隔离边界，你可以限制对工作负载的影响。在为新客户或租户配置，或应用工作负载变更时，你可以逐步进行，逐个隔块，换句话说，逐个隔离边界。这样，当发生故障时，受影响的客户或资源数量会减少。在 AWS 上，客户可以使用多个可用性区和 AWS 区域来实现故障隔离，但故障隔离的概念也可以扩展到你的工作负载架构中。</p>
<p>The overall workload is partitioned by a partition key. This key needs to align with the grain of the service, or the natural way that a service’s workload can be subdivided with minimal cross-cell interactions. Examples of partition keys are customer ID, resource ID, or any other parameter easily accessible in most API calls. A cell routing layer distributes requests to individual cells based on the partition key and presents a single endpoint to clients.<br>整体工作负载由分区键划分。这个密钥需要与服务的纹理保持一致， 或者说，服务工作负载可以自然细分的方式 细胞间相互作用极少。分区键的例子 是客户 ID、资源 ID 或其他任何参数，都很容易 大多数 API 调用中可访问。小区路由层分布 基于分区键和 向客户端展示单一端点。</p>
<p>A cell-based architecture uses multiple isolated instances of a workload, where each instance is known as a cell. Each cell is independent, does not share state with other cells, and handles a subset of the overall workload requests. This reduces the potential impact of a failure, such as a bad software update, to an individual cell and the requests that it’s processing. If a workload uses 10 cells to service 100 requests, when a failure occurs in one cell, 90% of the overall requests would be unaffected by the failure.<br>基于单元的架构使用多个孤立的工作负载实例，每个实例称为单元 。每个单元独立，不与其他单元共享状态，并处理部分整体工作负载请求。这减少了失败（如软件更新不良）对单个单元及其处理请求的潜在影响。如果一个工作负载使用 10 个单元来处理 100 个请求，当一个单元发生故障时，90%的整体请求将不受故障影响。</p>
<p>With cell-based architectures, many common types of failure are contained within the cell itself, providing additional fault isolation. These fault boundaries can provide resilience against failure types that otherwise are hard to contain, such as unsuccessful code deployments or requests that are corrupted or invoke a specific failure mode (also known as poison pill requests).<br>在基于单元的架构中，许多常见的故障类型都包含在单元内部，提供了额外的故障隔离。这些故障边界可以为那些难以控制的故障类型提供韧性，比如未成功的代码部署、损坏请求或触发特定失败模式（也称为毒丸请求 ）。</p>
<h3 id="A-typical-workload-典型的工作量"><a href="#A-typical-workload-典型的工作量" class="headerlink" title="A typical workload  典型的工作量"></a>A typical workload  典型的工作量</h3><p>To make it clearer, in the following diagram, we have a typical application divided into three layers. In this context, this application would be serving requests from 100% of clients. In the event of a failure, or a change in the application, 100% of customers would be impacted.<br>为了更清楚地说明，下图中我们有一个典型的应用，分为三层。在这种情况下，这个应用将满足100%客户端的请求。如果发生故障或应用变更，100%的客户都会受到影响。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/cell-based/typical-workload.jpg"
                     
                ></p>
<p>A typical workload 典型的工作量</p>
<h3 id="A-workload-with-cell-based-architecture-基于单元架构的工作负载"><a href="#A-workload-with-cell-based-architecture-基于单元架构的工作负载" class="headerlink" title="A workload with cell-based architecture 基于单元架构的工作负载"></a>A workload with cell-based architecture 基于单元架构的工作负载</h3><p>Rather than build out services as single-image systems, we propose a different approach: break your services down internally into cells and build thin layers to route traffic to the right cells. This type of architecture can be zonal, regional, or global.<br>我们提出另一种方法：将服务内部拆分为单元，构建薄层以将流量路由到正确的单元。这种类型的建筑可以是区域性的、区域性的或全球性的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/cell-based/cell-based-architecture.jpg"
                     
                ></p>
<p>A cell-based architecture 基于单元的架构</p>
<ul>
<li>The cell-based architecture has the following components, which will be further explored later in this guidance:<br>  基于单元的架构包含以下组件，后续将在本指南中进一步探讨：</li>
<li>Cell router — We also refer to this layer as the thinnest possible layer, with the responsibility of routing requests to the right cell, and only that.<br>  蜂窝路由器 ——我们也称这一层为 最薄的层 ，负责将请求路由到正确的单元，仅此而已。</li>
<li>Cell — A complete workload, with everything needed to operate independently.<br>  小区 ——一个完整的工作负载，所有设备都需要独立运作。</li>
<li>Control plane — Responsible for administration tasks, such as provisioning cells, de-provisioning cells, and migrating cell customers.<br>  控制平面 ——负责管理任务，如配置小区、取消配置小区和迁移小区客户。</li>
</ul>
<p>Building a cell-based architecture doesn’t necessarily mean having to double, triple, or more your application’s infrastructure. It might be that your application has 30 hosts, and in a cell-based architecture it has the same 30 hosts, but with a cell router and with tasks that are distributed or grouped between cells.<br>构建基于单元的架构并不一定意味着必须将应用基础设施加倍、三倍甚至更多。你的应用可能有30台主机，而在基于小区的架构中，它也有同样的30台主机，但配备了小区路由器，任务分布或分组在小区之间。</p>
<h2 id="Why-use-a-cell-based-architecture-为什么要采用基于单元的架构？"><a href="#Why-use-a-cell-based-architecture-为什么要采用基于单元的架构？" class="headerlink" title="Why use a cell-based architecture? 为什么要采用基于单元的架构？"></a>Why use a cell-based architecture? 为什么要采用基于单元的架构？</h2><p>These are the main advantages of a cell-based architecture.<br>这些是基于单元架构的主要优势。</p>
<h3 id="Scale-out-over-scale-up-规模扩大而非规模化"><a href="#Scale-out-over-scale-up-规模扩大而非规模化" class="headerlink" title="Scale-out over scale-up  规模扩大而非规模化"></a>Scale-out over scale-up  规模扩大而非规模化</h3><ul>
<li>Scaling up, or accommodating growth by increasing the size of a system’s component (such as a database, server, or subsystem) is a natural and straightforward way to scale. Scaling out, on the other hand, accommodates growth by increasing the number of system components (such as databases, servers, and subsystems), and dividing the workload such that the load on any component stays bounded over time despite the overall increase in workload. The task of dividing the workload can make scaling out more challenging than scaling up, particularly for stateful systems, but has well-understood benefits:<br>  通过扩大系统组件规模来适应增长 （例如数据库、服务器或子系统）是一种自然且直接的扩展方式。 而缩放扩展则通过增加 系统组件数量 （如数据库、服务器和子系统），以及如何划分工作负载，使得尽管整体工作负载增加，任何组件的负载仍保持有界。分配工作负载的任务可能使扩展比扩展更具挑战性，尤其是对于有状态系统，但其优点是众所周知的：</li>
<li>Workload isolation: Dividing the workload across components means workloads are isolated from each other. This provides failure containment and narrows the impact of issues, such as deployment failures, poison pills, misbehaving clients, data corruption, and operational mistakes.<br>  工作量隔离： 将工作负载划分到各个组件意味着工作负载彼此隔离。这提供了故障控制，并缩小了部署失败、毒丸、不当客户端、数据损坏和作错误等问题的影响。</li>
<li>Maximally-sized components: Accommodating growth by increasing the number of components rather than increasing component size means that the size of each component can be capped to a maximum size. This reduces the risk of surprises from non-linear scaling factors and hidden contention points present in scale-up systems.<br>  最大尺寸组件： 通过增加组件数量而非增加组件规模来适应增长，意味着每个组件的规模可以被限制在最大范围内。这降低了非线性缩放因子和放大系统中隐藏争点带来的意外风险。</li>
<li>Not too big to test: With maximally-sized components, the components are no longer too big to test. These components can be stress tested and pushed past their breaking point to understand their safe operating margin. This approach does not address testing the overall scaled out system composed of these components, but if the majority of the complexity and risk of the system sits in stress-tested components (and it should), the level of test coverage and confidence should be significantly higher.<br>  不大而难以测试： 对于最大尺寸的组件，组件不再太大而无法测试。这些组件可以经过压力测试，并将其推至极限，以了解其安全的工作余裕。该方法不涉及对由这些组件组成的整体扩展系统进行测试，但如果系统大部分复杂性和风险都集中在经过压力测试的组件中（而且应该如此），那么测试覆盖率和置信度应当显著提高。</li>
</ul>
<p>Cells change our approach from scaling up to scaling out. Each cell, a complete independent instance of the service, has a fixed maximum size. Beyond the size of a single cell, regions grow by adding more cells. This change in design doesn’t change the customer experience of your services. Customers can continue to access the services as they do today.<br>细胞改变了我们从放大到放大的方式。每个单元是服务的完全独立实例，最大大小固定。超过单个单元格的规模，区域通过增加更多单元格来增长。这种设计变化不会改变客户对服务的体验。客户可以像现在一样继续使用这些服务。</p>
<h3 id="Lower-scope-of-impact-影响范围较低"><a href="#Lower-scope-of-impact-影响范围较低" class="headerlink" title="Lower scope of impact 影响范围较低"></a>Lower scope of impact 影响范围较低</h3><p>Breaking a service up into multiple cells reduces the scope of impact. Cells represent bulkheaded units that provide containment for many common failure scenarios. When properly isolated from each other, cells have failure containment similar to what we see with Regions. It’s highly unlikely for a service outage to span multiple Regions. It should be similarly unlikely for a service outage to span multiple cells.<br>将服务拆分为多个单元可以减少影响范围。单元代表隔板单元，为许多常见故障场景提供隔离。当彼此适当隔离时，细胞具有类似区域的失效容纳。服务中断跨多个区域的可能性极低。服务中断跨越多个小区的可能性也同样不大。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/cell-based/scope-of-impact.jpg"
                     
                ></p>
<p>Cell-based architectures can reduce scope of impact 基于单元的架构可以缩小影响范围</p>
<h3 id="Higher-scalability-or-cells-as-a-unit-scale-更高的可扩展性或单元单元作为单位尺度"><a href="#Higher-scalability-or-cells-as-a-unit-scale-更高的可扩展性或单元单元作为单位尺度" class="headerlink" title="Higher scalability or cells as a unit scale 更高的可扩展性或单元单元作为单位尺度"></a>Higher scalability or cells as a unit scale 更高的可扩展性或单元单元作为单位尺度</h3><p>As recommended in Manage service quotas and constraints in the Well-Architected Framework, for your workloads, defining, testing, and managing the limits and capacity of a cell is also essential. Knowing and monitoring this capacity, it’s possible to define limits, and scale your workload by adding new cells to your architecture, thus scaling it out.<br>正如《管理良好架构框架中的服务配额与约束》中建议的，针对您的工作负载，定义、测试和管理单元单元的限制和容量同样至关重要。了解并监控这些容量后，可以定义限制，并通过向架构中添加新的单元来扩展工作负载，从而实现扩展。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/cell-based/scale-out-with-cells.jpg"
                     
                ></p>
<p>Scale-out with multiple cells 多单元的扩展</p>
<p>Cell-based architectures scale-out rather than scale-up, and are inherently more scalable. This is because when scaling up, you can reach the resource limits of a particular service, instance, or AWS account. However, scaling out your workload within an Availability Zone, Region, and AWS account, you can avoid reaching the limits of a specific service or resource. When building cells with a fixed size and known and testable limits, it is possible to add new cells that are in accordance with the limits of the same cited resources.<br>基于单元的架构是扩展而非扩展，且本质上更具可扩展性。这是因为在扩展时，你可能会达到某个服务、实例或 AWS 账户的资源限制。然而，在可用性区、区域和 AWS 账户内扩展工作负载，可以避免达到特定服务或资源的限制。在构建固定大小且已知且可测试的单元时，可以添加符合上述资源极限的新单元。</p>
<h3 id="Higher-testability-更高的可检性"><a href="#Higher-testability-更高的可检性" class="headerlink" title="Higher testability  更高的可检性"></a>Higher testability  更高的可检性</h3><p>Testing distributed systems is a challenging task and is amplified as the system grows. The capped size of cells allows for well-understood and testable maximum scale behavior. It is easier to test cells as compared to bulk services since cells have a limited size. It is impractical for cost reasons for large-scale services to regularly simulate the entire workload of all their tenants, but it is reasonable to simulate the largest workload that can fit into a cell, which should match the largest workload that a single customer can send to your application.<br>测试分布式系统是一项具有挑战性的任务，随着系统的发展，这一挑战会更加显著。单元格的上限尺寸允许实现被充分理解且可测试的最大规模行为。相比批量服务，检测单元更容易，因为单元体积有限。出于成本原因，大型服务定期模拟所有租户的全部工作负载是不切实际的，但合理的做法是模拟一个单元中能容纳的最大工作负载，这应与单个客户能发送到你应用的最大工作负载相匹配。</p>
<h3 id="Higher-mean-time-between-failure-MTBF-平均失效间隔时间（MTBF）"><a href="#Higher-mean-time-between-failure-MTBF-平均失效间隔时间（MTBF）" class="headerlink" title="Higher mean time between failure (MTBF) 平均失效间隔时间（MTBF）"></a>Higher mean time between failure (MTBF) 平均失效间隔时间（MTBF）</h3><p>Not only is the scope of impact of an outage reduced with cells, but so is the probability of an outage. Cells have a consistent capped size that is regularly tested and operated, eliminating the every day is a new adventure dynamic.<br>小区不仅减少了停电的影响范围，停电的概率也相应降低。细胞有一个固定的上限尺寸，需要定期测试和作，消除日常活动是一种新的冒险动态。</p>
<p>As in day-to-day operations, your customers are distributed among the cells and a problem can be identified locally. The same goes for new versions of applications that can only be applied to a small number of cells (up to just one) and when a failure is identified, rollback.<br>就像日常运营一样，你的客户分布在各个小区之间，问题可以在本地被发现。同样，对于只能应用于少量单元（最多一个）的新版本应用，发现故障时回滚。</p>
<p>With your customers spread across cells, for example, 10, you now have 10% of your customers in each cell. This, added to a gradual deployment strategy that we will describe later in this guidance, allows you to better manage system changes, and contain the scope of failures such as code or traffic spikes in some cells while others remain stable and unaffected, thus increasing the average time between application failures.<br>例如，当你的客户分散在不同单元格中，比如10个单元，你现在每个单元里有10%的客户。这结合我们稍后将在本指南中介绍的渐进部署策略，使您能够更好地管理系统变更，并在某些单元中控制代码或流量激增等故障范围，而其他单元则保持稳定且不受影响，从而延长应用失败的平均间隔时间。</p>
<h3 id="Lower-mean-time-to-recovery-MTTR-较低的平均恢复时间（MTTR）"><a href="#Lower-mean-time-to-recovery-MTTR-较低的平均恢复时间（MTTR）" class="headerlink" title="Lower mean time to recovery (MTTR) 较低的平均恢复时间（MTTR）"></a>Lower mean time to recovery (MTTR) 较低的平均恢复时间（MTTR）</h3><p>Cells are also easier to recover, because they limit the number of hosts that need to be analyzed and touched for problem diagnosis and the deployment of emergency code and configuration. The predictability of size and scale that cells bring also make recovery more predictable in the event of a failure.<br>小区也更容易恢复，因为它们限制了需要分析和触碰的问题诊断以及紧急代码和配置部署的主机数量。细胞带来的大小和规模的可预测性也使得故障时的恢复更为可预测。</p>
<h3 id="Higher-availability-更高的可用性"><a href="#Higher-availability-更高的可用性" class="headerlink" title="Higher availability  更高的可用性"></a>Higher availability  更高的可用性</h3><p>A natural conclusion is that cell-based architectures should have the same overall availability as monolithic systems, because a system with n cells will have n times as many failure events, but each with 1&#x2F;nth of the impact. But the higher MTBF and lower MTTR afforded by cells means fewer shorter failures events per cell, and higher overall availability.<br>自然的结论是，基于单元的架构应具有与单片系统相同的整体可用性，因为拥有 n 个单元的系统将具有 失败事件数是 n 倍，但每个事件 仅为冲击的 1&#x2F;n。但小区提供的更高 MTBF 和更低的 MTTR 意味着每个小区的短故障事件更少，整体可用性更高。</p>
<p>There is also the availability defined by:<br>还有一种可用性定义为：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#successful requests / #total requests</span></span><br></pre></td></tr></table></figure></div>

<p>With cells, you can minimize the amount of time the numerator is zero.<br>用单元格，你可以最小化分子为零的时间。</p>
<h3 id="More-control-over-the-impact-of-deployments-and-rollbacks-对部署和回滚影响的更多控制"><a href="#More-control-over-the-impact-of-deployments-and-rollbacks-对部署和回滚影响的更多控制" class="headerlink" title="More control over the impact of deployments and rollbacks 对部署和回滚影响的更多控制"></a>More control over the impact of deployments and rollbacks 对部署和回滚影响的更多控制</h3><p>Like one-box and Single-AZ deployments, cells provide another dimension in which to phase deployments and reduce scope of impact from problematic deployments. Further, the first cell deployed to in a phased cell deployment can be a canary cell, and each cell can have its own canary with synthetic and other non-critical workloads to further reduce the impact of a failed deployment.<br>与单一机和单区部署类似，单元为分阶段部署提供了另一个维度，并减少问题部署带来的影响范围。此外，分阶段单元部署的第一个单元可以是金丝雀单元，每个单元都可以拥有自己的金丝雀单元，配备合成及其他非关键工作负载，以进一步减少部署失败的影响。</p>
<p>Applications that do not use cell-based architecture can also benefit from strategies such as canary deployment. But what the cells bring is the possibility of a combination of a canary deployment strategy being applied in a context of even lesser impact.<br>不使用基于单元架构的应用也可以受益于诸如金丝雀部署等策略。但这些细胞带来的是，在影响更小的环境中，可能采用金丝雀部署策略的组合。</p>
<h2 id="When-to-use-a-cell-based-architecture-什么时候应该使用基于单元的架构？"><a href="#When-to-use-a-cell-based-architecture-什么时候应该使用基于单元的架构？" class="headerlink" title="When to use a cell-based architecture? 什么时候应该使用基于单元的架构？"></a>When to use a cell-based architecture? 什么时候应该使用基于单元的架构？</h2><p>There are applications that serve such a large number of customers that interruption of all customers is unacceptable, either for reputation, or financial reasons, where every unavailable second has a big impact. Workloads that have the following characteristics can benefit from a cell-based architecture:<br>有些应用服务于如此庞大的客户，以至于中断所有客户是不可接受的，无论是出于声誉还是经济原因，每一秒的不可用都会产生巨大影响。具有以下特性的工作负载可以从基于单元架构中受益：</p>
<ul>
<li>Applications where any downtime can have a huge negative impact on customers.<br>  任何停机时间都可能对客户产生巨大负面影响的应用。</li>
<li>FSI customers with workloads critical to economic stability.<br>  FSI 客户承担着对经济稳定至关重要的工作量。</li>
<li>Ultra-scale systems that are too big&#x2F;critical to fail.<br>  那些规模过大、关键到不能倒的超大规模系统。</li>
<li>Less than 5 seconds of Recovery Point Objective (RPO).<br>  恢复点目标（RPO） 不到 5 秒。</li>
<li>Less than 30 seconds of Recovery Time Objective (RTO).<br>  恢复时间目标（RTO） 不到 30 秒。</li>
<li>Multi-tenant services where some tenants require fully dedicated tenancy (meaning, their own dedicated cell).<br>  多租户服务，有些租户需要完全专用的租户（即他们自己的专用手机）。</li>
</ul>
<p>A question to ponder regarding your workload is this: “Is it better for 100% of customers to experience a 5% failure rate, or 5% of customers to experience a 100% failure rate?”<br>关于你的工作量，有个问题需要思考： “让 100%的客户体验 5%的失败率更好，还是让 5%的客户体验 100%的失败率更好？”</p>
<p>Cell-based architecture will not be a good choice for all your workloads, but it can bring great benefits for some your most critical workloads.<br>基于单元架构可能不适合所有工作负载，但它能为一些最关键的工作带来巨大好处。</p>
<p>Implementing a cell-based architecture is not a simple task, among the disadvantages are:<br>实现基于单元的架构并非易事，缺点包括：</p>
<ul>
<li>Increase in the complexity of the architecture due to the redundancy of infrastructure and components.<br>  由于基础设施和组件的冗余，架构的复杂性增加。</li>
<li>High cost of infrastructure and services, although utilization based fee structures like Amazon EC2 Reserved Instances (RIs) and saving plans help close this delta.<br>  基础设施和服务成本高昂，尽管基于利用率的费用结构如亚马逊 EC2 预留实例（RI）和储蓄计划有助于弥补这一差距。</li>
<li>Requires specialized operational tools and practices to operate these multiple replicas (cells) of the workload.<br>  需要专门的作工具和作方法来作这些工作负载的多个副本（单元）。</li>
<li>Necessity to invest in a cell routing layer.<br>  需要投资一个小区路由层。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>Program</category>
        <category>Architecture</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Program</tag>
        <tag>Architecture</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>剑道 轨迹</title>
    <url>/2024/07/02/%E5%89%91%E9%81%93-%E8%BD%A8%E8%BF%B9/</url>
    <content><![CDATA[<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/kendo/kendo_2.jpg"
                      alt="Kendo"
                ><figcaption>Kendo</figcaption></figure></p>
<h2 id="Locus-轨迹"><a href="#Locus-轨迹" class="headerlink" title="Locus 轨迹"></a>Locus 轨迹</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/kendo/locus.jpg"
                      alt="Locus"
                ><figcaption>Locus</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/kendo/locus_2.jpg"
                      alt="Locus2"
                ><figcaption>Locus2</figcaption></figure></p>
<h2 id="Men-面的打击"><a href="#Men-面的打击" class="headerlink" title="Men 面的打击"></a>Men 面的打击</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/kendo/locus_3.jpg"
                      alt="Men"
                ><figcaption>Men</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/kendo/men_new_old.jpg"
                      alt="Men2"
                ><figcaption>Men2</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/kendo/men_order.jpg"
                      alt="Men3"
                ><figcaption>Men3</figcaption></figure></p>
]]></content>
      <categories>
        <category>Kendo 剑道</category>
      </categories>
      <tags>
        <tag>剑道</tag>
      </tags>
  </entry>
  <entry>
    <title>开源协议比较</title>
    <url>/2017/02/22/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="五种开源协议的比较-BSD，Apache，GPL，LGPL，MIT"><a href="#五种开源协议的比较-BSD，Apache，GPL，LGPL，MIT" class="headerlink" title="五种开源协议的比较(BSD，Apache，GPL，LGPL，MIT)"></a>五种开源协议的比较(BSD，Apache，GPL，LGPL，MIT)</h1><h3 id="什么是软件许可协议？"><a href="#什么是软件许可协议？" class="headerlink" title="什么是软件许可协议？"></a>什么是软件许可协议？</h3><pre><code>通俗来讲，许可协议是指用来授权其他人具有某种使用你的作品的权利。
</code></pre>
<p>依靠许可协议将你的作品对外开源或者对你的作品的各个方面逐一进行授权，是一个不错的方法(WordPress, Drupal 和许多其它的内容管理系统都是开源软件)。一旦对外开源，你将失去所有对你的作品的版权，别人也没有义务将你标注为作品的原创者或捐献者。</p>
<p>开源许可协议 使人们免去了研究那些专业的许可条款的麻烦，使人们更方便的对开源项目贡献出自己的代码。而且它还能保护你作为作品的原创作者，确保你至少拥有由于贡献参与而带来的署名荣誉。它还能用来阻止其他人企图声明对你的作品拥有所有权的行为。</p>
<p>但是很多的软件作者和设计者都对各种不同的开源许可协议的内容和含义不甚了了。当你选择了某种开源许可协议时，你都放弃了哪些权力？在没有能明白各种开源协议的确切含义前，在不知道它们最适用于什么情况下时，软件开发者不可能在关于哪个许可协议最适合自己的软件的问题上做出准确的抉择。</p>
<h3 id="BSD开源协议-original-BSD-license、FreeBSD-license、Original-BSD-license"><a href="#BSD开源协议-original-BSD-license、FreeBSD-license、Original-BSD-license" class="headerlink" title="BSD开源协议(original BSD license、FreeBSD license、Original BSD license)"></a>BSD开源协议(original BSD license、FreeBSD license、Original BSD license)</h3><blockquote>
<p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”，可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p>
</blockquote>
<blockquote>
<p>但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>
</blockquote>
<blockquote>
<p>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。如果再发布的只是二进制类库&#x2F;软件，则需要在类库&#x2F;软件的文档和版权声明中包含原来代码中的BSD协议。</p>
</blockquote>
<blockquote>
<p>不可以用开源代码的作者&#x2F;机构名字和原来产品的名字做市场推广。</p>
</blockquote>
<blockquote>
<p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>
</blockquote>
<h3 id="Apache-Licence-2-0-Apache-License，-Version-2-0、Apache-License，-Version-1-1、Apache-License，-Version-1-0"><a href="#Apache-Licence-2-0-Apache-License，-Version-2-0、Apache-License，-Version-1-1、Apache-License，-Version-1-0" class="headerlink" title="Apache Licence 2.0(Apache License， Version 2.0、Apache License， Version 1.1、Apache License， Version 1.0)"></a>Apache Licence 2.0(Apache License， Version 2.0、Apache License， Version 1.1、Apache License， Version 1.0)</h3><blockquote>
<p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布(作为开源或商业软件)。需要满足的条件也和BSD类似：</p>
</blockquote>
<blockquote>
<p>需要给代码的用户一份Apache Licence，如果你修改了代码，需要在被修改的文件中说明。<br>在延伸的代码中(修改和有源代码衍生的代码中)需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</p>
</blockquote>
<blockquote>
<p>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</p>
</blockquote>
<blockquote>
<p>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布&#x2F;销售。</p>
</blockquote>
<h3 id="GPL-GNU-General-Public-License"><a href="#GPL-GNU-General-Public-License" class="headerlink" title="GPL(GNU General Public License)"></a>GPL(GNU General Public License)</h3><blockquote>
<p>我们很熟悉的Linux就是采用了GPL。GPL协议和BSD，Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源&#x2F;免费使用和引用&#x2F;修改&#x2F;衍生代码的开源&#x2F;免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软<br>件了。</p>
</blockquote>
<blockquote>
<p>GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。</p>
</blockquote>
<blockquote>
<p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成&#x2F;采用作为类库和二次开发的基础。</p>
</blockquote>
<blockquote>
<p>其它细节如再发布的时候需要伴随GPL协议等和BSD&#x2F;Apache等类似。</p>
</blockquote>
<h3 id="LGPL-GNU-Lesser-General-Public-License"><a href="#LGPL-GNU-Lesser-General-Public-License" class="headerlink" title="LGPL(GNU Lesser General Public License)"></a>LGPL(GNU Lesser General Public License)</h3><blockquote>
<p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用&#x2F;修改&#x2F;衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用<br>并发布和销售。</p>
</blockquote>
<blockquote>
<p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
</blockquote>
<blockquote>
<p>GPL&#x2F;LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品</p>
</blockquote>
<h3 id="MIT-MIT"><a href="#MIT-MIT" class="headerlink" title="MIT(MIT)"></a>MIT(MIT)</h3><blockquote>
<p>MIT是和BSD一样宽范的许可协议，作者只想保留版权，而无任何其他了限制.也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。</p>
</blockquote>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/LICENES.png"
                      alt="LICENES"
                ><figcaption>LICENES</figcaption></figure></p>
]]></content>
      <tags>
        <tag>LICENES</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务版本控制 Microservices Versioning</title>
    <url>/2024/07/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-Microservices-Versioning/</url>
    <content><![CDATA[<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><ul>
<li><a class="link"   href="https://www.codeguru.com/dotnet/best-practices-versioning-microservices/" >Best Practices in Microservices Versioning<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<h2 id="What-is-Versioning-and-Why-is-it-Important-什么是版本控制-为什么它很重要"><a href="#What-is-Versioning-and-Why-is-it-Important-什么是版本控制-为什么它很重要" class="headerlink" title="What is Versioning and Why is it Important? 什么是版本控制?为什么它很重要?"></a>What is Versioning and Why is it Important? 什么是版本控制?为什么它很重要?</h2><p>版本控制是一种策略，可让您维护具有相同功能的多个服务。与传统应用程序不同，基于微服务的应用程序中的版本控制并不简单。</p>
<p>版本控制是 API 设计的重要组成部分，它使开发人员能够改进 API，而不会破坏其他版本 API 的现有功能。随着应用程序的不断发展和演变，企业通常需要提供新功能，以便客户可以使用此类服务​​。</p>
<p>微服务架构主张团队应独立设计、构建、测试和部署服务。因此，版本控制可能是一个挑战，因为服​​务兼容性可能会丢失。您应该以这样的方式设计微服务，以便在需要时可以恢复到以前的版本。</p>
<h2 id="Microservices-Versioning-微服务版本控制"><a href="#Microservices-Versioning-微服务版本控制" class="headerlink" title="Microservices Versioning 微服务版本控制"></a>Microservices Versioning 微服务版本控制</h2><p>假设您有一个在生产环境中运行的服务，并且有多个消费者。现在假设您需要为该服务添加更多功能以满足客户的需求。</p>
<p>由于旧服务有多个用户，您可能希望保留现有功能。因此，您可能有一些用户需要旧服务，而其他用户则需要具有新功能或扩展功能的版本。这正是 API 版本控制发挥作用的地方。</p>
<p>阅读: <a class="link"   href="https://www.developer.com/design/transition-to-microservices/" >Transitioning to Microservices – Are You Ready?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="Microservices-Versioning-Strategies-微服务版本控制策略"><a href="#Microservices-Versioning-Strategies-微服务版本控制策略" class="headerlink" title="Microservices Versioning Strategies 微服务版本控制策略"></a>Microservices Versioning Strategies 微服务版本控制策略</h2><p>微服务应该随着时间推移而发展——它们应该能够表现出多种行为以满足不同客户的需求。这正是微服务版本控制的作用所在。</p>
<p>基于微服务的应用程序 API 版本控制最常见的两种方式是：</p>
<ul>
<li>URI 中的版本控制</li>
<li>标题中的版本控制</li>
</ul>
<p>微服务的版本控制有点棘手。虽然团队设计、开发和部署彼此独立的微服务，但这在版本控制方面带来了问题。虽然您应该设计一个基于微服务的应用程序来支持该服务的多个版本，但这需要额外的路由逻辑来帮助应用程序在运行时支持同一微服务的多个版本。</p>
<p>阅读: <a class="link"   href="https://www.developer.com/java/version-rest-api/" >Read: Versioning REST APIs.<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="URI-Versioning-URI-版本控制"><a href="#URI-Versioning-URI-版本控制" class="headerlink" title="URI Versioning URI 版本控制"></a>URI Versioning URI 版本控制</h2><p>在此方法中，版本信息作为服务 URL 的一部分提供。这样您就可以识别正在使用的服务版本。您应该将 URL 中未指定版本的服务请求重定向到服务的默认版本。以下是 URI 中使用版本信息的示例:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://myecommerceapp/v1.1.2/v1/GetAllProducts</span><br><span class="line">http://myecommerceapp/v2.0.0/GetProducts</span><br></pre></td></tr></table></figure></div>

<p>URI 修订通常用于更新服务的公共 API。它不会对其后端数据存储进行任何重大更改。使用 URI 版本控制的缺点是，随着时间的推移，处理非常大的 URI 占用空间可能会变得难以管理。</p>
<p>以下代码片段展示了如何实现启用版本控制的控制器。</p>
<div class="code-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SaveRequestResponseHeader.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ApiController</span>] </span><br><span class="line">    [<span class="meta">ApiVersion(<span class="string">&quot;1.0&quot;</span>)</span>] </span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;api/&#123;version:apiVersion&#125;/product&quot;</span>)</span>] </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductV1Controller</span> : <span class="title">ControllerBase</span> </span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">HttpGet</span>] </span><br><span class="line">        <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> OkObjectResult(<span class="string">&quot;Inside Product v1 Controller&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Header-Versioning-标头版本控制"><a href="#Header-Versioning-标头版本控制" class="headerlink" title="Header Versioning 标头版本控制"></a>Header Versioning 标头版本控制</h2><p>在此方法中，版本信息使用请求标头传递。HTTP 协议中的几个标头属性之一是内容版本。标头驱动的版本控制使用此属性来指定服务。</p>
<p>标头版本控制的主要好处是资源的名称和位置保持不变。这可确保 URI 不会因版本信息而杂乱无章，并且 API 对开发人员而言仍然具有语义意义。</p>
<p>这种方法有一个缺点：信息无法轻松地编码在超媒体链接中。以下是在 ASP.NET Core 中配置基于标头的版本控制的方法。</p>
<div class="code-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        services.AddControllers();</span><br><span class="line">        services.AddApiVersioning(config =&gt; &#123;</span><br><span class="line">        config.DefaultApiVersion = <span class="keyword">new</span> ApiVersion(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        config.AssumeDefaultVersionWhenUnspecified = <span class="literal">true</span>; </span><br><span class="line">        config.ReportApiVersions = <span class="literal">true</span>; </span><br><span class="line">        config.ApiVersionReader = </span><br><span class="line">        <span class="keyword">new</span> HeaderApiVersionReader(<span class="string">&quot;x-api-version&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="Semantic-Versioning-语义版本控制"><a href="#Semantic-Versioning-语义版本控制" class="headerlink" title="Semantic Versioning 语义版本控制"></a>Semantic Versioning 语义版本控制</h2><p>语义版本控制是另一种版本控制策略，其中每个版本使用三个非负整数表示，即Major、Minor和Patch。使用语义版本控制指定版本信息的格式如下：MAJOR.MINOR.PATCH 以下是每个版本的含义：</p>
<ul>
<li><strong>主要版本(Major)</strong> 主要版本表示对 API 的重大更改。如果由于版本发生重大更改导致 API 与新版本不兼容，则可以增加此版本。</li>
<li><strong>次要版本(Minor)</strong> 当您拥有兼容的软件版本但业务逻辑已发生更改时，将增加次要版本。</li>
<li><strong>补丁(Patch)</strong> 如果旧版本与新版本兼容，但更新版本中修复了错误，则应增加此值。</li>
</ul>
<p>次要版本和补丁版本通常用于向后兼容更新。在语义版本控制中，版本号是根据更改的严重程度分配的。</p>
<p>例如，v1.0.1是一个小改动，只有几个补丁，而v1.1.0是一个小改动。如果您的服务有重大变化，您可以将版本号设为v2.0.0。</p>
<p>以下是使用语义版本控制调用 API 的方法。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://api.product.com/v1.2.3/GetProducts </span><br></pre></td></tr></table></figure></div>

<p>如果您正在从事的项目有多个模块之间相互依赖，那么语义版本控制是一个不错的选择。</p>
<h2 id="Calendar-Versioning-日历版本控制"><a href="#Calendar-Versioning-日历版本控制" class="headerlink" title="Calendar Versioning 日历版本控制"></a>Calendar Versioning 日历版本控制</h2><p>日历版本控制是一种语义版本控制，利用日历日期代替非负整数。它不固定特定的格式 - 相反，它使用年、月、日的组合，并允许您从各种年、月、日组合中进行选择。</p>
<p>对于受时间限制的应用程序来说，日历版本控制是一个不错的选择。与语义版本控制不同，用于指定日历版本控制的格式如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAJOR.MINOR.MICRO </span><br></pre></td></tr></table></figure></div>

<p>请注意，在语义版本控制中，MICRO被称为PATCH 。</p>
<p>阅读: <a class="link"   href="https://www.developer.com/mobile/android/understanding-android-versioning/" >Understanding Android Versioning.<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Architecture</category>
        <category>Microservices</category>
      </categories>
      <tags>
        <tag>Microservices</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 RAW 格式 vs JPEG 格式</title>
    <url>/2024/07/23/%E6%91%84%E5%BD%B1-RAW-%E6%A0%BC%E5%BC%8F-vs-JPEG-%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-23/2024072301.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>RAW 格式和 JPEG 格式在图像处理方面有显著的差异，了解这些差异有助于解释为什么有时候 RAW 格式的照片看起来不如 JPEG 格式的照片好看。以下是对这两种格式的详细比较，涵盖它们的特点、优缺点，以及为什么 RAW 照片可能不如 JPEG 照片好看的一些原因。</p>
<h2 id="RAW-格式-vs-JPEG-格式"><a href="#RAW-格式-vs-JPEG-格式" class="headerlink" title="RAW 格式 vs JPEG 格式"></a>RAW 格式 vs JPEG 格式</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-23/2024072301.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h3 id="RAW-格式"><a href="#RAW-格式" class="headerlink" title="RAW 格式"></a><strong>RAW 格式</strong></h3><p><strong>定义与概念</strong></p>
<p>RAW 格式是一种未经过处理的原始图像数据格式，通常由相机的传感器直接生成。它包含了所有捕获的图像数据，没有经过任何压缩或处理。</p>
<p><strong>特点</strong></p>
<ul>
<li><strong>未压缩数据</strong>：保存了传感器捕捉到的所有数据。</li>
<li><strong>高动态范围</strong>：能够记录更多的亮部和暗部细节。</li>
<li><strong>后期处理灵活性</strong>：可以调整曝光、白平衡、对比度等参数。</li>
<li><strong>文件大小大</strong>：通常比 JPEG 文件大。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>高质量</strong>：提供更多的图像数据，便于后期调整。</li>
<li><strong>灵活性</strong>：允许进行广泛的编辑和调整。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>需要处理</strong>：需要使用专业软件进行处理和转换。</li>
<li><strong>文件大</strong>：占用更多的存储空间。</li>
</ul>
<h3 id="JPEG-格式"><a href="#JPEG-格式" class="headerlink" title="JPEG 格式"></a><strong>JPEG 格式</strong></h3><p><strong>定义与概念</strong></p>
<p>JPEG 格式是一种压缩图像格式，经过相机处理和压缩后保存的图像文件。</p>
<p><strong>特点</strong></p>
<ul>
<li><strong>压缩数据</strong>：经过有损压缩，丢弃了一部分图像数据。</li>
<li><strong>低动态范围</strong>：可能会丢失一些亮部和暗部细节。</li>
<li><strong>立即可用</strong>：可以直接使用，无需后期处理。</li>
<li><strong>文件大小小</strong>：通常比 RAW 文件小。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>即拍即用</strong>：图像经过处理，适合直接查看或打印。</li>
<li><strong>文件小</strong>：节省存储空间。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>较低质量</strong>：经过压缩，图像数据不如 RAW 丰富。</li>
<li><strong>有限的编辑空间</strong>：编辑空间有限，容易出现压缩伪影。</li>
</ul>
<h2 id="为什么-RAW-格式画面反而没有-JPEG-好看"><a href="#为什么-RAW-格式画面反而没有-JPEG-好看" class="headerlink" title="为什么 RAW 格式画面反而没有 JPEG 好看?"></a>为什么 RAW 格式画面反而没有 JPEG 好看?</h2><h3 id="1-RAW-文件未经处理"><a href="#1-RAW-文件未经处理" class="headerlink" title="1. RAW 文件未经处理"></a><strong>1. RAW 文件未经处理</strong></h3><p>RAW 文件是相机传感器捕捉的原始数据，未经任何处理和优化。相机厂商通常会对 JPEG 图像进行优化处理，使其看起来更加生动和引人注目。这些优化包括自动对比度调整、饱和度增强、锐化等。具体来说：</p>
<ul>
<li><strong>未调整的图像</strong>：RAW 文件直接从传感器获取的图像数据没有进行任何调整，可能显得平淡或缺乏细节。</li>
<li><strong>默认设置不佳</strong>：在未处理的 RAW 图像中，通常缺少对比度、饱和度和锐化效果，图像可能显得暗淡、平坦。</li>
</ul>
<h3 id="2-需要后期处理"><a href="#2-需要后期处理" class="headerlink" title="2. 需要后期处理"></a><strong>2. 需要后期处理</strong></h3><p>RAW 图像的处理需要用户进行后期调整来达到最佳效果。相机对 RAW 图像的处理通常是最基本的，用户需要使用软件来调整图像参数：</p>
<ul>
<li><strong>后期处理</strong>：你需要使用软件（如 Adobe Lightroom、Photoshop、DPP 等）来调整 RAW 图像的曝光、对比度、白平衡、色彩等。</li>
<li><strong>技术要求</strong>：后期处理需要一定的技术水平和经验，初学者可能不容易得到理想的结果。</li>
</ul>
<h3 id="3-JPEG-图像经过优化"><a href="#3-JPEG-图像经过优化" class="headerlink" title="3. JPEG 图像经过优化"></a><strong>3. JPEG 图像经过优化</strong></h3><p>JPEG 图像是经过相机内部处理和优化后的结果，通常具有以下特点：</p>
<ul>
<li><strong>增强效果</strong>：相机对 JPEG 图像进行了一些优化处理，如自动对比度、饱和度和锐化，使其看起来更加生动。</li>
<li><strong>即拍即用</strong>：无需后期处理，图像直接符合视觉标准，适合快速使用。</li>
</ul>
<h3 id="4-图像参数设置"><a href="#4-图像参数设置" class="headerlink" title="4. 图像参数设置"></a><strong>4. 图像参数设置</strong></h3><p>在拍摄 RAW 图像时，很多相机使用默认的参数设置，这些参数可能不适合所有场景：</p>
<ul>
<li><strong>曝光设置</strong>：可能需要手动调整曝光，RAW 图像在拍摄时可能没有完全展现场景细节。</li>
<li><strong>白平衡设置</strong>：RAW 图像的白平衡可能需要在后期处理时进行调整，JPEG 图像通常已经优化了白平衡。</li>
</ul>
<h2 id="不同厂家的-RAW-文件"><a href="#不同厂家的-RAW-文件" class="headerlink" title="不同厂家的 RAW 文件"></a>不同厂家的 RAW 文件</h2><p>RAW格式文件是一个统称，它并不像JPG照片一样，后缀名就是.JPG或者.JPEG，每个相机品牌所拍摄的RAW格式文件都有不同的后缀名。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-23/2024072302.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>比如佳能的后缀名是.CR2或者.CR3，尼康的后缀名是.NEF，索尼的后缀名是.ARW，富士的后缀名是.RAF，松下的后缀名是.RW2，宾得的后缀名是.PEF，徕卡的后缀名是.DNG，哈苏的后缀名是.3FR等等</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-23/2024072303.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="如何让-RAW-文件看起来更好"><a href="#如何让-RAW-文件看起来更好" class="headerlink" title="如何让 RAW 文件看起来更好?"></a>如何让 RAW 文件看起来更好?</h2><p>如果你希望 RAW 文件的画面效果更好，可以尝试以下方法：</p>
<h3 id="1-后期调整"><a href="#1-后期调整" class="headerlink" title="1. 后期调整"></a><strong>1. 后期调整</strong></h3><p>使用专业的图像处理软件对 RAW 文件进行调整：</p>
<ul>
<li><strong>曝光和对比度</strong>：调整曝光补偿和对比度，增强图像的亮度和对比度。</li>
<li><strong>饱和度和色彩</strong>：调整色彩饱和度和色温，提升图像的色彩效果。</li>
<li><strong>锐化</strong>：对图像进行锐化处理，提高细节的清晰度。</li>
</ul>
<div class="code-container" data-rel="Ini"><figure class="iseeu highlight ini"><table><tr><td class="code"><pre><span class="line">// 以 Adobe Lightroom 为例的调整步骤</span><br><span class="line">// 1. 打开 RAW 文件</span><br><span class="line">// 2. 调整曝光、对比度、饱和度等</span><br><span class="line">// 3. 应用锐化和降噪</span><br><span class="line">// 4. 保存和导出 JPEG 格式</span><br></pre></td></tr></table></figure></div>

<h3 id="2-使用预设"><a href="#2-使用预设" class="headerlink" title="2. 使用预设"></a><strong>2. 使用预设</strong></h3><p>利用现有的预设或创建自己的预设来快速提升图像效果：</p>
<ul>
<li><strong>下载预设</strong>：许多摄影师和设计师分享了适用于 RAW 图像的预设。</li>
<li><strong>自定义预设</strong>：根据个人需求创建和调整预设，以便快速应用效果。</li>
</ul>
<h3 id="3-学习图像处理技巧"><a href="#3-学习图像处理技巧" class="headerlink" title="3. 学习图像处理技巧"></a><strong>3. 学习图像处理技巧</strong></h3><p>通过学习图像处理技巧来提高处理 RAW 图像的能力：</p>
<ul>
<li><strong>参加培训课程</strong>：许多在线平台提供图像处理和后期制作课程。</li>
<li><strong>阅读教程</strong>：参考教程和指南来提升图像编辑技能。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><table>
<thead>
<tr>
<th>格式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RAW</strong></td>
<td>高质量数据，后期处理灵活</td>
<td>需要后期处理，文件较大</td>
<td>高级摄影、专业编辑、需要深入调整和优化的场景</td>
</tr>
<tr>
<td><strong>JPEG</strong></td>
<td>即拍即用，文件小，自动优化</td>
<td>图像质量较低，压缩丢失数据</td>
<td>快速拍摄、日常使用、需要快速分享的场景</td>
</tr>
</tbody></table>
<h2 id="Digital-Photo-Professional-DPP-、Photoshop-和-Lightroom-Lr-对比"><a href="#Digital-Photo-Professional-DPP-、Photoshop-和-Lightroom-Lr-对比" class="headerlink" title="Digital Photo Professional(DPP)、Photoshop 和 Lightroom(Lr)对比"></a>Digital Photo Professional(DPP)、Photoshop 和 Lightroom(Lr)对比</h2><p>Digital Photo Professional(DPP)、Photoshop 和 Lightroom(Lr)都是流行的图像处理软件，它们各自有不同的功能、特点和适用场景。以下是对这三款软件的详细对比，包括功能、优缺点以及适用场景等方面的信息。</p>
<h4 id="Digital-Photo-Professional-DPP"><a href="#Digital-Photo-Professional-DPP" class="headerlink" title="Digital Photo Professional(DPP)"></a><strong>Digital Photo Professional(DPP)</strong></h4><p><strong>定义与概念</strong><br>DPP 是佳能公司开发的一款专业图像处理软件，专为佳能相机用户设计，用于处理 RAW 格式照片和进行基本的图像编辑。</p>
<p><strong>主要功能</strong>  </p>
<ul>
<li><strong>RAW 处理</strong>：专注于佳能 RAW 文件的转换和处理。</li>
<li><strong>图像调整</strong>：基本的曝光、对比度、饱和度、白平衡等调整功能。</li>
<li><strong>色彩管理</strong>：色彩校正、色调调整。</li>
<li><strong>图像优化</strong>：去噪、锐化、校正镜头畸变等功能。</li>
<li><strong>批量处理</strong>：支持批量调整和导出。</li>
</ul>
<h4 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a><strong>Photoshop</strong></h4><p><strong>定义与概念</strong><br>Photoshop 是由 Adobe 公司开发的综合性图像编辑软件，广泛用于照片编辑、设计、插图等多种用途。</p>
<p><strong>主要功能</strong>  </p>
<ul>
<li><strong>图像编辑</strong>：专业的图像修饰、合成、调整功能。</li>
<li><strong>图层功能</strong>：多层图像编辑、混合模式、图层效果。</li>
<li><strong>高级修图</strong>：精细的修复工具、内容感知填充、图像调整等。</li>
<li><strong>设计功能</strong>：海报设计、网页设计、UI&#x2F;UX 设计。</li>
<li><strong>插件支持</strong>：大量第三方插件和扩展功能。</li>
</ul>
<h4 id="Lightroom-Lr"><a href="#Lightroom-Lr" class="headerlink" title="Lightroom(Lr)"></a><strong>Lightroom(Lr)</strong></h4><p><strong>定义与概念</strong><br>Lightroom 是 Adobe 公司开发的图像处理和管理软件，专注于照片的组织、编辑和分享。</p>
<p><strong>主要功能</strong>  </p>
<ul>
<li><strong>照片管理</strong>：导入、分类、标签、搜索照片。</li>
<li><strong>RAW 处理</strong>：照片的基本调整和编辑功能。</li>
<li><strong>批量处理</strong>：支持批量导入、处理和导出照片。</li>
<li><strong>图像调整</strong>：曝光、对比度、白平衡、渐变滤镜等。</li>
<li><strong>预设功能</strong>：使用和创建编辑预设以快速应用效果。</li>
</ul>
<h3 id="功能对比"><a href="#功能对比" class="headerlink" title="功能对比"></a>功能对比</h3><table>
<thead>
<tr>
<th>功能</th>
<th>DPP</th>
<th>Photoshop</th>
<th>Lightroom (Lr)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RAW 文件处理</strong></td>
<td>是，专为佳能 RAW 文件设计</td>
<td>是，但需额外安装 Adobe Camera Raw 插件</td>
<td>是，支持多种相机品牌的 RAW 文件</td>
</tr>
<tr>
<td><strong>图像编辑</strong></td>
<td>基本的编辑功能</td>
<td>高级的图像编辑、修饰、设计功能</td>
<td>基本的编辑功能</td>
</tr>
<tr>
<td><strong>图层支持</strong></td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><strong>批量处理</strong></td>
<td>是</td>
<td>支持批处理，但不如 Lightroom 强大</td>
<td>是</td>
</tr>
<tr>
<td><strong>照片管理</strong></td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><strong>预设功能</strong></td>
<td>否</td>
<td>支持通过插件或手动创建</td>
<td>是，支持使用和创建预设</td>
</tr>
<tr>
<td><strong>色彩管理</strong></td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><strong>插件支持</strong></td>
<td>否</td>
<td>是，有大量第三方插件</td>
<td>有一些第三方插件</td>
</tr>
<tr>
<td><strong>用户界面</strong></td>
<td>简洁，适合佳能用户</td>
<td>强大但复杂</td>
<td>直观，适合照片管理和编辑</td>
</tr>
</tbody></table>
<h3 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h3><h4 id="DPP"><a href="#DPP" class="headerlink" title="DPP"></a><strong>DPP</strong></h4><p><strong>优点</strong>  </p>
<ul>
<li><strong>专为佳能用户设计</strong>：与佳能相机和 RAW 文件格式兼容性好。</li>
<li><strong>免费</strong>：购买佳能相机后可以免费下载。</li>
<li><strong>简单易用</strong>：界面简洁，功能专注于 RAW 处理。</li>
</ul>
<p><strong>缺点</strong>  </p>
<ul>
<li><strong>功能限制</strong>：编辑功能较为基础，不支持高级修图或设计。</li>
<li><strong>兼容性问题</strong>：仅支持佳能 RAW 文件，其他品牌相机的 RAW 文件不兼容。</li>
</ul>
<h4 id="Photoshop-1"><a href="#Photoshop-1" class="headerlink" title="Photoshop"></a><strong>Photoshop</strong></h4><p><strong>优点</strong>  </p>
<ul>
<li><strong>功能全面</strong>：涵盖了从基础到高级的图像处理和设计功能。</li>
<li><strong>行业标准</strong>：广泛用于专业的图像编辑和设计领域。</li>
<li><strong>插件丰富</strong>：有大量的插件和扩展功能可用。</li>
</ul>
<p><strong>缺点</strong>  </p>
<ul>
<li><strong>学习曲线陡峭</strong>：功能复杂，初学者可能需要较长时间学习。</li>
<li><strong>价格高</strong>：需要订阅费用，成本较高。</li>
</ul>
<h4 id="Lightroom-Lr-1"><a href="#Lightroom-Lr-1" class="headerlink" title="Lightroom(Lr)"></a><strong>Lightroom(Lr)</strong></h4><p><strong>优点</strong>  </p>
<ul>
<li><strong>全面的照片管理</strong>：强大的照片导入、分类和组织功能。</li>
<li><strong>批量处理</strong>：支持批量调整、导入、导出。</li>
<li><strong>易于使用</strong>：用户界面直观，适合快速编辑和管理照片。</li>
</ul>
<p><strong>缺点</strong>  </p>
<ul>
<li><strong>功能相对基础</strong>：比 Photoshop 功能较少，适合基本编辑和照片管理。</li>
<li><strong>价格</strong>：需要订阅费用。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><table>
<thead>
<tr>
<th>场景</th>
<th>DPP</th>
<th>Photoshop</th>
<th>Lightroom (Lr)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RAW 处理</strong></td>
<td>佳能 RAW 文件的处理与优化</td>
<td>适用于所有相机品牌的 RAW 文件</td>
<td>处理多品牌的 RAW 文件</td>
</tr>
<tr>
<td><strong>高级编辑</strong></td>
<td>基本编辑功能，适合简单调整</td>
<td>高级图像修饰、设计、合成</td>
<td>基本编辑功能，适合快速调整和管理</td>
</tr>
<tr>
<td><strong>照片管理</strong></td>
<td>不提供照片管理功能</td>
<td>无照片管理功能</td>
<td>强大的照片导入、分类、搜索功能</td>
</tr>
<tr>
<td><strong>批量处理</strong></td>
<td>支持批量调整和导出</td>
<td>有批处理功能但不如 Lightroom 高效</td>
<td>强大的批量处理功能</td>
</tr>
<tr>
<td><strong>图像设计</strong></td>
<td>不适合图像设计</td>
<td>图像设计、广告设计、网页设计等功能</td>
<td>不适合高级图像设计</td>
</tr>
</tbody></table>
<h3 id="软件选择建议"><a href="#软件选择建议" class="headerlink" title="软件选择建议"></a>软件选择建议</h3><ul>
<li><p><strong>选择 DPP</strong>：</p>
<ul>
<li>如果你是佳能相机用户，主要需要处理和优化 RAW 文件。</li>
<li>你需要一个免费的、简单的工具来进行基本的 RAW 处理。</li>
</ul>
</li>
<li><p><strong>选择 Photoshop</strong>：</p>
<ul>
<li>如果你需要进行复杂的图像编辑、设计、修图等工作。</li>
<li>你愿意投入时间学习其复杂的功能，且预算允许支付软件订阅费用。</li>
</ul>
</li>
<li><p>**选择 Lightroom(Lr)**：</p>
<ul>
<li>如果你需要一个全面的照片管理解决方案，同时进行照片的基本调整和批量处理。</li>
<li>你需要一个直观的工具来组织和编辑大量照片。</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><strong>Digital Photo Professional (DPP)</strong></p>
<ul>
<li><a class="link"   href="https://www.usa.canon.com/internet/portal/us/home/support/" >DPP 官方网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.usa.canon.com/internet/portal/us/home/support/" >DPP 使用教程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
</li>
<li><p><strong>Photoshop</strong></p>
<ul>
<li><a class="link"   href="https://www.adobe.com/products/photoshop.html" >Photoshop 官方网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://helpx.adobe.com/photoshop/tutorials.html" >Photoshop 学习资源<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
</li>
<li><p><strong>Lightroom</strong></p>
<ul>
<li><a class="link"   href="https://www.adobe.com/products/photoshop-lightroom.html" >Lightroom 官方网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://helpx.adobe.com/lightroom/tutorials.html" >Lightroom 学习资源<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
</li>
</ul>
<p>通过对比这些软件的功能、优缺点及适用场景，你可以根据自己的需求选择最适合你的图像处理工具。如果有更多问题或需要进一步探讨，请随时提问！</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a class="link"   href="https://www.photographytalk.com/dpp-vs-lightroom-vs-photoshop" >DPP vs Lightroom vs Photoshop: Which Should You Use?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.techradar.com/news/best-photo-editing-software" >Best Photo Editing Software: Photoshop, Lightroom, and More<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.adobe.com/products/photoshop-lightroom-vs-photoshop.html" >A Comprehensive Comparison of Lightroom vs Photoshop<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.digitalphotomentor.com/raw-vs-jpeg/" >RAW vs JPEG: Understanding the Differences<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.photographylife.com/raw-vs-jpeg/" >Why is RAW Better than JPEG?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.adobe.com/products/photoshop-lightroom.html" >How to Edit RAW Photos in Lightroom<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://www.photographytalk.com/photoshop-vs-lightroom" >Photoshop vs Lightroom: Which One Should You Use?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>摄影</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 三要素</title>
    <url>/2024/07/02/%E6%91%84%E5%BD%B1-%E4%B8%89%E8%A6%81%E7%B4%A0/</url>
    <content><![CDATA[<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/spiekbriefje-diafragma-sluitertijd-iso.webp"
                      alt="tips"
                ><figcaption>tips</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/base_5.png"
                      alt="tips"
                ><figcaption>tips</figcaption></figure></p>
<h2 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h2><blockquote>
<p>是照相机镜头中控制光线进入镜头量的装置。它通常设置在镜头的前部，通过控制光圈的大小和孔径，可以控制镜头的进光量以及景深效果。</p>
</blockquote>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/lens-size.webp"
                      alt="lens"
                ><figcaption>lens</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/lens-size2.webp"
                      alt="lens"
                ><figcaption>lens</figcaption></figure></p>
<p>在摄影中，光圈的大小是影响照片曝光的关键因素之一。如果光圈开得过大，照片可能会过度曝光，失去细节和颜色；如果光圈开得过小，照片可能会欠曝光，显得暗淡无光。因此，合理调整光圈大小是非常重要的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/aperture.jpg"
                      alt="aperture"
                ><figcaption>aperture</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/aperture_1.jpg"
                      alt="aperture"
                ><figcaption>aperture</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/aperture_2.jpg"
                      alt="aperture"
                ><figcaption>aperture</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/aperture_3.jpg"
                      alt="aperture"
                ><figcaption>aperture</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/aperture_4.jpg"
                      alt="aperture"
                ><figcaption>aperture</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/aperture_5.webp"
                      alt="aperture"
                ><figcaption>aperture</figcaption></figure></p>
<p>除了控制曝光，光圈的大小还会影响景深效果。一般来说，光圈越大，景深越浅，即清晰范围越小；而光圈越小，景深则越深，即清晰范围越大。这种景深效果在拍摄人像、风景等需要突出主题、虚化背景的场景中非常有用。</p>
<p>此外，光圈的大小也会影响照片的画质。一般来说，光圈越大，画面的清晰度可能会降低，出现所谓的“散光”现象；而光圈越小，画面的清晰度则越高。因此，在拍摄高质量的照片时，需要根据实际情况选择合适的光圈大小。</p>
<p>总之，光圈是照相机中一个非常重要的装置，它不仅控制着光线的进入量，还影响着照片的曝光、景深效果和画质。通过合理调整光圈大小，摄影师可以创作出各种不同效果的照片。</p>
<h2 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h2><blockquote>
<p>快门快门是相机中控制曝光时间的重要部件，它的作用是控制相机曝光的时间长短。在拍摄时，我们需要根据不同的光线条件和拍摄需求来选择合适的快门速度。</p>
</blockquote>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/shutter-speed-2.jpg"
                      alt="shutter-speed"
                ><figcaption>shutter-speed</figcaption></figure></p>
<p>首先，让我们来了解一下快门的种类。常见的快门类型有机械快门和电子快门两种。机械快门是通过机械方式控制快门速度，而电子快门则是通过电子方式控制快门速度。两种快门都可以实现快速、准确的曝光控制，但在使用上略有不同。</p>
<p>其次，在拍摄时，我们需要根据不同的拍摄需求来选择合适的快门速度。例如，在拍摄运动场景时，我们需要使用较快的快门速度来捕捉运动员的动作和表情；而在拍摄风景时，我们需要使用较慢的快门速度来捕捉自然光线的变化和细节。此外，在拍摄夜景时，我们也需要使用较慢的快门速度来捕捉城市的灯光和天上的星星。</p>
<p>最后，在使用快门时，我们需要注意以下几点。首先，要保持相机的稳定和平衡，避免因为手抖或者姿势不当而导致照片模糊。其次，要根据不同的光线条件和拍摄需求来选择合适的快门速度，避免因为曝光不足或者过度而导致照片质量下降。最后，要学会灵活运用快门速度的变化来控制照片的曝光效果和氛围。</p>
<p>总之，快门是相机中控制曝光时间的重要部件，它的作用是控制相机曝光的时间长短。在拍摄时，我们需要根据不同的光线条件和拍摄需求来选择合适的快门速度，并注意相机的稳定和平衡以及灵活运用快门速度的变化来控制照片的曝光效果和氛围。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/speed.jpg"
                      alt="shutter-speed"
                ><figcaption>shutter-speed</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/speed_1.jpg"
                      alt="shutter-speed"
                ><figcaption>shutter-speed</figcaption></figure></p>
<h2 id="感光度"><a href="#感光度" class="headerlink" title="感光度"></a>感光度</h2><blockquote>
<p>感光度感光度是指相机传感器对光线的敏感程度。在摄影中，感光度是一个非常重要的参数，因为它决定了照片的曝光程度和画质。一般来说，感光度越高，传感器对光线的敏感度就越高，照片的曝光就越好，但同时也会带来一些负面影响，比如噪点增多和画质下降。</p>
</blockquote>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/iso_5.webp"
                      alt="iso"
                ><figcaption>iso</figcaption></figure></p>
<p>在拍摄照片时，摄影师需要根据拍摄环境的光线和拍摄需求来选择合适的感光度。如果拍摄环境的光线比较暗，那么就需要使用高感光度来保证照片的曝光程度；如果拍摄环境的的光线比较充足，那么使用低感光度就可以满足拍摄需求。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/iso_1.jpg"
                      alt="iso"
                ><figcaption>iso</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/iso_2.jpg"
                      alt="iso"
                ><figcaption>iso</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/iso_3.jpg"
                      alt="iso"
                ><figcaption>iso</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/iso_4.jpg"
                      alt="iso"
                ><figcaption>iso</figcaption></figure></p>
<p>此外，不同的相机传感器对光线的敏感度也不同。一般来说，全画幅相机比APS-C画幅相机具有更高的感光度范围，因此全画幅相机在暗光环境下表现更好。</p>
<p>除了对照片曝光的影响外，感光度还可以影响摄影师的拍摄速度。如果摄影师需要拍摄快速移动的物体，那么就需要使用高感光度来提高拍摄速度，从而捕捉到更好的画面。</p>
<p>总之，感光度是摄影中一个非常重要的参数，它决定了照片的曝光程度和画质。摄影师需要根据拍摄环境的光线和拍摄需求来选择合适的感光度，从而拍摄出更加完美的照片。</p>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 分类</title>
    <url>/2024/07/07/%E6%91%84%E5%BD%B1-%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>从广义上分类分为两大门类：第一类：记录摄影 ，第二类：艺术摄影 。<br>从小类分有：静物摄影、人像摄影、记录摄影、艺术摄影、画意摄影、商业摄影、水墨摄影、全息摄影等等。</p>
</blockquote>
<h2 id="静物摄影"><a href="#静物摄影" class="headerlink" title="静物摄影"></a>静物摄影</h2><p>一种艺术流派，主要是通过图像来展现无生命的元素（食物，游戏，水果，鲜花，各种物体……），在艺术家定义的框架内以某种方式组合，多以工业或手工制成品、自然存在的无生命物体等为拍摄题材。在真实反映被摄体固有特征的基础上，经过创意构思，并结合构图、光线、影调、色彩等摄影手段进行艺术创作，将拍摄对象表现成具有艺术美感的摄影作品。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/2024070704.png"
                      alt="静物"
                ><figcaption>静物</figcaption></figure></p>
<h2 id="人像摄影"><a href="#人像摄影" class="headerlink" title="人像摄影"></a>人像摄影</h2><p>人像摄影与一般的人物摄影不同：人像摄影以刻画与表现被摄者的具体相貌和神态为自身的首要创作任务，人物摄影是以表现有被摄者参与的事件与活动为主，它以表现具体的情节为主要任务，而不在于以鲜明的形象去表现被摄者的相貌和神态。</p>
<p>只要是以表现被摄者具体的外貌和精神状态为主的照片，都属于人像摄影的范畴。当然，它分作照相室人像、室内特定环境人像和户外人像三大类。人像摄影的要求是“形神兼备”。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/202407070A.png"
                      alt="人像"
                ><figcaption>人像</figcaption></figure></p>
<h2 id="记录摄影"><a href="#记录摄影" class="headerlink" title="记录摄影"></a>记录摄影</h2><p>纪录摄影指以纪录为第一目的，对客观事物进行真实影像反映的图片摄影。</p>
<p>摄影之所以诞生，就是为了记录的目的。它诞生之后所显示出来的强大的生命力，也恰恰在于它的记录功能。这是其他技术或艺术所无法比拟或取代的。按照纪录影像的方式和追求的价值不同来划分，纪录摄影分为新闻摄影和纪实摄影。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/20240715082310.jpg"
                      alt="记录"
                ><figcaption>记录</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/20240715082317.jpg"
                      alt="记录"
                ><figcaption>记录</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/2024070701.png"
                      alt="记录"
                ><figcaption>记录</figcaption></figure></p>
<h2 id="艺术摄影"><a href="#艺术摄影" class="headerlink" title="艺术摄影"></a>艺术摄影</h2><p>随着的发展，人们在摄影中不断地增加艺术的元素，开始产生艺术摄影。它与记录摄影的区别在于艺术性的多少与高低，而无绝对的界限。艺术摄影拍出来的效果更唯美，因为这不仅需要技术，还要找准拍摄的时间、地点和角度。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/2024070702.png"
                      alt="艺术"
                ><figcaption>艺术</figcaption></figure></p>
<h2 id="画意摄影"><a href="#画意摄影" class="headerlink" title="画意摄影"></a>画意摄影</h2><p>画意摄影以其唯美的画面语言及美好的设计内涵一直是人像摄影的一种重要的表达方式。画意摄影逐渐成为摄影艺术中的一个重要流派。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/2024070706.png"
                      alt="画意"
                ><figcaption>画意</figcaption></figure></p>
<h2 id="商业摄影"><a href="#商业摄影" class="headerlink" title="商业摄影"></a>商业摄影</h2><p>商业摄影，顾名思义是指作为商业用途而开展的摄影活动。这类摄影是为商业利益而存在的，要按照企业要求进行拍摄，比较拘束。</p>
<hr>
<h2 id="纪实摄影"><a href="#纪实摄影" class="headerlink" title="纪实摄影"></a>纪实摄影</h2><p>纪实摄影是抓拍真实场景或事件的摄影风格。它追求对事实的真实和生动的展示，表现出对生活、社会和人性的深入理解和揭示。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/2024070710.png"
                      alt="纪实"
                ><figcaption>纪实</figcaption></figure></p>
<h2 id="战地摄影"><a href="#战地摄影" class="headerlink" title="战地摄影"></a>战地摄影</h2><p>战地摄影是指在战争和矛盾危机等情况下拍摄的摄影风格，追求传达悲痛、突出真相、强调反战思想等特点。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/2024070711.png"
                      alt="战地"
                ><figcaption>战地</figcaption></figure></p>
<h2 id="街头摄影"><a href="#街头摄影" class="headerlink" title="街头摄影"></a>街头摄影</h2><p>街头摄影是指摄影师在街头、公共场所等公共场合拍摄人和城市景观的摄影风格。它注重情感和思维的传递和场景分析。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/2024070708.png"
                      alt="街头"
                ><figcaption>街头</figcaption></figure></p>
<h2 id="风景摄影"><a href="#风景摄影" class="headerlink" title="风景摄影"></a>风景摄影</h2><p>风景摄影是指以自然风景（如山脉、河流、海滨、森林）作为主要拍摄内容的摄影风格。它注重展现色彩、光线和节奏的美感。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/2024070707.png"
                      alt="风景"
                ><figcaption>风景</figcaption></figure></p>
<h2 id="色彩摄影"><a href="#色彩摄影" class="headerlink" title="色彩摄影"></a>色彩摄影</h2><p>色彩摄影是指以色彩作为主要表现手段的摄影风格，突出色彩鲜艳、强调色彩对表现力的贡献。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/2024070709.png"
                      alt="色彩"
                ><figcaption>色彩</figcaption></figure></p>
<h2 id="黑白摄影"><a href="#黑白摄影" class="headerlink" title="黑白摄影"></a>黑白摄影</h2><p>黑白摄影是指去除了色彩的影像，它强调光影、黑白和构图等因素的运用，追求影像的纯粹和力度。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/20240714150007.png"
                      alt="黑白"
                ><figcaption>黑白</figcaption></figure></p>
<h2 id="女性摄影"><a href="#女性摄影" class="headerlink" title="女性摄影"></a>女性摄影</h2><p>女性摄影是指以女性和女性社群为主要拍摄对象的摄影风格，它注重女性在身体、社会和文化中的角色和地位。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/2024070705.png"
                      alt="女性"
                ><figcaption>女性</figcaption></figure></p>
<h2 id="蒙太奇摄影"><a href="#蒙太奇摄影" class="headerlink" title="蒙太奇摄影"></a>蒙太奇摄影</h2><p>蒙太奇摄影是一种艺术化的摄影风格，它强调利用摄影过程中的纹理、色彩和形状，使多张影像组合在一起，形成一个视觉艺术品。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/202407070C.png"
                      alt="蒙太奇"
                ><figcaption>蒙太奇</figcaption></figure></p>
<h2 id="抽象摄影"><a href="#抽象摄影" class="headerlink" title="抽象摄影"></a>抽象摄影</h2><p>抽象摄影是指通过不同的拍摄技巧（如长曝光、移动摄影等），摄影师可以创造出特殊的图像，使图像脱离现实，发展出自己的意义。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/202407070F.png"
                      alt="抽象"
                ><figcaption>抽象</figcaption></figure></p>
<h2 id="科技摄影"><a href="#科技摄影" class="headerlink" title="科技摄影"></a>科技摄影</h2><p>科技摄影是指使用高科技技术，如红外线、芯片、激光、雷达等进行拍摄和处理，以探索和创造新的影像和图像效果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/202407070E.png"
                      alt="科技"
                ><figcaption>科技</figcaption></figure></p>
<h2 id="人文摄影"><a href="#人文摄影" class="headerlink" title="人文摄影"></a>人文摄影</h2><p>人文摄影是一种文化性的摄影形式，强调人们的生活、文化、传统和历史，注重照片背后的故事和人类关系。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/20240707/202407070D.png"
                      alt="人文"
                ><figcaption>人文</figcaption></figure></p>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 对比</title>
    <url>/2024/08/19/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>对比在摄影中的意义，比大多数摄影家所能认识到的还要广泛得多。<br>在他们看来，对比只不过是选用等级适当的相纸，和合理控制负片密度所得到的那种明暗差别而已。</p>
<p>在构图学中，对比是指有效地运用任何一种差异。<br>大小、形状、方向、质感以及内容上的种种差别，像明暗之差一样，都可以用于对比。</p>
<p>通过差异进行对比是一种最有效的手段，它可以把注意力吸引到主体的主要部分，并使这部分成为压倒其它部分的趣味中心。<br>对比和上一章所谈到的“布局”配合起来，可把观众的目光直接吸引到我们所要表现的主要意图上来。<br>至于其它构图原则，有的是为了引导观众观赏画面的其它特点，有的是为了保持画面完整统一。</p>
<p>缺乏各种对比的照片是单调乏味的。要使用这种照片增色，就应当尽可能多地运用各种表现形式来强调对比。<br>使明者更明，暗者更暗——这种具体运用对比的手法是使一幅呆板的照片焕发光彩的传统验方。</p>
<p>对比离不开变化，有了变化才能产生差异。<br>由于艺术大多渊源于自然，而自然界又总是处于不断变化之中，所以我们也不可避免地要感受到变化，并把它摄入镜头。<br>然而自然界的种种变化，在其变化的瞬间是如此的丰富多彩，又是如此的杂乱无章，以致摄影艺术家不能不象戏剧导演那样，想方设法发挥次要事物的配角作用，以烘托他的中心思想。<br>这样，观众便能一目了然地看出作者所选定的趣味中心了。</p>
<p>为了取得对比的效果，必须使发生变化的地方看来清晰醒目。<br>在一定条件下，特别在由各类似事物构成的环境中，即使是微小的变化，也能产生显著的对比效果。</p>
<p>我们不难看出上下两扇窗中有两块换过的地方。<br>发生变化的地方通常应由周围事物直接反衬出来，否则，会因变化很小而无法觉察。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124546.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>我们特别设计的图案，用来体现对比的必要性和运用对比后所发生的戏剧性变化。<br>图案中所有的方块都一模一样，并精确地排列成行。<br>这种一成不变的形状和排列使人感到单调乏味。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124611.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在这种情况下，我们可以选择任何一个方块加以突出。<br>现在试选左起第三列的第二个方块作为主方块来研究。</p>
<h2 id="利用大小进行对比"><a href="#利用大小进行对比" class="headerlink" title="利用大小进行对比"></a>利用大小进行对比</h2><p>要突出这个主方块，一般人考虑的第一个步骤就是把它放大。<br>这就是自然形成了大小对比。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124621.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>可能有人会怀疑，把主方块加大会不会产生更大的吸引力，其实，这种变化所产生的吸引力，比乍看起来要大得多。<br>主方块加大了，使得周围起衬托作用的背景空间发生了重要变化。<br>原先背景空间上的平直行列是畅通无阻的，而现在的大方块却妨碍了视线的连续运动。<br>由于突出了这个主块，原来各方块之间整齐的行列被打乱了。<br>所有这一切因素，不论是它们单独起了作用还是加在一起起了作用，都促使了差异的产生；而这一差异便使人们的注意力首先集中在发生变化的区域，并且一次又一次地被引回这个区域。</p>
<p>现在，我们可以归纳如下：</p>
<blockquote>
<p>在构图中取得对比效果的一个做法，是把一件物体表现得比其它所有物体更大一些。</p>
</blockquote>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124629.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124643.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>被摄物体在实际体积上并不一定非要大于其它的物体。<br>事实上，它甚至可以比其它物体小得多。<br>让它靠近镜头，而使其它物体远离镜头，通过透视的作用夸大了选定的拍摄主体，它的影像就比较大了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124658.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>照片中的男孩身高四英尺，大人身高六英尺。<br>单凭身高这一点并不能保证画面上的优势。<br>这种优势可以通过布局和下述方法加以调整。</p>
<p>男孩的巨大形象位于画面中心，无疑是画面的优势部分。<br>从同一张认底片剪裁出来的，小男孩的形象移到左侧，成为边框的一部分，因而把画面的统治权让给了画面中心那个较小的人像。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124710.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>为了使构图更为理想，应当把大小、布局、背景空间和其它要素结合起来进行综合试验。<br>采取这种独立探索的态度能得出直觉的判断，比死抠精确的比例尺或心理学条文要有意义得多。</p>
<p>你可以移动那个大的人像，调整影像的大小，并注意背景空间的影响，直到能够最有力地表达你的意图为止。</p>
<p>现在回到我们的基本图形上来，试把主方块缩小看看会取得什么效果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124721.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>请注意缩小的方块怎会一下子抓住你的注意力的。<br>小方块有强烈吸引力的原因和大方块非常像。<br>现在，恰恰是小方块周围的背景空间比其它方块的背景空间大；<br>整齐的行列被打乱了，于是出现了一个有差异的因素。</p>
<p>所以，我们可以得出这样的结论：</p>
<blockquote>
<p>在任何一个大小匀称的构图中，足以打破其均匀性的某一成分，就具有最大的吸引力。</p>
</blockquote>
<p>利用差异作对比，一个以成人为背景的小孩，与一个以小孩为背景的成人一样，都具有同样的强烈吸引力。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124734.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>我们甚至可以这样说：突出于若干大形象之前的小形象也可以成为优势部分。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124751.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="利用明暗进行对比"><a href="#利用明暗进行对比" class="headerlink" title="利用明暗进行对比"></a>利用明暗进行对比</h2><p>取得对比效果的另一个方法是使主要拍摄目标变暗。<br>由明暗对比产生的差异具有强大的吸引力。<br>如果同时运用大小对比和明暗对比，可使吸引力大为增强。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124800.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124810.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>相反，也可以让主体方块明亮，让其它方块黑暗而造成差异。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124820.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在实际拍摄中，当拍摄主体极暗而周围环境极亮，或情况完全相反时，所产生的对比效果是最为强烈的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-19/20240819124830.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124452.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124510.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>但某些情况下，极其强烈的对比显得过于刺眼，因而是不可取的。<br>想取得更加微妙的对比效果，可将拍摄主体置于中间色调背景上，而不是采用色调极端相反的背景。</p>
<p>我们可以把明亮的物体衬在中间色调的背景上，</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124521.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>中间色调的物体衬在明亮色调的背景上，</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124533.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>暗调的物体衬在中间色调的背景上，</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124549.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>中间色调的物体衬在黑暗色调的背景上，</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124603.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>或明暗结合的物体衬在中间色调的背景上。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124614.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>但是，要确实保证让大量的对比因素有利于突出拍摄主体，切不可喧宾夺主。<br>主题的次要内容必须在大小和色调上处于从属地位。</p>
<p>要再三注意各个构图原则之间的相互依存关系。<br>纵然大小和明暗的对比都运用得恰到好处，如果布局不当，也是枉然。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124626.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="利用形状进行对比"><a href="#利用形状进行对比" class="headerlink" title="利用形状进行对比"></a>利用形状进行对比</h2><p>在大小明暗保持不变的情况下，也可以通过形状的变化来取得对比的效果。<br>圆形本身从周围的方块图案中突出出来。<br>处在圆形环境中的方块有着同样强烈的吸引力。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124639.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>衬托在背景上的圆微之所以醒目，主要归功于形状的对比，其次，大小对比、布局以及独特的设计和文字图案等因素也起到了强有力的烘托作用。<br>整个画面的色调也是协调一致的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124649.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>人物的优势地位不空置疑，因为他的不规则的体形反衬在几何图形背景上造成了形状对比，此外，还有大小、明暗和方向的对比，而且把人物靠近在画面中心，这种布局也有利于人物的优势地位。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124704.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="利用方向进行对比"><a href="#利用方向进行对比" class="headerlink" title="利用方向进行对比"></a>利用方向进行对比</h2><p>因物体方向改变而引起的差异具有强大的吸引力。<br>只要把主方块绕其中心略为旋转一下，我们就会情不自禁地把注意力倾注在预定的趣味中心上面，不再需要辅以大小、形状或明暗的变化。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-22/20240822124715.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果使其它方块改变角度，仍然可以让选定的趣味中心保持其显著地位，这就足以证明吸引力来自差异，而不是由于图形棱角本身有什么内在的特殊作用。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132152.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>和前面几种对比一样，使主方块得以突出而成为趣味中心的原因，除了物体方向变化之外，还有一些因素，就是打乱了图形和行列的规律，以及使方块周围背景空间的形状发生了重大变化等。</p>
<p>和物体形状的方向变化相比，线性方向的变化所造成的对比具有更强烈的效果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132207.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>有一根单独的线条表示趣味中心，位于画面中心附近；如果构图中没有其它方向性因素出现，这条单线的优势地位本来是不用怀疑的。</p>
<p>然而，如果设想给这条单线增加许多条附加线，并且在观察者看来，这些线条都是向同一方向倾斜的，你就会看到这些附加线湮没了原来那条单线的优势地位，结果趣味中心就不复存在。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132215.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>但是，假如附加线条都向相反方向倾斜，就可以获得截然不同的结果。<br>尽管附加线条比图三六九中的数量增加了很多，但原来那条单线仍然昂然突出于群线之中，成为趣味中心和优势部分。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132223.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>继续增加附加线条，不管增加多少，甚至加到快把它湮没的程度，也很难抹煞原来那根线条的存在。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132231.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这些异向线条并不一定非要各趣味中心的方向完全相反，只要方向上有充分的变化，中心内容仍可不失优势地位。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132259.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>当涉及方向问题时，我们往往考虑的是物，而不是人。<br>然而，头、躯干和人体各部分之间以及周围物体之间，常表现出一定的倾斜角度，而这种倾斜角度对构图和情绪有着强烈的影响。<br>当拍摄对象的表情紧张呆板时，为了使他们变得轻松自然一些，我们不是都曾提过建议，请他们把头稍为偏转一下吗？</p>
<p>站立时，并不一定要求身体笔直，可以向前弯、向后仰，或向两侧倾斜。<br>就坐姿势的角度和曲线方向与个性和情绪之间大有关系，这一点你即使不是职业心理学家也是可以理解的。<br>卧倒、走路、跑步、工作、游戏、休息——这一切都具有方向特征，摄影家对此必须十分敏感，这样他的作品才能传神，并且有构图上的感染力。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132314.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132323.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132333.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="利用情绪进行对比"><a href="#利用情绪进行对比" class="headerlink" title="利用情绪进行对比"></a>利用情绪进行对比</h2><p>从前面的线条草图中可以看出，方向对比的作用，不仅限于构成优势部分，它在表现各种情绪，如有力的动作、兴奋、竞赛、对抗以及轻松恬静等方面，也是一个重要的因素。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132346.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>优秀的摄影作品能够通过画面上的线条、形状和色调来传达某种情绪：<br>这些线条、形状和色调所表现的也正是摄影家在摄影时对于主题画面基本精神的感受。<br>要表现高贵、庄严、内心冲突、喜悦、恐惧、镇定、沉思和平静，仅仅具备与这些情绪有关的素材是不够的，要善于选择和运用能够表现这种情绪的构图原理和要素，这一点和选择拍摄内容本身具有同样重要的意义。</p>
<p>在下图中，除了是趣味中心以外，方向对比主要表现在横向和竖向的交错上。<br>可比较一下平静感和运动感。<br>在这幅画面中，不仅趣味中心，而且处于次要地位的船只和水面都有角度的对比。<br>这种角度对比产生了一种强烈的运动感。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132356.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果你想把一个纪念性建筑拍摄得雄伟、状丽、庄严，你的画面就应包括能够衬托这样特点的内容，如周围的风光、背景、前景甚至天空。</p>
<p>这样，画面就会表现出你所希望的情绪。<br>挺拔的树木，物体的鲜明轮廓，井井有条的风景布局，天边的云彩：<br>它们都构成了一定的形状，线条，立体感和质感，由于和谐一致并形成了对比，从而烘托了气氛。<br>另一方面，假如你的目的是要表现对某一纪念物的不满或鄙视，那么，你所选的景色内容和天空就应该不那么庄严。<br>背景可以摄入令人不愉快的物体，而前景可以显得肮脏而杂乱。</p>
<p>这里不宜使用横平坚直这种明快的对比，因为这种对比表现力量和稳定；<br>而应当使用不规则的斜线条和拙劣的形状的对比。</p>
<p>以上谈到的构图要素和构图原理虽然在大多数情况下是正确的，但并不能保证在所有情况下都能体现作者的意图.<br>两种相对立的情绪或动作之间，并不存在一条明显的界限.狂欢和悲伤的面部表情十分接近，以至有时会把一张狂欢的照片误认为是悲伤;反之亦然。<br>往往，一个摄影者打算拍摄一个人在开门，而印出的照片却好象是在关门。<br>在一张纪念性建筑物照片中，原先用来贬低其重要性的那些景物，可能起完全相反的作用。<br>它们可能使这个建筑物看起来好象是存在于杂乱而冷落的环境中的一个庄严有序的宜人之处。</p>
<h2 id="利用质感受进行对比"><a href="#利用质感受进行对比" class="headerlink" title="利用质感受进行对比"></a>利用质感受进行对比</h2><p>质感方面的对比经常容易被人忽略。<br>事实上即便是在一个色调完全一致的地方，摄影家也可以找到相当多质感上的差异来加以突出，或者为取得视觉或美学的效果而加以强调。</p>
<p>对比法则表明，一种颜色和它的补色放在一起，就显得分外鲜艳。<br>要取得最佳的质感效果，同样也要使用相对的质感作为衬托，例如用柔软光滑的围巾衬托一张粗糙的脸，用平静的湖水衬托闪亮的金属等等。<br>美丽的大理石精磨制品往往要放在粗糙的底座上才更耐人玩味。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132410.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132420.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="利用思想和内容进行对比"><a href="#利用思想和内容进行对比" class="headerlink" title="利用思想和内容进行对比"></a>利用思想和内容进行对比</h2><p>我们所谈到的对比实例都是最常用的，如大小、形状、明暗、方向和质感。<br>最有效的一种对比手段——颜色，我们还没有涉及，因为本书中只讨论黑白摄影的构图。<br>色彩对比不过是色彩研究的一部分，而对色彩学的全面研究将涉及到相当广泛的内容，研究起来会令人陶醉。</p>
<p>对于一个摄影家来说，他必需把对比时时铭记在心。<br>对比不仅仅是为了吸引注意力而使用的一种手段，它还是一条基本的自然法则，在艺术领域中是绝对不可忽视的。<br>对比在表现活力、生命力和紧张状态时，具有一种令人信服的力量。</p>
<p>当摄影家获得机会有意识、有目的地使用构图手段时，他们往往运用相似点去追求所希望的和谐。<br>但任何事物的相似点太多都会导致单调和乏味。<br>通过相反事物的平衡，如黑与白，推与拉，主动与被动，也能产生同样的和谐效果。</p>
<p>正像在写作当中运用对偶，对照等修辞手段一样，通过强调物体、态势和动作之间的区别，可以把某些观念表达得更清楚，更富有戏剧性。<br>这些区别必需表现得十分强烈，观众才能迅速领会摄影家的主观意图。</p>
<p>我们认为，值得花费一些时间和精力，从许许多多事物中选出一些可用于摄影的对比关系。<br>举例如下：</p>
<ul>
<li>痛苦——愉快， 粗劣的——精细的，</li>
<li>天然的——人造的， 零碎的——完整的，</li>
<li>优越——低劣， 井井有条——杂乱无章，</li>
<li>短暂——持续， 原因——结果，</li>
<li>内在——外在， 坚韧的——脆弱的，</li>
<li>灵活的——死板的， 成组的——单独的，</li>
<li>简单的——复杂的， 相似——差异，</li>
<li>整体——部分， 开始——结束，</li>
<li>永恒的——多变的， 有力——无力，</li>
<li>向前——后退， 优——劣。</li>
</ul>
<p>拍摄了消夏用的游艇在冬季风雪中运输的场面，这就是刚才说过的思想内容对比的一例。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-23/20240823-132433.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>内容对比是构图的一个重要手段。<br>它和大小、形状、色调、方向和质感的对比有所不同，它并不是每张照片中必不可少的。<br>表现主题，可以运用多种方法。<br>究竟应该选用哪一种对比手段，则取决于主题，取决于摄影家的观点，以及观众的兴趣爱好。</p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 布局</title>
    <url>/2024/08/13/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="单一物体的布局"><a href="#单一物体的布局" class="headerlink" title="单一物体的布局"></a>单一物体的布局</h2><p>让我们设想你发现了一个颇感兴趣的主题。<br>经过一番考虑，你确定了一个中心思想，你甚至把这张照片的画面轮廓都确定下来了。<br>现在就是提出这么一个问题：</p>
<blockquote>
<p>把趣味中心安排在画面哪个部位更为理想？</p>
</blockquote>
<p>一般的摄影指南都赞成把趣味中心安排在画面中心的附近。<br>但是，赞同与反对者对此却各执一词。</p>
<p>首先，我们来考虑一下，把一个稍暗的物体衬在一个简洁明亮的背景上应该怎样布局。<br>这里，我们采用已故雕刻家阿尔比诺-卡瓦利托的石雕海龟作为试验的对象。</p>
<p>为了便于作试验，把石雕放在沙盘上，沙上放些淡颜色的卵石和树叶使质感有所变化。<br>试验时只拍一张底片，要给海龟四周留出充足的余地，以便在各个方向进行剪裁。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-17/20240817125049.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在艺术作品里，大和小总是相对的。<br>由于画面上没有已知尺寸的其它物体可以用作测量石雕的依据，所以从图二九〇上无法确定石雕的实际大小。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-17/20240817125106.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>其实石雕本身不过六英才长，但照片上的石雕看起来要大得多。<br>为了更清楚地表示实物的大小，我们另印一张照片，使石雕在画面上相对地小一些。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-17/20240817125117.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在让我们试验一下各种各样的布局。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-17/20240817125129.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>最好忘掉接触过的各种“规则”，不要带任何偏见，仔细观察这些布局，也不要考虑你曾学过的诸如平衡之类的理论，只需要评价这些布局本身给你的印象。<br>尽管画面都很简单，但每一个布局所表现的动感、悬念和气氛却不尽相同。<br>从这一点看来，其中有些布局的效果比中心布局的效果肯定更为理想。</p>
<p>为了有所创新，必须学会观察。<br>观察不是为了肯定已知事实，或套用传统理论，重要的是从中作出自己判断。<br>创造性的活动不应受过去的束缚，必须从有碍个人探索的先入之见中解放出来。<br>甚至有时候应该向传统观念挑战，才更为明智。</p>
<p>上面各种布局仍有局限性，因为画格尺寸的比例受到通用商品的规格限制。<br>想要获得更大的变化和更好的表现效果，可用其它的画格尺寸来作试验。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-17/20240817125139.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-17/20240817125151.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="人像摄影的布局"><a href="#人像摄影的布局" class="headerlink" title="人像摄影的布局"></a>人像摄影的布局</h2><p>在人像摄影的布局中怎样安排趣味中心，这个问题要更复杂一些。<br>人像和小物体不一样，我们不可能把人像的底部与人体本身完全隔裂开来。</p>
<p>这里仍有必要把主体衬在一个简单的背景上。<br>如前所述，为了使用试验简单明了，我们让头部的色调稍微明亮，而背影的色调保持中灰。<br>这次使用室内背景，以便保持适当的环境和质感。</p>
<p>要使注意力绝对集中在头部，而不集中在背影的任何部位上，就得把人像安置在背景前面适当的位置，以便当镜头聚焦于头部时，背景能被柔化。</p>
<p>由于作布局试验时需要有充分的背景空间以保证趣味中心的自由移动，我们应该用完整的原始负片印出这样一张照片。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123437.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>用这张底片剪裁出一张标准的面向前方的肖像，其头部可能恰好位于画面中心。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123452.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这张照片的布局和比例虽然没有什么大毛病，而且在许多情况下还算得上剪裁得当，然而，却显得平淡无味，缺乏深度。<br>用不同的画格和布局进行试验，可以得到下面一些结果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123508.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123522.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>以上照片中背景绝不至于反宾为主变成趣味中心，因为：</p>
<ol>
<li>头部色调较亮，和较暗的背景色调形成相当强烈的对比，因而显得十分突出。</li>
<li>头部焦点清晰，能把注意力从焦点模糊的背景上吸引过来。</li>
<li>头部的立体感、形状和质感吸引了注意力。</li>
<li>对主体的性格刻划十分生动，这本身就具有强烈的吸引力。</li>
</ol>
<p>结果是，拍摄的主体比画面其余部分具有压倒的吸引力，所以我们大可不必考虑把主体置于画面中心的原则。<br>拍摄对象不论位于画面的什么部位，都会成为趣味中心。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123536.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="布局对摄影意图的强调作用"><a href="#布局对摄影意图的强调作用" class="headerlink" title="布局对摄影意图的强调作用"></a>布局对摄影意图的强调作用</h2><p>当画面上出现具有同等吸引力的两个拍摄对象时，问题就大不相同了。<br>让我们把两个人放在一个简单背景上来研究。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123611.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如何布置趣味中心，完全取决于你想表现的特定意图。</p>
<p>如果你想强调双方会见的重要性而不强调任何一方，那么就要以几乎同等的重要地位来表面双方。<br>每一方周围的背景空间也应该基本相等，同时整个画面应该留有宽敞的背景，以便使双方体现为一个整体。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123633.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在，假定两人亲切握手是你意图中最重要部分，那么，镜头就要靠近握着的双手，把手拍得更大一些。<br>还要剪裁部分躯体，以减少足以分散注意力的因素。</p>
<p>如果握着的手和人体相比所占比例再加大一些，人体就得裁掉更多一些。<br>有时这样的构图比保留较多的人体更能表现作者的基本思想。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123647.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>请注意观察：如果在构图时把握着的手放在画面较低的位置会产生什么效果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123657.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>由于手臂的定向线条都通向握手处，握着的手作为趣味中心仍然保持其优势地位。<br>也许大多数人会认为前一张照片的构图能够更有效地把注意力吸引到握手上。<br>但是，左面这张照片由于周围背景平淡，加上手臂定向线条的作用，特别是两个人体构成了边框，这一切使两使两只手臂的接触点具有一种不可抗拒的吸引力。</p>
<p>如果我们的意图是要突出两人之中的一方，那就需要对构图作进一步的调整。</p>
<p>构图调整以后，要突出的那一位上体周围留出了相当的空间，而另一个人则被裁掉了一部分。<br>这样一来，左侧的人就受到更多的注意，而握手依然是趣味中心。</p>
<p>如果把构图作相反的调整，右面的人同样能被突出。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123705.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在，如果你回过头来再看看前面一系列的照片，好好研究一下拍摄意图和主体位置之间的关系，你就会发现一条指导原则：</p>
<blockquote>
<p>为了强调所选定的趣味中心，必须把它布置在画面中心附近的某一个地方。</p>
</blockquote>
<p>因此，我们可以得出如下结论：</p>
<ol>
<li>如果画面上没有强有力的竞争对手，趣味中心就不一定布置在画面中心附近，可以安排在效果最佳的任何部位。</li>
<li>如果画面包括了附加的对象并有可能分散注意力，就要把中心部位让位给主要对象，使它具有更大的吸引力。</li>
<li>把附加对象布置在紧靠边框的地方或裁掉一部分，就能体现出它的从属地位。</li>
</ol>
<p>下面几章还要谈到构图学的其它原则；<br>理解了那些原则之后，我们就会发现，还有另外一些因素也会影响布局。</p>
<p>前面一些图例只是为了阐明关于布局的论点而作的一些浅显说明。<br>还有一类照片，包含的拍摄对象更多，能够表现的意图也更多，让我们看看对这类照片该怎样运用上述的论点。</p>
<p>这张照片是一伙打桥牌的人。<br>如果我们的意图不过是想表现这些打牌的人，就应当使她们尽可能向一起靠拢。<br>但这几个人受到桌子的限制，无法靠得更近，所以，要使用场面较大的背景，以表现他们相距很近。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123715.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>为了突出远处那个打牌的人，把她安排在画面中心附近，而把两侧的两个人加以剪裁。<br>位于前景的人尽管显得很大，而且也同样处于中心，却不会占据优势。<br>这是因为背影远远不及面孔受人注意。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123725.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果把三个人集中在一边，右手的那个人因为和别人拉开距离而显得突出了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123739.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>左侧的那个人突出起来了，部分原因是布局的关系，部分原因是玩牌的注意力集中在她那里。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123751.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>突出的是位于前景的人以及她如何对“明家”出牌。<br>其他人的影像几乎完全从画面上裁掉，这就使她们完全处于从属地位，从而再也不可能把注意力从选定的中心引走了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123759.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在上面一系列照片中，每一幅照片中的趣味中心都是运用以上的结论取得的。<br>把需要突出的人物尽可能地移到画面的中心，其余人物或移到边缘，或部分裁掉，以表示他们是无关紧要的。</p>
<h2 id="指出着重点"><a href="#指出着重点" class="headerlink" title="指出着重点"></a>指出着重点</h2><p>一个手指指着一定方向就具有一定的指挥力量，这种力量是很难抗拒的。我们的注意力总是沿着手指所指的方向移动，直至移到所指对象身上为止。<br>箭头也有类似的力量，能够控制我们的注意力。<br>手指和箭头常常作为符号用来把注意力引向某个焦点。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123817.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>不论所指目标多么微不足道，不论在所指目标的前面有多少障碍物，也不论所指目标处在什么位置上，我们都会不由自主地去注意那个被指出的人或物，而这个被指出的人或物就成了趣味中心。<br>这种指示力量是无法抵挡的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123825.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在拍摄人造物时，有时能发现尖形的物体和箭状物体，可用来把注意力引向选定为趣味中心的内容上去。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123834.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>许多物体都具有惊人的定向效果。<br>任何角度，或任何形状当它们汇集于一点的时候，或当它们缩小到近乎一个点时，都会把观察者的注意力引到各个边的相交点上，或使注意力沿着它们的走向而移动。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123843.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>当两条或多条线交叉的时候，注意力便集中在交叉点上。<br>我们总是情不自禁地去注意交叉点，因为从某种意义上说，四个或更多的箭形物体都正指向着同一个点。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123853.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>一条有力的线条，或曲或直，总能引导观察者顺着它的路线去探视，去寻找在它终端的那件东西。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123900.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果线条是从画面的边缘或靠近边缘的地方开始的，这种效果就更为明显。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-18/20240818123914.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 形状</title>
    <url>/2024/07/14/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E5%BD%A2%E7%8A%B6/</url>
    <content><![CDATA[<blockquote>
<p>在构图的所有要素中，形状可能是一个最基本的要素。相当多的摄影杰作之所以获得成功，或者是凭它单个物体的形状具有戏剧性的效果，或者是依靠几个物体的形状微妙地相互作用；所以我们很容易得出这样的结论：只有形状才是构图的基本要素。<br>另一方面，在许多优秀照片中，物体的形状却又无关紧要。在艺术上这类问题经常出现，它和手工技艺不同，并没有什行固定标准可言。经常是一旦发现某一原理至关重要，就会有人出来雄辩地证明说，艺术创作本来可以不要那个原理，甚至可以和它背道而驰。</p>
</blockquote>
<p>从圆开始:</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144131.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在摄影时，这个圆形可能是一个硬币，一个球，一块圆饼或是一只盘子。</p>
<p>生活中不存在孤立的物体，我们所遇到的，看到的和感受到的每件物体都和其它物体相互联系而存在。<br>如果我们在这个圆形(硬币或馅饼)的四周加个边框，由于和边框的相对位置发生了变化，它便呈现出不同的视觉效果。虽然下面图例中的边框都是一般照片通用的矩形，但它们所包容的物体形状可以各不相同。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144241.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>边框所包容的空间叫作画面。<br>画面里的形状或物体叫图形。</p>
<h2 id="画面和图形的相互关系"><a href="#画面和图形的相互关系" class="headerlink" title="画面和图形的相互关系"></a>画面和图形的相互关系</h2><p>只要图形一进入画面，就会出现形状设计中第三个极其重要的要素，即背景空间。这个第三要素与前两个要素——图形与画面一样，也是一个不可忽视的积极因素。在下边的例子中，较暗的区域就是背景空间。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144327.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果我们利用同一图形和画面，只是把图形放在画面的不同位置上，使背景空间发生变化，我们就能清楚看出背景空间的重要性。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144357.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>图形在画面上稍一移动，背景空间的形状也就随之改变，从而影响了构图。这种影响虽然不易察觉，但起的作用却相当巨大。</p>
<p>摄影者往往只把注意力集中在图形上而忽略了画面。这是由于他们只能买到固定尺寸的底片和相纸，所以有一定的局限性。下面是用同一个简单的圆形所构成的不同画面。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144428.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>画面每变化一次所形成的对圆形的包围圈就不相同，给人的视觉感受也不同，而且也使背景空间的形状截然不同。</p>
<p>通过控制光线，我们可以:</p>
<ol>
<li>强调圆形物体的轮廓<br> <figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144530.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></li>
<li>通过布光，在一侧投出影子，以强调它的立体感。<br> <figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144538.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></li>
<li>强调轮廓的不规则性。<br> <figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144550.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></li>
<li>强调轮廓的圆滑。<br> <figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144723.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></li>
<li>强调圆形和画面之间的明暗对比。<br> <figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144730.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></li>
<li>强调表面的图案或质感。<br> <figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144744.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></li>
</ol>
<p>根据拍摄对象的色调和我们希望强调的程度，上述各种安排可作如下的变化:</p>
<ol>
<li>亮调物体衬在暗调的背景上。</li>
<li>亮调物体衬在中等色调的背景上。</li>
<li>中等色调的物体衬在亮调的背景上。</li>
<li>中等色调的物体衬在暗调的背景上。</li>
<li>暗调物体衬在亮调的背景上。</li>
<li>暗调物体衬在中等色调的背景上。</li>
</ol>
<p>改变画面中的图形的大小，还可以获得更多的变化形式。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144756.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在摄影中，任何一个要素如果离开其它要素，都不可能得到充分的表现。<br>色调、质感和大小三者相互作用极为重要，不得稍有偏废。<br>在下面的讨论中，我们的确稍有侧重，但我们的目的不过是为了对那些引起视觉兴趣的物征集中地分别进行研究而已。<br>通过这种方法，我们可以深入理解这个原理并提高视觉的洞察力。<br>现在，摄影者不妨选择一些圆形物体并给以照明，使它们发生有趣的变化。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144836.png"
                      alt="-"
                ><figcaption>-</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144843.png"
                      alt="-"
                ><figcaption>-</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144854.png"
                      alt="-"
                ><figcaption>-</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144901.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>把相机凑近圆形物体所在高度的平面,拍摄其透视图并观察其结果。这样拍出来的是个椭圆形，它和圆形还有相似之处，然而它的图形设计特点却显著不同了。</p>
<p>一个圆形没有特殊的方向性，但是椭圆或它的同族——卵形却有一个长轴，这个长轴赋予图形本身一种特殊的方向感。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714144902.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>把这种图形放在画面里，如果改变图形的方向，就能使背景空间发生显著的变化，从而加强了方向变化的效果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714145009.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在人工制造的和自然存在的物体中，人们常常发现含一个直边（或两个直边）的弓形。这些弓形使形状变化和方向变化更加多样化，从而有可能设计出更多，更有趣的背景空间。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714145033.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这还可以使方向变化的效果更为强烈。请比较下面两个图形的视觉效果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/20240714145053.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="形状的创造"><a href="#形状的创造" class="headerlink" title="形状的创造"></a>形状的创造</h2><p>当我们开始涉及三角形时，形状变化的机会就更多了。首先，我们还是在纸上画草图，所画草图可以稍大于下面的图样。<br>形状的变化是无穷无尽的，首先，我们使用下列各种三角形。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715120922.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>利用三角形的大小和方向的变化可以布置出各种形状的画面。<br>培养构图灵感的一个有效方法如下：先选定一个特定形状的三角形，制作几个不同尺寸和不同比例的矩形，矩形的尺寸应足以容纳这个三角形的各种姿势。把三角形放在矩形画面之中并到处移动其位置，考察不同的位置所产生的效果。</p>
<p>这个方法看来很简单，但可以提高敏感性，认识形状之间的有趣关系，其结果意味深长的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715120948.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="对自然界各种形状的观察"><a href="#对自然界各种形状的观察" class="headerlink" title="对自然界各种形状的观察"></a>对自然界各种形状的观察</h2><p>在研究上述几何图形的时候，你会发现自己能看到视觉世界中许多有趣的形象，这些形象过去你也曾多次遇到，但却未予注意。这种新培养出来的意识正是一个摄影家最宝贵的才能，这就是透过表面观察事物的能力。</p>
<p>在你的自我训练中，不能看一眼了事，而要仔细实地观察。在初期，作为自我训练的一个部分，可选定一个题目，并尽可能找到最多的答案。这并不需要安排特殊的时间，可以利用旅行、散步、凭窗眺望，或室内小坐的时间，而且完全可以作为一种不用相机的观察练习。</p>
<p>设法发掘你周围环境中的三角形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121116.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>不要忽略实物之间的空隙所形成的三角形。</p>
<p>我们从圆形和三角形谈到四边形时，形状变化的机会是逐渐递增的。<br>我们用圆形和三角形所做的每个试验都可继续用于四边形。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121207.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>四边形的比例有无穷的变化，所以能够用来构成无穷尽的形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121218.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>你如果出去观察或拍照，在城市里是不难找到四边形的。在城市建筑中到处都有四边形，它们几乎占据着统治地位。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121400.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>以上，我们只是讨论了规则的几何形状，这种形状往往使照片看来整齐匀称。<br>再用铅笔作试验，用四条长短不同的直线创作出各种有趣的形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121414.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>请注意，其中有些形状妙趣横生，而有此则毫不动人。环顾一下你的工作室，你会发现在实际物体中，在阴影里，在背景空间里，或者在两个或多个物体之间的背景上，到处都会看到上面所画的一些形状。<br>试用上述方法，勾画五条直线连接成的各种图形。你画得越多，就越富有创造性。每次都可以创造出无数的形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121425.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="自由形状和复合形状"><a href="#自由形状和复合形状" class="headerlink" title="自由形状和复合形状"></a>自由形状和复合形状</h2><p>艺术上很多有价值的东西都是从某些简单题材发展变化而来的。设计或创造四边形和五边形的图形不过是图形变化的一个简单的练习，但是要创造C形曲线的变化图形,其程序要多少复杂一些。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121438.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在，把几条直线和一条C形曲线结合在一起。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121448.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>然后，我们再使用两条C形曲线。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121500.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>有些形状是由多条C形曲线结合而成的，里面一条直线也没有。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121510.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这类形状要尽量简单明快，如果纠缠不清，就不足以动人。你能创造出多少S形曲线呢？</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121518.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在用几条S形曲线和几条直线设计几种形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121528.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>然后，把几条S形曲线和几条C形曲线结合起来。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-15/20240715121539.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在设计各种形状时，除了采用线条组合法之外，还可以采用下述方法。</p>
<h2 id="减图造形法"><a href="#减图造形法" class="headerlink" title="减图造形法"></a>减图造形法</h2><p>先用纸做一个基本图形，如圆、三角形、正方形或或矩形，从角上或边上剪下一些较小的形状，如直线、C形曲线或S形曲线，直到形成一个满意的新形状为止。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716122907.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="增图造形法"><a href="#增图造形法" class="headerlink" title="增图造形法"></a>增图造形法</h2><p>选用一些小的形状，把它们结合在一起，形成一个全新的形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716122926.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="剪纸造形法"><a href="#剪纸造形法" class="headerlink" title="剪纸造形法"></a>剪纸造形法</h2><p>用剪刀或锋利的刀片作一系列的自由式剪纸。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716122936.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="烧纸造形法"><a href="#烧纸造形法" class="headerlink" title="烧纸造形法"></a>烧纸造形法</h2><p>烧烤一个基本形状的边和角。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716122947.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="随意造形法"><a href="#随意造形法" class="headerlink" title="随意造形法"></a>随意造形法</h2><p>随意造形，然后从中选出一个单个形状或一个复合形状。把选好的形状剪下来或涂成黑色以资鉴别。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716122956.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在做了这样一些简单练习之后，你会对自己鉴赏力和观察力提高的程度感到惊讶。</p>
<p>原来在物体和物质的平凡的外表下面隐藏着的耐人寻味的各种形状，现在都展现在你的面前并且受到鉴赏。</p>
<p>你发现得越多，你就越要去探索，于是，你就越加为自己新养成的感受能力和观察觉能力而感到欣慰。</p>
<h2 id="单个形状的拍摄"><a href="#单个形状的拍摄" class="headerlink" title="单个形状的拍摄"></a>单个形状的拍摄</h2><p>现在正是大好时机，可以开始拍摄由单一形状控制画面的照片了。<br>但是需要提醒一句，当你通过取景器观察的时候，单纯的以录像为目的的老习惯时时有抬头的危险。<br>有一种偏见，认为摄影的主要目的就是要无比清晰地捕捉每一个细节，从而显示你的镜头质量是如何高超。<br>摄影家必须不断地和这样的想法作斗争。</p>
<p>拍摄单个形状时，我们的目的是发现有意义的形状，并把它突出出来。<br>找到这种形状之后，往往因它所处环境不够理想，就要上下左右地调整你的位置，直到取景器中出现的形状满意为止。<br>然后就要集中精力简化背景，以突出这个形状。这个过程可能可迫使你作出必要的让步和调整，迫使你作出决定：究竟需要作怎样的删节才能达到突出主体或简化背景的目的。</p>
<p>为了简化背景，也许不得不拍摄一个姿态不太理想的形状，如果现有光线不能使形状和背景分开，不能使两者保持足够的对比，可以使用人工辅助光以达到预期的效果。常常可以加大光圈，限制景深以大大简化背景，这样做能使背景的细部显得模糊。</p>
<p>你可能会考虑到图形与画面的相互关系，但是在拍摄当时要做出明确的决定是不太可能的。以后，在印制照片的过程中，会有适当的机会来试验各种布局、尺寸和画面安排，以便找出一个最满意的相互关系。</p>
<p>现在所以考虑到图形与画面的关系，无非是要表明应该注意从多方面去考虑，因为从多方面考虑才是艺术摄影所必需的和应当培养的一种思想方法。除了变化迅速的场合之外，拍摄一张照片花费多少时间都无关紧要。有时候，一切构图要素都能迅速安排妥当，很快就能拍摄完成。然而，有时候为了寻求最佳形状，要移动位置；为了使背景简化和柔化，要在主体和背景之间进行调整；为了完美地再现主题，要等待最理想的光线。这一切都需要花费很长的时间，然而却十分引人入胜。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123159.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="直观构图"><a href="#直观构图" class="headerlink" title="直观构图"></a>直观构图</h2><p>到这里为止我们所介绍的大多数材料完全是通过直观，通过构图设计过程中的即兴安排来控制的。每一个活动都完全听命于个人的感受和判断，而不是受通常的衡量标准的支配。</p>
<p>完全直观的构图设想包括:</p>
<ol>
<li>形状的设计。</li>
<li>画面的设计。</li>
<li>形状对画面的相对尺寸。</li>
<li>形状在画面中的布局。</li>
<li>背景空间的安排。</li>
</ol>
<p>其实，大量的艺术创作都是直观的，大部分构图也是如此。不可能有什么规则，因为任可规则只能抑制个人的即兴表现力，并导致作品题材陈旧、千篇一律而令人生厌。</p>
<p>很多卓越的摄影家创作出的优秀作品，并且自己也认识到这一点之后，他们才开始分析那些艺术作品所遵循的标准，并提出指导他们今后工作的一些原则。</p>
<p>自从摄影变成了文化的组成部分以后，摄影家们也一直考虑同样的问题。特别在过去的一百年里人们花费了很多心思，去研究那些影响构图要素的设计原理。有些原理，如大小、方向、明暗的对比和突出地位等，在摄影练习指南上都曾提及。这些原理，以及一些类似的原理都将在以后的各章中充分展开讨论。</p>
<p>清楚地了解这些原理，对于解决任何构图问题都大有裨益。<br>特别当牵涉到两个或更多形状的结合问题时尤其如此。尽管读者现在对这些原理还没有充分理解，但并不是说对它们毫无体会。</p>
<p>因此，姑且把本章下面要提出的一些问题放在纯綷直观的基础上去讨论。以后，当读者对这些原理充分理解和接受时，再对本章所述的直观构图及其效果重新评价。我们常常发现，潜在意识会引导我们获得新奇的成果，而这些成果最终是能理论化并得到充分论证的。</p>
<h2 id="两个或多个形状的构图"><a href="#两个或多个形状的构图" class="headerlink" title="两个或多个形状的构图"></a>两个或多个形状的构图</h2><p>虽然在自然界人们偶然也能发现只有单个形状的画面，但是很多拍摄题材则包含两个或更多的形状。这里，简单的绘图和剪纸仍是我们作试验的有效手段。</p>
<p>剪下两个不同比例的矩形，一个用黑纸，另一个用白纸。然后用灰纸剪下很多不同尺寸和比例的画面，画面的大小要能容纳得下这两个形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123235.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>首先试验两个矩形在画面中的各种布局，两个矩形不要相接触。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123253.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>然后布置这两个形状使它们在边、角处互相接触。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123303.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>随后，安排它们互相遮挡。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123315.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在，我们再选各种画面，继续试试布局。任一形状稍一移动都会使背景空间发生变化，这些变化都要一一牢记。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123327.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="空间的划分"><a href="#空间的划分" class="headerlink" title="空间的划分"></a>空间的划分</h2><p>下面的课题表明，要想用一些横线，竖线构成各种矩形以达到有效地划分空间的目的，需要进行何等强度的思考和判断练习。</p>
<p>先画一个画面。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123338.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>加上一条竖线，构成两个矩形，使两者保持适当的关系。其中一个矩形应充分突出同时并不埋没另一个矩形。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123345.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>加上一条横线，形成四个有趣的矩形——各不相同，却十分协调。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123352.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>继续增加竖的和横的单线和双线，有些延伸到边框的最外沿，有些延伸到图形内部的线上。在加上每一个线条之前，应仔细考虑新出现的矩形，以及整个构图是否富有情趣。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123406.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>用铅笔把某些形状涂成暗调或中等色调，试看会发生什么变化。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123413.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这个方面是由二十世纪一个荷兰艺术家皮埃特􀂷蒙德里安发展起来的，他认识到把艺术简化成最简单的形式的价值。<br>大多数初学者看到了蒙德里安的作品都认为它们并不难画，然而那些模仿者（而不是抄袭者）却发现，要创造一个满意的布局比他们所想象的要难得多；而且还发现通过这种练习获得的学问是相当奥妙也是十分有用的。</p>
<p>上述的设计图是由一些交叉的线条构成的，在线条之间小心地留出间隔，从而构成很多矩形。它们的大小、方向和比例各不相同，但却互有联系。<br>下面讲的构图是这个方法的变化形式，但是和前边一样也要考虑如何使图形的相互关系富于变化和情趣。这个图形的整个印象是人们在任何城市环境中都能感受到的。</p>
<p>用黑纸或白纸剪出一些不同尺寸和不同比例的矩形，其中有些形状可剪出两份，有些则可剪出三份。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123422.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>把这些形状垂直地或水平地布置在灰纸作成的画面中，这些形状可以分开安排，也可以在边上或角上互相接触。<br>你给每个矩形定位时都要考虑如果把它放在毗邻矩形的旁边会成什么样子，并要考虑它对整个构图的外观产生什么影响，尤其要考虑背景空间的大小和形状。<br>由于每个矩形都起着分界线的作用，现在的背景空间就是灰色部分。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123432.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>前面两上问题都以横竖矩形为构图基础，这种构图原理在实际摄影中十分重要。</p>
<ol>
<li>收集大量的矩形盒子和盒盖，它们的高度、颜色和比例要各不相同；可以是空白的，也可以是印过的。把它们布置在地板上或桌子上，用灰色、白色或黑色的纸或桌布做底子。<ol>
<li>首先用反射光拍照，反射光从正上方照射画面。</li>
<li>再用直接光拍照，光源应有适当的角度，使高盒子的影子投在矮盒子上，构成半透明的矩形，这样会使构图更加有趣。</li>
</ol>
</li>
<li>通过一间屋子的门道观察另一间屋子，注意观察各种矩形，如家具、照片、窗户、窗帘、阴影、装饰线条以及地面所形成的矩形。选择一个观察点，以便能够看到这些矩形的有趣变化，稍微带上一点墙壁的会聚点的变化，拍一张照片。</li>
<li>每一个居民区、商业中心、办公地区，事实上也是建筑物的集中的地方，都充满了门、窗、楼道、路标、壁板和台阶。所有这些都是矩形。在这种区域中选出一个拍摄主体，使它尽量包括各种有趣的矩形，拍成照片。</li>
</ol>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123444.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="各种艺术风格的相互依存关系"><a href="#各种艺术风格的相互依存关系" class="headerlink" title="各种艺术风格的相互依存关系"></a>各种艺术风格的相互依存关系</h2><p>每一个专门从事某一门艺术的人，往往由于对他那门艺术过分专心致志，以致忽略了各门艺术只有互相依存才能形成文化的整体这样一个事实。<br>艺术是各个时期占统治地位的社会的、政治和经济力量的反映。当这些力量发生变革时（它们确实是不断变革的），必然要在艺术上反映出来。</p>
<p>在过去的年代里，一些重要的变革最初需要几百年才觉察得到；后来，便缩短为一百年；而最后，到了十九世纪，则只隔大约二十五年的时间。每次变革都给各种艺术的表现形式带来了实质性的变化。<br>音乐、戏剧、舞蹈、文学、建筑以及绘画和雕塑都同时受到类似的影响。一代人认为是重要的东西，下一代人认为已经过时了。当然也有许多人总是喜欢老作品，而不喜欢“稀奇古怪”的新东西，而且在大多数情况下，保守主义受到有钱人的支持。<br>然而，新的风格最终是要确立的，但它又会随着时间的推移而过时。</p>
<p>在二十世纪，特别在二十世纪后半期，这个进度加快了。我们刚刚习惯于某一艺术风格，就发现它又被新的所取代，没有一种风格能在十年以后仍然保持盛而不衰。<br>所以，二十至二十五年以前的照片就显得过时了，而且要比照片的内容，如建筑、室内设计和服装等过时得多。这里面部分原因可归结为构图风格的不同。</p>
<p>有一个时期，照片上出现了大片黑暗区域，明暗对比强烈，边缘模糊不清。又有一个时期，强调的可能是起伏的曲线，使人联想到植物的形状。<br>而在以后的时期，可能转而注重衰败和毁灭，内心的奥秘，非人类所表现出来的人类外观，互不相关的瞎涂乱画以及人类生活中那些最为平庸陈腐的细节。</p>
<p>在研究矩形设计时，学习摄影构图的人应该培养自己善于意识到生活中所存在的矩形形状，如公共汽车和火车、室内和室外、图书馆中、火车站里、商店里、街道上、标牌上以及建筑工地上的各种矩形。</p>
<p>此外，还应该观察画家和雕塑家们在做些什么，观察商店的内部和外部是如何设计的，特别是要注意那些为广告和社论材料设计版面的艺术家们在创作些什么。<br>为图书、杂志、报纸和电视而工作的艺术家以及广告画设计师，具有长期研究矩形形状的经验，往往可以从他们那里获得对摄影有益的启示。即使别无所获，至少也可学会如何鉴赏好的和时兴的艺术形式。</p>
<h2 id="规则形状和不规则形状相结合的构图"><a href="#规则形状和不规则形状相结合的构图" class="headerlink" title="规则形状和不规则形状相结合的构图"></a>规则形状和不规则形状相结合的构图</h2><p>请设计出一个不规则的形状或者从前面的试验中选出一个，用铅笔把它画出，使它的尺寸在画面中占据显要的地位。试验多种布局方法，直到你认为满意为止。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123457.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>再增加一些几何形状或自己设计的形状，记住它们互相搭配之后的形象和整个构图的效果。在图形上加些铅笔色调，造成黑、白和灰的效果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123504.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>再用剪好的纸像以前那样操作，灵活地移动画面中各个形状，使布局更加协调。用黑、白、灰纸剪出一些几何形状，或自己设计的形状，使尺寸和形状各不相同。<br>把它们配置在一个矩形画面里，如果有必要的话，可再加以剪切或移动，直到构图满意为止。然后用浆糊把它们定位。<br>完成之，把构成的图形挂在墙上，研究形状、色调和背景空间的相互作用。要十分留意整个构图的协调性：哪一部分效果最好，哪一部分需要改进，以及如何改进。</p>
<p>这种自己评价的办法是一重要的创作方法。它可以不断发展，并且为你奠定一个基础以便不断提高敏感性、创造性和构图水平。</p>
<p>做这些试验的目的，是为了提高对几何形状设计和不规则形状设计的鉴赏能力，并且认识这类形状对构图的影响。<br>虽然我们在前面把铅笔画和剪纸作为初步经验向大家作了介绍，但我们的主要目标是要培养对自然界和文明世界的更敏锐的审美感。<br>这样，当摄影家遇到自然存在的各种杂乱的细节时，便能够根据个人的判断，选择那些有用的要素，以加强拍摄对象的视觉效果。<br>在下面各章中，我们将讨论的原理是如何使构图和谐并富有表现力。</p>
<h2 id="表现各种形状的照片"><a href="#表现各种形状的照片" class="headerlink" title="表现各种形状的照片"></a>表现各种形状的照片</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123513.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-16/20240716123526.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 揭开平衡的真象</title>
    <url>/2024/08/31/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E6%8F%AD%E5%BC%80%E5%B9%B3%E8%A1%A1%E7%9A%84%E7%9C%9F%E8%B1%A1/</url>
    <content><![CDATA[<p>在虔诚的学习摄影的人听到的全部废话中，关于平衡原理的说教要算最没有意义的了。<br>这些学生，原来是渴望提高自己的美学修养，结果却上当受骗，成了那些自命不凡的“专家”的牺牲品。<br>这些“专家”除了精通构图的词藻以外，实际知识很少。</p>
<p>拍照片的人都有一个共同愿望，就是希望自己的作品能够赢得观众，博得赞赏。<br>为了提高照片质量，许多人认真地接受强加于他们那些批评。<br>这些所谓批评家，既没有能力也没有兴趣提供什么建议性意见。<br>他们总是企图用那满腹高深的学识去说服艺术家和愿意听他的人。<br>事实上，那些学识不过是关于平衡的肤浅的空话而已。<br>也许因为平衡看起来来常明确，似乎又是最容易理解的构图原理，所以，它就成了人们评价照片的最常用的依据了。</p>
<p>我们经常看到，当那些自封的批评家告诉有才能的学生说，他们的照片应该如何如何改进才能使它平衡时，这些学生被弄得多么困惑不解！<br>许多容易理解，富于表现力的构图本来具备了情趣、动感和活力，结果被这个倒霉的主意弄成了荒谬呆板的平衡状态。</p>
<h2 id="对称平衡"><a href="#对称平衡" class="headerlink" title="对称平衡"></a>对称平衡</h2><p>据说儿童在接触艺术的初期，就有一种天生的强烈的要求——从中心垂直地分割画面。<br>当然这只是我们感觉出来的，而不是儿童明白表示出来的。<br>因为他们画面的时候，总是在画面的一侧画出和另一侧对称的图象，就像镜子里照出来的一样。<br>显然，儿童是下意识地满足于房子、花朵、树木、山丘和人物的对称结构，虽然从成年人的现实观点看来，这些画未免显得可笑。<br>许多成年人也没有超越这个艺术修养的初级阶段。<br>他们在布置房间的时候，让房间的一边和另一边对称而平衡，才觉得舒服。<br>偶尔在别人怂恿下，按照家具的用途或比较随便地安排房间时，他们才会背离绝对对称的原则，但也不会走得太远。</p>
<p>在艺术史的初期阶段，艺术家们所以按照对称的格局构图，有三个原因。</p>
<p>第一，因为他们的画是宗教建筑中实用的装饰部分，所以必须遵循整齐和对称的建筑设计要求。</p>
<p>第二，因为当时除了特权人物，都没有阅读能力，所以为这画必须传达宗教的和伦理的训示；<br>它们常常是通过象征的形式表达的，因而必须简单明了。</p>
<p>第三，大胆的、新的构图观念还没有实验出来和建立起来。<br>无论艺术家还是观众，都要经过漫长的教育过程，才能从简单粗犷走向复杂精巧。</p>
<p>但这并不意味着要贬低对称构图在绘画和摄影中的价值。<br>有些主题，特别是那些庄严、神圣、需要装饰、注意形式的主题，对称是最好的表现形式。<br>需要表现纪律、严谨和稳定的时候，对称布局也是最适当的。<br>其所以如此，一方面是由于它的整齐严肃，另一方面也是由于传统的联想样作用。<br>在政府和宗教场所，经常能遇到需要对称安排的主题。<br>偶而，我们在大自然中也能发现有趣的结构严谨的形状，使人联想到严肃和整齐。</p>
<p>在现代，除非在那些最保守的场合，对称的或严格的平衡——有时人们是这样叫的——已经不常用了。<br>正因为不常用，它的简单明快的特点就特别引人注意，它那直率、庄严、有时是古雅的力量就特别能够吸引人。</p>
<h2 id="平衡的传统观念"><a href="#平衡的传统观念" class="headerlink" title="平衡的传统观念"></a>平衡的传统观念</h2><p>历来，人们都把天平和跷跷板看作是解释平衡现象的最好的例子。<br>对称平衡，就是把重量相同的物体放在离中心（支点）距离相等的地方，因而跷跷板能够在水平位置上保持平衡。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125640.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125657.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>下面的跷跷板的透视图表现了对称平衡的一种变化形式。<br>力量似乎是大致相等的，可是，支点却移到了画面空间的深处。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125706.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>下图体现了这一原理。<br>左边前景上的建筑，可以说是和右边远景中的建筑相平衡的，支点大致上应该在两个房子中间的透视中心处。<br>从每座建筑物到邻近的边框的距离大致相等的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125716.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>粗略地看来，人们可能相信这个关于平衡的推论是符合逻辑的。<br>可是眯起眼晴仔细研究一下这张照片，就会发现这个推论实际上是根据不足的。</p>
<p>从影调上看，前景上的建筑消失在背景之中，已经完全谈不上对比了。<br>屋顶和栏杆的线条不是把这座房子从背景上衬托出来，而是把视线引向了那座明亮的建筑，从而使它占据了优势地位。<br>道路所起的作用是进一步把注意力从前景上引开。</p>
<p>此外，还有两个强有力的因素，加强了远处那座房子的优势地位：<br>其一，是它和背景之间的影调对比，其二，它是照片中唯一一个水平形象，和所有其它斜线对照起来，对比十分强烈。</p>
<h2 id="非对称的平衡"><a href="#非对称的平衡" class="headerlink" title="非对称的平衡"></a>非对称的平衡</h2><p>大多数调皮的构图，是由非对称平衡（有时叫不规则平衡或隐性平衡）构成的。<br>假设想象中的垂直中线仍然存在，但在两边不是镜象那样对称，而是在大小、形状、明暗和布局上有着很大的差异。<br>平衡是通过力量均等建力起来的，不管它是否相似。</p>
<p>把一端的物体，换上两个或两个以上较轻的物体，使它们的总重量仍和原物相等，这时候便产生了非对称平衡。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125726.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果我们不去仔细研究一下这种平衡状态对照片和艺术家具有多么大的影响的话，我们会以为它是值得一用的，或者，最多不过是没有多大妨碍而已。<br>求平衡中最伤脑筋的问题，是要考虑物理因素和数量因素，特别是重量因素，它似乎成了取得平衡的决定性手段。</p>
<p>问题的复杂之处在于，为了取得某种形式的稳定，必须先确定每一物体在构图中的相对重量。<br>背景空间对重力的影响是正的呢，还是负的？<br>背景空间本身表示沉重呢，还是表示轻飘？<br>是不是一个情绪激动或积极的被摄体比一个消极的被摄体为重？<br>一个细长线条和一个小块形状，一个明亮区域和一个黑暗区域，一个粗糙质地和一个光滑质地——这一切之间，怎样才算重量均等呢？<br>几何图形比不规则图形重到什么程度呢？<br>最后，一个最根本的问题是，有没有必要建立绝对平衡？<br>是否有必要以稳定为目的？<br>如果“打破平衡”更能表现艺术家的创作意图的话，难道有些照片不可以这样处理吗？</p>
<p>从视觉表现上说，我们可以在画面中心的一侧安放一个大图形，而在另一侧安放两个或更多的小图形。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125736.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这种平衡的变化形式是，让一个较重的物体离支点近些，而较轻的物体离支点远些，这样来使一个较重的物体与一个较轻的物体之间建立平衡。<br>这是一个关于力矩的物理现象，每一边的力量是用物体的重量乘它到支点的距离求出来的。<br>如果乘积相等，便可取得平衡。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125746.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在形象处理上，我们还可以让大图形离画面中心近些，而小图形离画面边框近些，这样来取得平衡。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125754.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这里就出现了完全不合逻辑的情况。<br>我们在布局实验中已经看到，当若干个形象同处一个画面中时，离画面中心最近的形象通常是最能引人注意的。<br>如果我们把大图形所具有的较大吸引力和所处的优势地位考虑在内，怎么能承认图四四八是平衡的呢？<br>小图形离中心那么远，它有什么力量克服占据中心的大图形的巨大吸引力呢？<br>如果当小图形离画面边缘很近，特别当另一个图形、一个更强有力的图形被安置在靠近画面中心时，小图形便要失去它的吸引力了。</p>
<p>有趣的是，如果我们把小图形干脆拿走，大图形仍能非常好地保持着平衡。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125807.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>我们还可以进一步试验，结果证明，对上述原则作相反的处理，倒是更加合理些。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125819.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="物理力和视觉力感"><a href="#物理力和视觉力感" class="headerlink" title="物理力和视觉力感"></a>物理力和视觉力感</h2><p>在构图中，如果把物理力和视觉感等同看待，往往会造成错误。<br>重力作用在物理现象中是有实际影响力的，但在照片里，它除了引起联想以外，不起实际作用。<br>一定体积的木材，其重量比相同体积的铁要轻得多，但是它们的视觉效果可能是相同的。<br>二者之中的任意一种，都能通过画面安排和环境处理而显得更加重要。</p>
<p>在物理量和视觉力感之间不可能通过量或质的表现来确定等量关系。<br>所有大小、形状、明暗、质感和方向的对比都能改变照片的吸引力。<br>节奏、布局和统一也能影响照片的总结构或结构的某一部分，也能影响我们观看照片的方式。<br>重量、运动和重力之间的类比对视觉趣味毫无关系。<br>一根衬托着暗调背景的明亮的羽毛，如果被作为前景安排在靠近画面中心的地方，就能很容易地压倒画面任何部位的满载铁矿石的一列火车。</p>
<p>图四五二可以说是表现了物理力的平衡关系的。<br>我们相信，平衡原理的维护者一定会认为这是一张符合平衡要求的照片，甚至能够用图解的办法标出起平衡作用的各个力点。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125831.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果我们把画幅改变一下，让趣味中心向左或向右移动，画面的平衡状态依然保持不变。<br>但视觉效果却大受影响。<br>试问，现在我们应该说它是平衡呢还是不平衡？</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125841.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125851.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这两张照片所表现的思想稍有不同，然而这种不同只是画面布局和背景空间的不同的结果。<br>根本和平衡无关！</p>
<p>因而，把物理力和视觉力感等同看待是不妥当的，即使偶而一用也是行不通的。<br>如果我们的目的是求得视觉平衡，那只有通过视觉力感。</p>
<p>这里我们又遇到一个难置可否的问题，即需要确定主体的哪些部分具有吸引力和是否平衡的问题。<br>谁能权威地宣称某个拍摄对象对比另一个更有意义呢？<br>事实上，是否有意义是根据各人的爱好，体验和反应来决定的。<br>任何人也无法替别人决定某一形状，某一影调对比，某一线条走向的吸引力大于另外一个。<br>对于每个人来说，他会有意识地同时也是下意识地偏爱这个或偏爱那个。<br>这个很大大度上取决于画面一部分同另一部分的相互关系，以及这个部分同画幅形状与特征的相互关系。<br>在这个过程中，心理上的爱好往往起着很大的作用，因为吸引力是随着艺术家也是随着观者当时的情绪以及以后的情绪变化而有所不同。<br>好奇心，这个与画面感染力极为有关的因素，是非常不稳定的，不仅人与人之间有所不同，一个人在不同的时期也不一样。</p>
<h2 id="假想垂直中轴线的顽固性"><a href="#假想垂直中轴线的顽固性" class="headerlink" title="假想垂直中轴线的顽固性"></a>假想垂直中轴线的顽固性</h2><p>平衡中一个值得注意的问题是，人们总是假定存在着一条想象中的但却无时不有的垂直中轴线，它是起支点作用的。<br>只要让这条中轴线两边的重量相等，就能保持平衡。</p>
<p>首先，我们不得不对这条线的中心地位发生怀疑。<br>照片是根据主体的特征确定自己的结构的，而主体和中心位置很少有关。<br>据我们所知，趣味中心不一定要在画面的实际中心上，所以，如果能够看到或感觉到这样一条中轴线的话，那它也不一定就是在画面的中央。</p>
<p>下图中趣味中心是放在照片中垂直的视觉中心上的，但它并不靠近画面的垂直中轴线。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125900.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>有些照片，像下图，是按照对角线或斜轴安排的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-31/20240831125916.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>还有一些照片的轴线，是按排在不规则、不完整的线条上，另外一些则安排在进入画面两边的流畅曲线上，甚至有的把画面从水平方向截然分开而没有垂直线。</p>
<p>垂直中轴线或者任何这类东西，有什么神圣不可侵犯的呢？<br>不过是因为在儿童的图画里出现过，成年人在摄影中把它作为不高明的基本功继续使用罢了。<br>有理由相信，儿童是间接从成年人的行为中或从他们自己的生活经验中学到这种容易做到的方法的。</p>
<p>照片不是油画，无论如何它与文艺复兴早期的纯朴的油画不同。<br>没有理由去死守那些毫无用处的关于平衡的规则和原理，它们对摄影艺术形式毫无意义。</p>
<p>摄影教师、摄影著作家和评论家，被那些关于画面重量问题的糊涂观念弄得晕头转向，这种现象比其它艺术领域更为严重。<br>大块形状被认为“更重”一些。<br>但透过树木观看大片天空或水面时这样的说法能成立吗？暖色比冷色“更重”,强烈的色彩比柔和的色彩“更重”，质地粗糙的表面比光滑的表面“更重”。<br>和许多别的事情一样，这些说法有时候是对的。<br>本书作者还记得，这种说法曾深深地印在他们的脑海里，说什么大片暗区必须放在照片的下方，不然的话，它就岌岌可危，像是要从高处滚下来。</p>
<h2 id="稳定的必要必性值得怀疑"><a href="#稳定的必要必性值得怀疑" class="headerlink" title="稳定的必要必性值得怀疑"></a>稳定的必要必性值得怀疑</h2><p>平衡、均衡、对称——所有这些字眼都包含着稳定的含义。<br>这一原理的目的是指引艺术家取得力量的均等。<br>但这样做的结果，往往是超过了稳定的需要而造成画面呆滞。</p>
<p>在有些照片里，稳定可能是值得追求的，它也完全符合主题的需要和艺术家对主题的感受。<br>对另外一些主题和同一主题的其它表现手法来说，稳定可能不是所希望的结果，由于过分雕琢和仔细地事先安排而显得缺乏刺激、过于拘谨、不够自然。<br>而那些不平衡的形象，倒是有助于唤起强烈的情感和动感。</p>
<p>夸张是一种艺术手段，它能突出地表现艺术家对于主题的感受。<br>大部分优秀照片都是通过这种或那种形式被夸张了的。<br>正像我们所了解的那样，如果对平衡怀有强烈的兴趣的话，实际上就不可能做到有效的夸张。</p>
<h2 id="用直觉处理平衡关系"><a href="#用直觉处理平衡关系" class="headerlink" title="用直觉处理平衡关系"></a>用直觉处理平衡关系</h2><p>那么，在构图中摄影家究竟应当在什么时候，在多大程度上关心平衡呢？<br>我们的建议是根本不必要过多地考虑这个问题。<br>如果主题要求平衡，你也认定了要用这种方法加强表现时，那就全力以赴。<br>即使遇到了重量这种问题时，也不必受我们在本章里所讲的反对理由的限制，也不必受你从其它方面所接受的条条框框的束缚。<br>我们的意图只是想驳斥一下，在平衡问题上过分强调重量这样一种传统看法。</p>
<p>相反，如果主题本身不是强烈的平衡结构，你也不想用这种方式去表现它，那照片就已经是平衡的了，你也不会觉得有改变它的必要了。<br>如果摄影家建立了某程度的稳定性，或者虽不稳定，但在他看来这是符合他要求采取的表现主题的方式的，对这些他都感到满意，这也就是平衡。</p>
<p>直觉是最可靠的向导。<br>没有必要去揣摸怎样才能影响、集中和吸引注意力。<br>如果画面需要某种形式的调整，你会自动地有所反应，并会根据需要加以取舍。</p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 线条</title>
    <url>/2024/07/19/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E7%BA%BF%E6%9D%A1/</url>
    <content><![CDATA[<p>线条在我们的视觉感受和思维活动中所占的地位如此重要，以致人们很难接受这样一种事实，即线条在自然界中是根本不存在的。<br>线条是人们发明出来的，以便用它来确定固定物的边缘界限和物体表面的连接处。<br>它很可能是远古文明中用以交流视觉信息的最初手段。</p>
<p>由于线条在我们的日常生活，书法和绘画中所占比重极大，所以我们坚信线条是表达事实、想法和感情的一种清楚而明确的手段。<br>线条能明确地表示方向、长度和感觉它能使那些用线条作画及看画的人都得到很大程度的满足。</p>
<h2 id="对自然界和人造物中线条的观察"><a href="#对自然界和人造物中线条的观察" class="headerlink" title="对自然界和人造物中线条的观察"></a>对自然界和人造物中线条的观察</h2><p>既然自然界中并不存在线条，那么，摄影家怎么能把线条应用于他的摄影艺术呢？<br>要知道，我们周围有许多物体，它们的宽度非常小，以致在照片上完全可以把他们看作线条，比如电话线、电线、电视天线、树枝以及植物的纤细部分（特别是芦苇和高大的禾本科植物）、晒衣绳、船缆以及桥上的铁索。</p>
<p>有些形状和它的长度相比显得十分纤细，所以也可以看作是线条——虽然它们较粗，但毕竟还是线条。<br>这种线条包括旗杆、电话线杆子、路灯柱、不粗的树树木、绳子、园林浇水用的软管、小路、各种篱笆、线状云、水面涟漪、动植物的骨架、木质建筑物和钢铁建筑的框架，小溪以及火车铁轨等。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-19/20240719124902.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>很多细长的阴影，象墙板和迭披墙板的接缝、墙壁和地板的裂缝、窗框、砖石墙壁的接缝所投下的阴影。以及树木和杆子在地面的投影等，由于很细，往往只能摄成线条。</p>
<p>实际上，这种例子是不胜枚举的，要是你愿意，完全可以对线条的表现力进行一番专门的研究。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-19/20240719125033.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>另外，各种形状的边缘，墙壁和天花板、地板的衔接处，自然物和建筑的剪影的边缘，布的绉褶以及耕后田地的犁沟等，都可以间接地产生线条。</p>
<h2 id="理解线条的特性"><a href="#理解线条的特性" class="headerlink" title="理解线条的特性"></a>理解线条的特性</h2><p>在我们周围到处存在着大量的拍摄题材和构图要素，可供我们拍成优秀的照片。我们必须不断提高自己的洞察力和鉴赏力，并努力提高具体运用它们的能力。<br>我们应该善于观察题材内在的视觉要素。当我们观察船、帆、桥、树、房屋或人物的时候，应该撇开它们的一般特征，而把它们看作是形状、线条、质地、明暗、颜色和立体物的结合体。<br>只有把深入的研究精神和强烈的个人兴趣结合起来，才能养成这样的观察能力。</p>
<h2 id="线条的语汇"><a href="#线条的语汇" class="headerlink" title="线条的语汇"></a>线条的语汇</h2><p>在你到自然界中去寻找各种线条之前，最好对已有的丰富线条类型有所认识。<br>培养这种鉴赏能力最好方法，是勾画各种具有不同特点的线条。下面的大部分线条虽然都是画成水平方向的，但同样适用于垂直线、对角线、曲线以及线条的组合。</p>
<p>无论你创造出什么样的线条来，都可以保证你在视觉世界里找到某种类似的形态，不论是自然物的形态还是人造物的形态。</p>
<p>线条的形式多不可数，这里只举几个例子。</p>
<p>我们从规则的机械线条开始：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123119.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>把这根直线加组，使它显得具有信心和力量；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123146.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>把这根直线变为一系列急促、活跃的短线；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123157.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>再把它画得毛糙一些；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123208.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>或画成细小轻巧的波纹；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123319.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>然后让它轻轻颤动；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123331.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>可以画成粗犷的线条；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123338.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>可以画得疏松轻软；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123347.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>可以画得断断续续；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123356.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>可以画成点线；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123407.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>或画成一串珠子；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123423.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>也可画成连绵的曲线；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123437.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>可以使它折来折去；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123448.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>画得蜿蜒曲折；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123500.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>画得湍急零乱；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123607.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>画成优美的起伏线；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123619.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>由粗变细，飘然而逝；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123630.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>呈滚滚波涛状；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123642.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>隆起、展平而至破碎；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123654.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>呈蜿蜒迂回的运动；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123710.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>甚至在没有线条的地方也会感到存在着线条。譬如，当手指、箭头或其它指示物把注意力引向另一处的某一物体时，就会产生这种感觉。</p>
<p>有浅度曲线；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123747.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>深度曲线；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123847.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>螺旋线；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123856.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>书法线条；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123904.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>火焰似的曲线；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123914.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>用尖头画笔蘸墨水在平滑的纸上画几根线条；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123926.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>然后画在粗糙的纸上；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123936.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>当画笔快干时，画出的线条又是如此不同；</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724123949.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>收集一批非正规的绘画用具，包括树技、羽毛、尖角布头、一节细绳或链条、铁丝、骨头、麻绳、树叶以及有光边或毛边的硬纸板和木头。<br>把每件东西蘸上墨水或颜料，然后作划线试验。<br>这些东西中每一样都可以划出具有不同性质和感觉的图形，这些不同的效果是由它们各自的物理特性和它们在特定表面上的移动情况所造成的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724124025.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>当你绘出这些图形时，请注意你的目光是如何强烈地被引向这些线条运动的方向，并体会你的视觉是如何感受着这些线条的突然变化，感受着它们的含蓄或粗犷，曲线的隆起或动态的优美。</p>
<p>现在，你已经掌握了大量的关于线条的语汇，可以到大自然中去，在你的周围环境中寻找和发现富有表现力的各种线条了。</p>
<p>开始的时候可能收获不大，一旦取得了观察经验，就会迅速获得成果。在有些情况下，你只要浮光掠影地瞟上一眼就可能发现线性特征。而在另外一些情况下，却极为需要深入钻研。你甚至会因此而发现很多有意义的题材，从而拍出许多高质量的照片。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724124105.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-24/20240724124115.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="画面中的线条"><a href="#画面中的线条" class="headerlink" title="画面中的线条"></a>画面中的线条</h2><p>我们在《形状》一章中所探讨的许多理论都适用于线条。照片中的任何一个内容，如果不是为了提出作专门研究，就不能看作是孤立的东西。因为任何一个内容都和其它内容密切相关，而且还影响着背景空间和整个画面。</p>
<p>在下面各图中，画面和垂直线条都一模一样，只是布局有所不同。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-28/20240728110417.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在第一图中，垂线居中，所以垂线和左右边框的距离以及垂线两端和上下边框的距离都相等而固定。</p>
<p>在第二图中，左右两侧的距离发生了变化，产生了不同的相互关系。右侧的空间较为突出。</p>
<p>在第三图中，垂线紧靠边框，所以它和左侧的联系比和整个画面空间的联系要密切得多。画面空间大为突出，以至垂线本身失却了影响力。</p>
<p>把垂线稍稍上下移动一下，就会使总的效果产生重大变化。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-28/20240728110431.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>把同样长度的线条水平地置于同一画面里，也会发生类似的重大变化。还应注意，把线条横放会使画面变得多么不一样。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-28/20240728110450.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果改变了画面本身的形状，效果就会发生更大的变化。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-28/20240728110500.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在用铅笔或钢笔在不同形状的画面里画出水平线和垂直线各若干条，使它们之间产生有趣的相互关系。不要去理会这会不会和自然界中某种物体相似，甚至也不要去思考这种构图是不是和你以往见过的某种物体雷同。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-28/20240728110508.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>由于我们已经脱离了单一线条，所以不必再去研究每条线的单独特性，而必须去体会线条之间的总体关系。</p>
<p>不要以为这里所研究的视觉概念过于简单或肤浅。最复杂的思想往往寓于最简单的表述之中。这些研究的目的仍是要提高你的观察力，培养你对线条排列的敏感性；这样，在你遇到了能表现这些原理的主题时，你便能够认识它们，并且拍出有价值的照片来。</p>
<p>要给你自己规定一项任务——留意这样的题材：它们的水平线条和垂直线条都很突出，而且形成有趣的并列关系。当你去寻找一些以线条为主的题材时，你会发现有些题材可能整个地用线条来表示，但你也应该设法把其它一些形状和视觉要素也包括在这个构图里。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-28/20240728110524.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在你原有的试验基础上再逐渐增加斜线和曲线，继续作试验，先用铅笔和钢笔，然后，再出去作一次野外观察。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-28/20240728110537.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-28/20240728110547.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="线条的象征性联想作用"><a href="#线条的象征性联想作用" class="headerlink" title="线条的象征性联想作用"></a>线条的象征性联想作用</h2><p>原始人用象征物作为一种本能的视觉语汇来表达口头语言还不能表达的感情和思想。<br>这类象征物已经深深扎根于我们的文化传统当中，所以当代精神分析家十分重视象征性联想和暗示交流之间的关系。<br>他们通过象征物来发现病人内心深处的愿望、需要和恐惧。</p>
<p>长期积累起来的经验告诉我们，特定的感情往往和某些物体或现象相联系，而这些物体本身又和某种特定的形状相联系，从而，形成了一种传统观念，即把线条的位置和方向当作一种象征，它能使人们产生一定的联想。例如：</p>
<p>垂直线代表生命、尊严、永恒、权力以及抗拒变化的能力。</p>
<p>水平线趋向于表示寂静和安定、大海的平静、死亡、大地和天空。</p>
<p>斜线意味着行动、危险、崩溃、无法控制的感情和运动。</p>
<p>参差不齐的斜线使人联想起闪电、意外变故和毁灭。</p>
<p>圆形的和隆起的曲线象征着大海般流畅的运动，象征着优雅、色情、成长和丰产。</p>
<p>垂直和水平线条的结合使用表明人造的结构。</p>
<p>尽管有些人由于对事物有较强的敏感性，有较高的文化素养和丰富的经验，因而对象征性的联想容易有所反应，但并不意味着大多数观众总会产生同样的反应。<br>如果摄影家的摄影创作是为了某些物定的观众，这些观众能根据形象符号的内在含义来理解作品，那么，他就可以按照这种特殊的表现手法去选择并表现他的主题。<br>东方文化在书法、装饰设计以及图画中所用线条的哲学含意方面，有着特别深厚的传统观念。</p>
<p>但是，一些含有诗意和宗教意义的摄影作品，往往是通过突出和强调线条的象征性而创作出来的。<br>千百年来的联想，使人们一看到建筑中的三角饰、圆形拱门、尖顶拱门以及十字形状，马上就会想到宗教。<br>如果在一个普通环境中，有无数形形色色的线条和形状分散了人们的注意力，那么，它的宗教含义也会被湮没。<br>假如把它和周围的环境分离开来，只显示它最基本的轮廓，它的宗教色彩便又变得明显了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-29/20240729124738.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="轮廓线或边线"><a href="#轮廓线或边线" class="headerlink" title="轮廓线或边线"></a>轮廓线或边线</h2><p>线条还有一种表现形式，它涉及形状或形体的有连续性的外缘，这种表现形式和前面所讨论的那些相比，不那样明显。<br>人们对形体的感觉不只通过视觉，还通过触觉。<br>往往，由于两个或两个以上的感觉结合在一起，产生了多重含义，从而大大影响了照片的表现力。<br>要解决这类问题并不容易，不少优秀的摄影人员曾为此而感到棘手。</p>
<p>譬如，看见菠萝，哪怕还没有碰到它，也会使人想起手指触及菠萝的那种感觉。<br>这不仅是由于菠萝质地多刺，而且是由于从大量菠萝所形成的知觉作用唤起的。</p>
<p>一只苹果和一只梨可能质感相同，但它们的“形体感觉”显然不同。<br>我们的目光和手指会禁不住协同一致地去探索形体的外缘，欣赏它的轮廓的走向。</p>
<p>如果照明把整个形体和其它形体或背景截然分开了，我们就会强烈地意识到沿物体边缘有着明显的分界线。<br>这连贯的、轮廓鲜明的分界线给人以一种十分确切的感觉；它的边线就摆在那里，不但看得见，甚至用手指顺着它去摸的话，也似乎能摸得着。</p>
<p>尽管也有立体感、明暗差异和阴影，但它们却无法压过这条明显的边线。<br>可是，突出边线会使整个效果趋于平板，只有不单独突出某一个线条时，整个线条结构才能显示出来。<br>边线本身往往很富美感，当然，这首先得要主体的轮廓美才行。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-30/20240730123643.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-30/20240730123658.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这一原则的逆定理有助于阐明它的含义。<br>当照明条件突出了一个物体的立体感，同时光斑和阴影又增强了它的深度感时，我们对它周围界限的感觉就削弱了；边缘的连续感觉也消失了。<br>我们所见到的边缘变得忽明忽暗，时隐时现了。<br>这与自然界中昆虫和其它动物用保护性斑纹来遮掩自身的轮廓有很相似的效果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-30/20240730123709.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>下面的投影凸起的字母很引人注目，因为它具有立体感。<br>这些看来似乎是凸起的字母中被省略去的笔划，由想象力给补齐了。<br>想象力还使我们感觉到，和每个暗边相对的那一面都是处在高光之下。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-30/20240730123719.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>把这个方法应用到摄影上，我们通过控制光线使主体和背景的影调相似，便能获得许多奇特的效果。<br>调整光线，给主体的一侧打上一道窄光，也可以获得类似的立体效果。</p>
<p>这一方法本身并不特别重要。然而，这道窄光所造成的有起伏的线条，却表现了物体的边缘和立体感。而正是这个线条的特性，使这幅照片具有艺术情趣。</p>
<p>通过控制照明，勾画出一道暗线条，效果也同样有趣。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-30/20240730123732.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 立体感</title>
    <url>/2024/08/05/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E7%AB%8B%E4%BD%93%E6%84%9F/</url>
    <content><![CDATA[<p>人们只要看看汽车展览或帆船展览，就会认识到人类对于有趣而美好的造型是多么敏感。<br>就像过去欣欣赏优秀雕塑和建筑一样，人们现在也开始欣赏比例、凹形和凸形的各种变化了。<br>这种对外形美的欣赏已经超出了对交通工具自身功能的要求，因为，交通工具的外形设计可能只是考虑到空气阻力和有效空间而已。<br>人们很容易理解，为什么纽约市一家享有盛誉的美术馆曾一度把几部精致的汽车作为现代雕塑艺术的杰出范例拿来展出。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-05/20240805122231.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>同样，对于许多实用工业产品的设计，包括电冰箱、面包烤炉、洗衣机、电视机、食物搅拌器、家具以及各种工具的设计，人们也有类似的感受。<br>人们不仅欣赏它们使用方便，也欣赏它们的造型美观。</p>
<p>这绝非新的社会现象。<br>自远古文明以来，造型优美的物体就一直受到推崇。<br>最初，好看的石头、长矛、投镖、棍棒、篮子、泥罐都成为珍藏品。<br>后来，随着文明历史的发展，雕塑、摹冢、建筑物以及家具等都加入了这个行列。<br>尽管给这些东西加上装饰品，但人们首先注意的还是那些动人的立体造型。</p>
<h2 id="空间对气氛的塑造作用"><a href="#空间对气氛的塑造作用" class="headerlink" title="空间对气氛的塑造作用"></a>空间对气氛的塑造作用</h2><p>在人类文明的早期，原始人认识到某些洞穴的空间能够使人产生某种情绪。<br>有些洞穴看起来高大庄严，造成一种神秘奥妙的气氛。<br>有些则能引起宁静、舒适的感觉，使人愿意把它变为家园。<br>还有一些酝蓄险情，诱人探索。有些空间则散发出阴郁凄凉的气氛，只适于留作坟墓。</p>
<p>空间是指一个包容物中的内容，空间里含有一定量的气体、液体或者是真空的；它们被容纳在包容物中，并和包容物的形状相一致。<br>由于它不是固体形态的，而且其线度随着包容物的线度而发生变化，所以人们很难把空间纳入立体形状的定义中去。</p>
<p>但是对于艺术家来说，空间和形状之间有着共同的内容需要考虑。<br>因此，我们确定了“立体物——立体感”这个名词，它包括了“空间”和“形状”两者的意思。</p>
<h2 id="在平面上表现立体物"><a href="#在平面上表现立体物" class="headerlink" title="在平面上表现立体物"></a>在平面上表现立体物</h2><p>在一个平面上，像在纸张、画布或灰泥墙面上，如何表现立体物，这是许多世纪以来不少伟大的思想家一直在思考的一个课题。<br>和其它手段相比，摄影术为此提供了最为满意的解决办法。<br>然而，要把立体物作为一种艺术感觉表现出来，却有很多问题有待研究。</p>
<p>优美的立体物除了给人以良好的触觉感受外，还蕴蓄着许多乐趣，最受盲人的赏识。<br>盲人通过触觉，摸索物体的形状，追寻物体的高低起伏，体会它的厚度和曲折，探索它的凹陷和孔洞，并从中得到极大的满足。<br>他们虽然看不见，却能了解空间的特点，并产生和明眼人极为相似的反应。</p>
<p>由于立体物是一种既能看到，也能摸到的东西，又具有引起情感反应的力量，所以了解立体物的本质就成为摄影构图学中必不可少的一项内容了。</p>
<h2 id="实心立体物和空心立全物"><a href="#实心立体物和空心立全物" class="headerlink" title="实心立体物和空心立全物"></a>实心立体物和空心立全物</h2><p>石头、木头和混凝土是实心的立体物，茶杯、饭碗、贝壳和房屋是空心的立体物。<br>当然，要给一个术语下严格不变的定义是不可能的，也不必力求多么精确。<br>例如，石头本身确确实实是实心的立体物，但却可以筑墙成屋，这房屋又成了空心的立体物。<br>玻璃和陶瓷花瓶显然是空心立体物，它们往往有不同形状的厚壁，这厚壁本身又属于实心立体物。</p>
<h2 id="形状和立体物"><a href="#形状和立体物" class="headerlink" title="形状和立体物"></a>形状和立体物</h2><p>人们往往错误地把立体物当作形状来看待。<br>形状是平面的，没有可见的厚度或深度。而立体物最明确的特点就是它有厚度。<br>从纸上剪下一个圆形，不管质地如何，也不论表面如何装饰，终究只是一个形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-05/20240805122401.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>一个球体的轮廓，无论从哪个角度观察都是一个圆形。<br>在一定的光线条件下，特别是使用背面光和正面光的时候，球形的特点消失，结果看起来形成了一个平面圆形，像纸做的圆形一样。</p>
<p>在另外的光线条件下，球形的特点便突出了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-05/20240805122412.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>研究一下明暗层次可以得到不少有益的启示：明暗层次能给人造成球体感而不是平面感。<br>同时还要弄清楚如何避免平面感而表现立体感。</p>
<p>请看图二三五，注意强光是如何射在每个球体左半部的边缘附近的。<br>左半球虽然都是亮调，但光的影调向各个方向逐渐暗淡下去，直到边缘；<br>在右半球上，影调继续变暗，到右侧底部变得最暗。<br>这是暗部的最低端，它集中在右侧附近。<br>周围物体上的反射光射到阴暗区域，又照亮了右侧边缘。</p>
<p>我们研究立方体或矩形棱柱体之后，也可得出类似结果。<br>尽管对棱柱体的线性分析表明，这里可以看出通常透视现象所体现出来的深度和体积，但在一定的光线条件下，特别是在直接的正面光或背面光的照射下，棱柱体给人印象只是一个平面的形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-05/20240805122423.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果通过照明区分影调，清楚地展现出三个方向的阴暗面，就能清楚地看出这是一个立体物了。<br>影子有助于明确显示一个物体是实在的和丰满的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-05/20240805122432.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>球体的层次是连续性的，而立方体或棱柱体的层次则是非连续性的。<br>不连贯的层次变化能显现出平面的各个边缘。</p>
<p>圆柱体是一种立体物，它既有连续性的特点，也有非连续的特点。<br>它那椭圆的轮廓部分就象立方体的透视线条一样，很难完全隐藏它那三线度的性质。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-05/20240805122448.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>然而，这些图形显现出相对的平面感，使它们更接近于平面形状，而不大像立体物。</p>
<p>当加以照明而显示其立体特点时，我们能看到它曲面外表的影调层次是连贯的，而底部表面层次则是不连贯的。<br>还要注意：强光部分是在亮面的边缘附近。<br>但最暗的部位并不是正在右面边缘上，而是在边缘附近。<br>边缘是被周围物体向暗处反射的光照亮的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-05/20240805122459.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>当看到具有不同影调层次的球体、立方体和圆柱体照片时，我们的眼睛会向脑子传送一种形体的感觉，就种感觉和我们触摸这些实物时的感觉是相似的。<br>对于我们就些生活在二十世纪并习惯于在平面上表现立体形状的人来说，除了会产生这种明显的感觉之外，不会有什么特殊的反应了。<br>而一百五十年以前，这种立体的感觉会被认为是不可思议的，就象在立体镜中第一次看到物体的深度一样地不可思议。</p>
<h2 id="意义不明确的轮廓"><a href="#意义不明确的轮廓" class="headerlink" title="意义不明确的轮廓"></a>意义不明确的轮廓</h2><p>当我们认识到从很多不同的形体可以得出一个同样的轮廓图形时，便会明白两线度形状的表现力是不充分的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-05/20240805122524.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>但对于一个摄影家来说，这并不一定就是个缺陷，摄影家倒可以因此获得更灵活的表现手法和更丰富的表现机会。<br>把外形类似的形状和实际的立体物并放在一起，加以照明。<br>所得结果将是很有趣的。</p>
<p>重视技术的摄影家对于立体物的平面化颇有感受，这种效果在使用远摄镜头拍摄时尤为明显。<br>用长焦距镜头拍摄的照片，其深度感显著减少，以至于立体物看起来接近平面形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-05/20240805122537.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>相反，短焦距镜头增加了景深，有时会增加到线性失真的程度。</p>
<h2 id="立体性质的表现"><a href="#立体性质的表现" class="headerlink" title="立体性质的表现"></a>立体性质的表现</h2><p>为了加强对立体感的理解和鉴赏能力，不妨在你的附近选出各样的物体并努力表现它们丰满的立体感。<br>花瓶、盒子、灯座、装饰品、瓶子、罐子、废纸篓、小收音机、玩具、儿童积木等等都是很好的观察对象。<br>尽量寻找不同轮廓和不同形体的物体以便于研究。</p>
<p>开始时，只研究单个物体，看看以什么视角进行观察才能最好地表现它的立体感。<br>如果它的造型是不规则的，则可加以转动，找出一个你自己认为最满意的角度，以便充分表现它的总体。<br>然后加以照明。但照明不是为了突出边缘的轮廓，而是要突出形体。<br>光线要集中在边缘之间的隆起和凹陷处。<br>一般说来，全部设备只用一个光源加上一个白纸反光板就足够了。</p>
<p>待布光满意之后，通过相机的毛玻璃或取景器仔细研究照明对象，作一些调整，以便增强立体感。<br>凡能使你受到感动的研究结果总是值得拍成照片的。<br>这不一定是为了展出，而是为了验证你对立体物的感受，并确定一套记录这种感受的拍摄方法。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122557.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>直到不久前，雕塑的实践还是按照绘画的传统方式，只限于表现人物、动物和物体。<br>对雕塑特点的欣赏主要根据其逼真程度，体态的动感以及感情的形象表现。</p>
<p>但是，很多观赏者都不会情不自禁地注意他们认为不属于雕塑的那些特点。<br>他们不仅忍不住想触摸一下材料的质地，并且还想用手到外抚摸，去感受那有趣的外形，体会一下它的起伏、凹陷、弯曲、薄厚变化、并探索它的孔眼。<br>很多人从石头、木头、陶瓷或金属的材料特性中，从它们上面显而易见的颜色、纹理和质地中，不仅发现有视觉上的美感，而且还体会到触觉上的美感。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122613.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现代抽象派雕塑能够满足这些感官上的要求，而又故意不去理会过去关于逼真的要求。图二四七是布良朗卡􀂷斯特恩的石雕。<br>从这个作品中我们能感觉到这位艺术家是如何吸引我们的眼晴和手去探索那不断变化的曲曲弯弯的表面的。<br>这是一种探索性的尝试，滑进不规则的洼处，然后突然上升到一个波峰似的隆起处，随后又穿过孔道。<br>随着我们的手指在物体表面徐徐前进，不断地由于新的诱惑和内心的冲动而变换方向时，我们会体会到整个物体的轮廓是变化莫测的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122634.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>摄影家要想去表现一个优美的立体物固有的视觉美感，就必须首先会欣赏它，如果可能的话，首先通过触摸，然后再通过视觉观察。<br>尽管现代抽象雕塑品是很好的启蒙手段，但它们毕竟是难以得到的；<br>要是参观者在美术馆里擅自触摸陈列的雕塑品，服务人员会立即制止的。</p>
<p>卵石和小石子的形状变化无穷，利用它们培养敏感性会使你流连忘返。<br>物色一些带有孔眼的从不同角度观察时具有不同外形的卵石。<br>有些石头上有深深的锯齿和耐人寻味的隆起、凹陷、蜂窝或小丘，有些则是带圆形的平扁石。<br>我们会情不自禁地转移兴趣，而去欣赏它们的色调，质地和反光特性，所以要克制自己的闲情逸致而集中研究它们的外形。</p>
<p>在对它们的外形有了一定的感受之后，选出一块拳头大小的石头，通过触摸和视觉观察再研究它的形体。<br>这样做会培养出你对石头的感觉，并在头脑中确定你喜欢拍摄的那些特定形状。<br>现在，把石头放在一个简单的背景上，加以照明，作进一步研究。<br>不断地变换背景的色调，使之满意：既不要反差太强以致夸张了石头的轮廓，也不要反差过分相近，以致石头和背景难以区分。</p>
<p>先用一个光源，用反光板来调节影子。<br>以后，如果必要，就再加上一个光源，目的是用明、暗手法来表现你感觉中的形体。<br>一旦找到了满意的布光，足以表现出你的触觉感受时，便可通过你的相机取景器仔细地加以验证。<br>等你完全满意时，就拍成照片。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122650.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在转动石头和试验布光的过程中，你可能会发现，有些新的外形十分动人，可以和你最初欣赏的外形媲美，甚至更胜一筹。<br>这时，一定要进一步研究你的新发现。这才是创作的实质。<br>从确定课题，到培养敏感性和对普通的物体有深刻的认识，需要花费一定的时间。<br>但是一旦闯过了这一关，你会得出不只一种，而是多种有价值的构图方案——你并没有虚度时光。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122705.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在可以到野外或公园里，在树干、树技和裸露的树根中去探寻有趣的立体感。<br>你凑近树木，就会发现那些远看像圆筒似的树干却原来千姿百态，形状各异。<br>有些形态是因为枝杈和树干自身的盘根错节而形成的。<br>另一些形态之间的差异则更为明显，是天气、昆虫、兽类以及病虫留下的创伤。</p>
<p>在现代雕雕塑中，你会发现一些具有强烈的视觉效果的造型、凹陷和切痕。<br>同样，在摄影方面仅仅强调物体形态及其质地变化的照片也可以成为优秀作品。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122724.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>遗憾的是，许多摄影家的习惯是只注意拍摄题材，而忽略了在挖掘题材和表现手法这两方面，视觉感受才是最本质的东西。<br>他们把自己对树木的观察局限在一般特点的识别上，通过树干、枝杈和树叶的特点，看它们是哪一种树种：<br>是柳树、橡树、榆树、苹果树、松树还是枫树，很多人对于每棵树本身的特色无动于衷。</p>
<p>这个道理不仅仅适用于一棵树木。<br>几乎任何一个自然物体或人造物体都具有许多可以发掘的特质，可用以拍成优秀的摄影作品。<br>在这里，你能赋予拍摄主题的东西要比这个主题展现给你的东西重要得多。<br>你对于形状、线条、立体感和质感的感受越是敏锐，你就越加不必去专门搜寻有趣的拍摄题材，因为有趣的题材在你的周围比比皆是。</p>
<h2 id="用轮廓表现立体感"><a href="#用轮廓表现立体感" class="headerlink" title="用轮廓表现立体感"></a>用轮廓表现立体感</h2><p>表现立体形态的一个方法是造成阴和影。<br>如果是不规则的形状，像大块成层岩那样断断续续的，则可以在表面上勾画轮廓线，这是表现立体形态的又一种方法。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122740.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>像图二五一中的成层岩，由于线条明显，轮廓线的前、后运动表现了凸凹变化。<br>有时把轮廓线以及阴和影结合运用，比各自单独使用时，能表现出更强烈的立体感。</p>
<p>被水冲到岸边的木头是研究立体感的又一种好材料。<br>水流的冲蚀使它更为复杂，凹陷、裂纹和孔洞也更加突出和显著。往往，由于水流冲掉了无关紧要的小枝杈后，会给木头留下一些奇特的轮廓；<br>而这些轮廓又给复杂的立体形态增添了奇妙的线条形式。</p>
<p>我们说这种立体的形态带有复杂性，是因为这些形态必须通过明暗处理和利用木头的轮廓线这两主面才能表现出来。<br>这些线条是在长期浸泡后又经干缩的过程中形成的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122800.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="立体物的相互关系"><a href="#立体物的相互关系" class="headerlink" title="立体物的相互关系"></a>立体物的相互关系</h2><p>研究单个物体的立体感会体验到它内在的魅力。<br>当我们开始探索立体物之间的关系时，就更入迷了。</p>
<p>收集七、八只盒子，它们的大小、比例和几何图形应该各不相同。<br>为了避免因色调和质地不同而给研究工作造成麻烦，可用同样的或相似的纸张把盒子包起来。<br>甚至可以自己动手用卡片纸板做一些盒子。<br>这些盒子在各种摄影实验中都会用得到。<br>把木块用纸包起来同样可以做成盒子形状。</p>
<p>现在把这些盒子好好布置一下，主要目的是要获得满意的立体物的相互关系。<br>先用两三只盒子布置，必要时增加或更换一些盒子。<br>让大的盒子衬小的，高的衬托矮的，横的衬托竖的，长方形的衬托圆筒形的。<br>注意观察使用几只同样大小的盒子会产生什么样的效果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122812.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>把两个盒子摞起来，使其轴线方向各不相同。<br>有些盒子可以斜放，从而进一步造成方向的变化和空间的伸展。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122823.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>要把盒子组合得很巧妙，使观众总想围绕着它的四周去观看，而不要只拿正面来吸引人。<br>但无论如何不要弄得太复杂。</p>
<p>这种娱乐方式可增强摄影者的感受能力、创造发明能力和探索精神。<br>有些最动人的照片往往正是得自这种简单的方法和试验活动。</p>
<p>当你对自己的布置感到满意时，便可开始布光，以便表现纵深。<br>试着把一个物体的影子投到另一个物体上去。<br>看看长方形的影子落在圆形纸盒上时，是如何加强了筒状物的圆形感的。<br>每当你组成一个特别动人的画面结构时，就要通过取影器研究其组合情况，再加以调整并拍摄下来。</p>
<p>再找一些具有几何图形的物体，如水皮球、漏斗、角锥体和碗一类东西，把它们和前边使用的物体组合起来。<br>突出各立体物之间的相互区别。<br>在照明下，把一个立体物的影子投向另一个不同形状的立体物，继续试验投影的效果，看看影子的形状是如可影响形状的表现力的。<br>然后，变换大小、位置和方向，使构图，特别在立体物的相互关系上，达到满意为止。</p>
<p>曝光、洗印，并研究洗印后的结果。<br>从这些试验中你很可能会学到很多东西，并愿意继续试验。<br>如果是这样的话，请你务必继续下去。</p>
<p>下一步，可以把一些静物，如装饰用盒子、花瓶、花盆、水果、蛋类、壶和平底锅之类组进构图中。<br>土豆、黄瓜、西葫芦、葫芦、南瓜、鲜胡椒和甜瓜都是研究立体感的好材料。<br>只要你的目标是集中研究这些物体之间立体感的相互作用，而不是从室内装饰或烹饪的角度来布置它们，那么你对这些物体的布置和拍出的照片就会有更大的兴趣。<br>把上述的实用物品变换一下，着手拍摄一般的题材，像食品、乐谱、艺术品、文具、时装、书籍或金属器械。<br>根据主题的需要把有关用具布置在一起，可以创作各种构图来。</p>
<h2 id="户外题材的立体感"><a href="#户外题材的立体感" class="headerlink" title="户外题材的立体感"></a>户外题材的立体感</h2><p>现在，只要迈出一小步，便可以从研究静物构图发展到研究人造物的组合了。<br>我们对周围环境中的人造物是如此的熟悉，以至很少去注意它们。<br>首先，物色一些几何形状的物体。<br>在城市里能找到这种材料的理想处所是房顶上面。<br>那里，有和通道、排烟、储水、空调等有关的各种几何结构。<br>楼群、建筑物的某一部分、胸墙、阳台和塔楼都可作为这些形状的背景。</p>
<p>工厂和工业建筑群常常由稀奇古怪的几何形状的结构组成；<br>煤气储存厂、充气圆屋顶、农场建筑（特别是有锥形顶棚的圆柱形地窖）、铁路设施和建筑以及各种塔台都是研究立体构图的极好题材。<br>水滨的商业区和游乐区也是很好的研究对象。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122840.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122852.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在你通过照明试验立体物的构图时，可能已经注意到，要表现立体感，最有效的照明是有一定角度的光源。<br>这个道理也可以应用于户外的构图研究中。<br>如果你的目的是专门为了表现立体感，那么，你的拍摄时机就要选在上午或下午较为适中的一段时间里。<br>这时阳光是斜射的。</p>
<p>我们所见到的或接触到的一切物体都是立体的。<br>最细的金属丝，最薄的纸张都有可感的厚度和体积。<br>可供研究立体感的物体是无究无尽的，无法一一列举。</p>
<h2 id="自然界的立体感"><a href="#自然界的立体感" class="headerlink" title="自然界的立体感"></a>自然界的立体感</h2><p>摄影家对云彩有特殊的兴趣，因为它们的形状千变万化，并能激发人们的情感。<br>云彩有时象各种线条，有时呈色调均匀的大团。<br>有时变成明暗不同、质感各异的细缕，有时又是大片的平面形状。<br>积云和积雨云则形同怒涛。<br>云彩时聚时散，变化无穷，为摄影家提供了取之不尽的创作源泉。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122906.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>地貌也可以被看作是各种形状、线条、色调、质感和立体感的组合。<br>在圆石、砂丘、风化岩石、溪谷、山峡和冰蚀山谷这些静物之中也可以找到动人的立体感。<br>除了供科学研究用的一般地文学照片以外，人们能够从地貎中发现独特的立体组合而创作出杰出的摄影作品。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122916.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在斜射光线的作用下，乔木和灌木都可以呈现出立体的形态。<br>对立体感有深刻认识的艺术家知道怎样把它们用于摄影构图。</p>
<h2 id="深度空间和浅度空间"><a href="#深度空间和浅度空间" class="headerlink" title="深度空间和浅度空间"></a>深度空间和浅度空间</h2><p>讨论空间象讨论立体物一样，绝不能忽略深度空间的问题。<br>这个问题有时称作线性透视和空气透视。</p>
<p>线性透视感最明显的是平行线的会聚，象公路和铁路伸向远方那样。<br>它还表现在视觉对物体逐渐变小，即越远越小的感觉上。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122931.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>空气透视是指远处物体细节模糊不清的一种现象。<br>观察者和物体之间的距离越大，该物体的光线需要穿透的空气层就越厚。<br>远处的物体看来好象是沉浸在一片濛濛雾气之中。</p>
<p>摄影家有机会创作出使远近立体物有戏剧对比的照片。<br>可惜这个拍摄方法用得太多而流于公式。<br>结果，很多追求较为流行风格的摄影家，常常对这种表现空间的方法避而不用。<br>然而，这种题材并没有失去效用。<br>任何一个独树一帜的人，只要他的见解能够概括地体现近处立体物和深度空间的相互作用，他就会取得出色的成就。</p>
<p>在现代艺术中，摄影和绘画，雕塑和印刷艺术相互渗透，十分倾向于表现浅度空间。</p>
<h2 id="含蓄的立体感"><a href="#含蓄的立体感" class="headerlink" title="含蓄的立体感"></a>含蓄的立体感</h2><p>以上，我们研究的立体物都是有形的。<br>现在不妨考虑一下螺旋浆或风扇叶子的运动。<br>在静止时，可以清晰地看出，它们是由两个或多个叶片构成的。<br>而运动中，叶片的结构看不见了，我们看到的只是一个模糊的圆筒，圆的深度等于叶片的螺距。<br>旋转门或旋转木马也有类似的效果。</p>
<p>尽管这种立体感是蕴藏在运动状态之中的，而不是体现在固体形状或包容空间中，但它确实是可以用摄影方法记录下来的立体物。<br>它的实际存在和一显即逝的特点，可以用来构成一幅非同寻常的画面。</p>
<p>拿一个金属丝制成的挂衣桇，不均匀地拧它几下，然后把它吊在一根绳子上。<br>现在，把绳子捻上很多转，当捻紧的绳子被松开往回转的时候，拧过去的挂衣架就会随之旋转起来。<br>这时用低速快门把旋转着的衣架拍下来。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807122951.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>然后，在绳子往回转时，轻轻地推它一下，使它在旋转的同时来回摆动，所用速度应保证能摄入摆动的全部扫描轮廓。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807123009.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>最后，换一根橡皮绳子，把跳动、旋转和摆动三种运动的扫描轮廓都结合在一起，拍成照片。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807123019.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>做了这些初步的试验之后，你会了解某些金属丝的结构，特别会了解它们的旋转运动(自转式的)和绕转运动（公转式的）以及其它一些协同运动。<br>如果增加不同粗细的金属丝，变换悬挂物体和悬挂形状，以及增加玻璃垂饰这样的反光材料，则可获得千变万化的效果。<br>如果再加上不太平衡的活动方式，还可以产生出一些摇摆和绕转的变化。</p>
<p>安排一个时间去游乐场转一下，在那里，使用中的各种骑乘玩具能产生含蓄的立体感。<br>当夜幕降临，各种结构上灯火通明时，你还能发现种种奇异的构图。<br>如果把几种含蓄的立体物结合在一起，或者把含蓄的立体物衬在有形的立体物上，更可以创作出风格独特的作品。</p>
<h2 id="肖像和人体摄影的立体感"><a href="#肖像和人体摄影的立体感" class="headerlink" title="肖像和人体摄影的立体感"></a>肖像和人体摄影的立体感</h2><p>人类的形象，包括肖像和人体摄影，在摄影中，如同在任何其它视觉艺术中一样，仍然是最有趣的主题。这决非偶然。<br>从穴居时代开始，观赏那些表现熟悉的和陌生的人们的作品，就给人带来了很大的愉快和乐趣。人体的差异，以及外表和表情的不同，几乎是无穷无尽的。</p>
<p>我们大家在很多方面是如此地相象，同时又是如此地不同。</p>
<p>我们每个人各自的外表和比例、凸度和凹度、皮肤质地和皮肤色调不仅是各有特点，而且它们也随着我们的每个动作，以及我们内心的每个想法、情绪和感情的不同而发生变化。</p>
<p>本章前述的经验也有助于我们表现肖像的立体感。</p>
<p>我们不去美化人物，不想表现他的个性，也不求惟妙惟肖，甚至不管他的感情表现或皮肤纹理——我们只是研究纯粹的人体结构的外形。<br>我们首先观察一个面孔瘦削，面部轮廓清晰的中年模特儿。<br>观察他面孔的细节：<br>前额和鬓角交接处的角度清晰明显，突出的眉骨，深陷的眼窝里一对清澈的眼晴，突出的鼻子，端正的鼻梁和惹人注目的鼻翼，两颊的颧骨适当突起，下颏轮廓鲜明。<br>这个要求也许偏高，但找到这样的模特儿实际上是并不困难的。</p>
<p>你他细研究这个头形，确定一个合适的观察点，以便最有效地突出这个模特儿的面容特征。<br>仔细布光，以便能强调出各部分的立体感，使整个头和脸尽可能地成几何图形。<br>你很可能会发现，为刻划这个外貌，只用一个调焦聚光灯或者一个摄影聚光灯就足够了。<br>但如果你想刻划那更细微的特点，可能需要其他类型的反光器或辅助光。<br>这里无法规定任何照明计划，因为每个人的体形都不相同，因而照明方法也不能千篇一律。<br>只要你决心去生动地表现立体感，经过一些尝试和失败，你总会找到适当的途径的。</p>
<p>曝光，并冲出胶卷。<br>在洗印过程中你需要牢记你的主要目的是什么，并通过洗印的控制来达到那个目的。<br>研究一下你的洗印结果。<br>看一看你拍成的照片多么富有新鲜感！<br>你选择模特儿的指导思想，摆出的姿势和用光都会在照片中体现得清清楚楚。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-07/20240807123030.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>把你的照片顛倒过来，使底部朝上，检查每个部位的形状。<br>鼻子是不是象一块突出的岩石，几乎要从照片上伸出来，眼睛是不是好像装在一个球形的曲面上？<br>嘴唇之间牙齿周围是不是给人给人以筒状感觉？<br>下颏是否明显地突出于脖子上？<br>你是否仍然能够明确辨别出前额和鬓角的连接处？<br>能否明显地感觉到颧骨从眼睛的外侧延伸到耳朵，形成了面颊和颜面前部的交界点呢？</p>
<p>以此为例，你可以选择任何一个模特儿并按同一办法去做。</p>
<p>重要的是你要把构成模特儿头型各部分外形的特点认识清楚，并通过照明设法加以突出。</p>
<p>要记住，这只是肖像摄影的多种方法之一。<br>根据不同的拍摄目的，选用不同的方法能取得不同的结果。<br>究竟采用哪种方法取决于预期结果和指导思想。</p>
<p>穿衣服和裸体的人体都是表现立体感的良好题材。<br>躯干和四肢的每一部分都可以和一个近似的几何图形联系起来。</p>
<p>为了获得更强烈的立体效果，可以把人体布置成扭转的姿势，使头、肩和臀每个部分的方向稍有不同，这时，观察者的兴趣便从正面开始，绕过侧面，然后转向背面。<br>于是又形成了另一种含蓄的立体感。</p>
<p>当人体的一个突出的立体部位衬托在一个凹陷的背景空档上的时候，能产生效果极好的照片。<br>这也是利用背景进行对比，造成动感，表现立体感的一个手法。</p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 明暗</title>
    <url>/2024/07/31/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E6%98%8E%E6%9A%97/</url>
    <content><![CDATA[<p>在构成视觉艺术的各种要素中，明和暗对摄影具有特殊的重要性。<br>因为有了明和暗，照片中各种物体才成为可以看得见的影像；<br>所有其它要素，包括形状、线条、质感和立体感等，实际上都是明和暗的不同表现形式而已。<br>时至今日，事实已经证明，摄影的实质就是在于依靠光线发生作用，也就是依靠光线通过镜头对感光材材料发生作用。</p>
<p>摄影家从快门打开的一瞬间到照片离开显影盆的整个过程中，也就是明和暗这个范围之内，发挥他的影响和控制作用的。</p>
<p>摄影过程的每一个细小的环节，包括胶片选择、滤镜使用、底片曝光、药液特性、显影时间等，都对明暗的再现有着相当大的影响，从而也相当大地影响着作品的表现力。</p>
<p>在放大照片时，有遮挡经验的人都知道，对照片的局部遮光和加光会给作品的清晰度和立体感带来多么大的影响！<br>如果再把相纸的反差和显影剂的强弱考虑在内，可以说控制明暗的机会是相当多的。</p>
<p>从根本上说，明暗只是色的三大特征之一，其它两个是色别和色艳度。因为本书只论黑白摄影构图，所以明暗是当作独立的构图讨论的。</p>
<h2 id="照片的质量"><a href="#照片的质量" class="headerlink" title="照片的质量"></a>照片的质量</h2><p>从早期的摄影教育开始，人们就教导摄影者说，照片必须表现从明到暗（包括少量纯白纯黑在内）的整套灰色层次。<br>每本摄影手册也都告诉读者，一定要把明暗两个部分的影调等级和层次充分细致地表现出来。<br>毫无疑问，这正是摄影比其它视觉艺术独到的地方。这也是照片质量问题的核心所在。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-31/20240731123352.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="明和暗的造型作用"><a href="#明和暗的造型作用" class="headerlink" title="明和暗的造型作用"></a>明和暗的造型作用</h2><p>没有哪一种造型手段能像摄影那样，用从纯白到纯黑的无数个灰色层次的变化，把物体的立体感那样生动地表现出来。<br>没有哪一种造型手段能像摄影那样，在一个平面上向人们提供凸起和凹下的幻觉，从而构成一个逼真的立体形状。</p>
<p>下面的人像是故意颠倒过来的，为的是分析它的形状而不是去注意人物的特征。<br>请注意眉毛下面的凹处和眼睑下面的圆形眼球。<br>鼻子是渐渐隆起的，鼻尖达到最高点，耸立于周围的颧骨之上，然后突然下降到上嘴唇的平面上。<br>嘴的形状紧随着下面牙齿的圆筒状。<br>两片嘴唇形成了隆起的弧线，由中间的分界线上下分开。<br>下巴从嘴唇下面的凹处突起，形成一个高丘，然后下降，先缓后急，直抵下颌。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-31/20240731123430.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>没有其它造型手段能够记录象下图这样微妙的明暗变化；<br>正是这种明暗变化表现了光线和空气构成的神秘的环境气氛，给人一种树木似乎沐浴在气流之中的感觉。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-31/20240731123451.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在记录物体的透明度、半透明度的反光特性的能力方面，任何其它造型手段都无法与摄影相媲美。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-31/20240731123516.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="灰色级谱"><a href="#灰色级谱" class="headerlink" title="灰色级谱"></a>灰色级谱</h2><p>能觉察到的灰色色调是无限多的。用摄影方法能记录下来的色调也是难以计数的。<br>为了对色调进行大致分类，人们设计了这个图谱，并用它作为识别和记录色调的依据。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801122859.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>像实际生活中其它方面一样，艺术需要多样化，就是公认的事实。<br>艺术风格需要不断变化的最主要的理由也许是：任何一种特定式样要是用得过久，就会引起厌烦。<br>不断观赏一个形象会使人的精神疲倦，这时候会要求调换不同的形式来进行调剂。</p>
<p>在使用色调方面也需要多样化。<br>当许多照片在一个展览会上展出或一种出版物中出现的时候，色调的多样化特别重要。</p>
<p>如果大部分照片是以灰色级谱上的中间色调为主，很少有极浅灰、白、深暗灰和黑，这种色调的雷同将会使人觉得沉闷乏味。</p>
<p>在一张照片或一组照片里，怎样运用级谱里的数值，是影响作品气氛的因素之一。<br>在艺术中和在生活中一样，气氛的改变不仅是可能的，而且是竭力追求的。</p>
<h2 id="高调和低调"><a href="#高调和低调" class="headerlink" title="高调和低调"></a>高调和低调</h2><p>一张照片，如果它主要包括了灰色级谱的上半部分（白、极浅灰、浅灰、深浅灰和中灰），一般说它表现的是轻松愉快的气氛，这样的照片被称为高调照片。<br>但要注意这样一种危险：没有包括灰色级谱上所有等级(那怕是一点痕迹)的高调照片，看起来会像曝光不足或显影不足一样。</p>
<p>当然，如果从纯白到中灰的所有等级都能充分表现出来的话，暗调部分可以省掉。<br>也就是说，如果从极浅灰到中灰之间最少能分辨出十个灰色等级时，这样的高调照片从色调上说是可以接受的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801122912.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801122926.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>同样，一张照片如果主要包括灰色级谱的下半部分（中灰、浅暗灰、暗灰、深暗灰、和黑色），<br>它表现的是阴沉忧郁的氛，这样的照片被称为低调照片，也常常要有一些较亮色调，<br>以便使人相信就张照片是有意这样处理的而不是失手弄黑的，<br>假如包含较亮色调后对所要表现的气氛所有干扰的话，也可不要较亮色调，但必须具有极丰富而明显的暗调层次。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801122941.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="对自然界明暗的联想作用"><a href="#对自然界明暗的联想作用" class="headerlink" title="对自然界明暗的联想作用"></a>对自然界明暗的联想作用</h2><p>我们总是不可避免地要把照片上的色调和实物、经验以及情绪联系起来。<br>砖墙或是混凝土墙的颜色会唤起人们内心已有的那种明暗概念。<br>人们会自动地把特定的颜色和固定的色调联系在一起，所以我们可以料想一只桔子拍成照片以后表现的色调比一只柠檬要深些，一只苹果则比一只桔子更深，而茄子是它们当中最深的。</p>
<p>我们说到雪、牛奶、亚麻布床单会联想到白色，说到岩石会联想到灰色，说到夜晚、寂静、空间、煤炭会联想到黑色。<br>愉快的情绪是和明亮的调子相联系的。<br>压抑忧郁的情绪是和接近黑色的调子相联系的。荒凉是和灰色相联系的。</p>
<p>虽然这种联想在大多数情况下是正确的，但不是在所有情况下都是适用的。<br>有时候会出现这样的情况：一个物体经过影调处理后才能符合常规的联想。<br>这时候摄影家就得控制光线、加用滤镜、调整曝光或通过印放处理来达到自己的目的。</p>
<p>在另外一些情况下，为了构图或表现上的需要，牺牲或打破这种常规的联想关系更为有利；<br>浅色的物体可以处理成暗调的，深色的物可以处理成浅调的。</p>
<p>这种联想关系还被扩大到伦理道德范畴中去。<br>明与暗经常被用来和正面事物与反面事物、善与恶相联系。<br>在人类历史的早期，上帝被认为就是光明。<br>因而，亮调就代表无形之物、非物质精灵，经常用大片空间和天空来表示。</p>
<p>相反，黑暗只和忧伤的情绪相联系，用来表示抑郁和悲伤。</p>
<p>如果我们认真考虑一下这种联想作用，我们会发现，它既不是一成不变的，甚至也是没有道理可讲的。<br>难道黑暗不是冒险精神、宗教迷信和神秘主义的环境气氛吗？不是也有很多诗情画意的作品是用暗调来表现的吗？<br>甚至爱情和沉思这些带神秘感的生活片断，也是和黑暗或近乎黑暗的环境相联系，而不是用中午的耀眼阳光来衬托的。<br>强烈的阳光使一切暴露无遗，没有一点含蓄回味的余地。<br>阴暗的教堂比起明亮的教堂来，是宗教忏悔的更合适的环境。</p>
<p>黎明和黄昏的朦胧光线似乎适宜于渲染宗教精神，而光天化日却能使人们摆脱神秘和离奇的想象。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801122955.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>艺术家在表现他的主题的时候，必须能够不受约束地选择它的调子。<br>艺术上的墨守成规是创造力的障碍。<br>拘泥于简单地反映，屈从于公众的低级趣味，只能产生乏味的，没有特色的作品。夸张是艺术的有机组成部分。<br>在摄影艺术中，夸张的机会主要存在于明暗控制之中。<br>如果把晴天雪地上黑色影子强调出来会有利于你的美学设想，那就让它变黑，必要的话还可以在放大时加光。<br>如果在表现采矿的照片上，煤的颜色干扰了你想要强调的东西，你设法让它亮一些是合理的。</p>
<p>几乎可以说，不加夸张地处理色调只能落入俗套，而打破常规的处理却会因为它的新颖大胆而博得赞赏。</p>
<p>艺术家应该具有独特的观察力，能够越过常规和成见去观察事物，创造出扣人心弦的作品来。</p>
<h2 id="明和暗在美学上的运用——气氛"><a href="#明和暗在美学上的运用——气氛" class="headerlink" title="明和暗在美学上的运用——气氛"></a>明和暗在美学上的运用——气氛</h2><p>在明暗的运用方面，摄影家的眼界必须更加开阔；<br>不要认为它只是清晰地记录影象的一种手段。<br>除了构成画面和产生立体效果之外，明和暗还有很强大的艺术表现力。<br>它是一个有效而独立的构图要素，是表现和烘托气氛的最有力手段。</p>
<p>为了造成特定主体的适当气氛，并像你所希望的那样表达感情，往往不必拘泥于实际情况，而把明和暗看成独立的实体。<br>我们不可能也不愿意制订出一个一览表列出通过明暗配置造成的气氛的方法。<br>处理方法是多种多样的，这要根据每个人的经历、经验、风格和判断能力来决定。</p>
<p>虽然亮调能够表现温暧，但也能表现寒气、遥远、空虚、清晰明快和暴露无遗。<br>暗调可以表现宁静，也可以表现寂寞；可以表现停滞，也可以表现危险。</p>
<p>从许多方面来看，光线和音乐有相似之处。<br>它能够变换轻重和强弱。自然光有着很大的调节可能和适应性。<br>人工光能产生极为丰富的层次变化，效果如何，取决于灯具和应用方式。</p>
<p>当一个物体被充分照明，它的每个部分由于明暗分明而能清楚地辨别出来时，这时所强调的是被摄体而不是整个画面。<br>我们不禁会注意到它的突出轮廓。<br>它是那样地明显，以至于我们不去留心照片的整个构图。<br>这种情况，在完全正面照明时，或者当一个明亮的图形衬着暗调背景时，是经常遇到的。<br>逆光照明下，黑色剪影衬在明亮的背景上也是如此。<br>突出轮廓，能给人以明晰精确的印象。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123009.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123023.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>相反地，如果光与影的配置没有把每个具体形状分别强调出来，这时整个画面的整体感就加强了。<br>光线是使物体能被看见的力量，也具有湮没物体的能力。<br>边界能被隐藏，轮廓会变模糊。</p>
<p>在一个统一的画面中，一个形状的光与影和另外一个形状的光与影混淆了起来。<br>用亮调的、中间调子的和暗调的色块组成画面，并不要求每个形状的界限分明，这时线条和立体感的作用就会减弱，整个画面显得模糊不清。但整体感加强了。<br>观众不再注意每个局部，而是把照片当作一个整体来看了。<br>每个被摄体的形状和由明暗色块组成的整个照片不大区分得开了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123032.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123045.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="明暗配置"><a href="#明暗配置" class="headerlink" title="明暗配置"></a>明暗配置</h2><p>把亮调的、暗调的中间调子的色块集中在一个不规则的画面上，排除形状和线条的作用，那么构图美学的另外一个重方面，即整个画面的明暗就显得突出了。</p>
<p>如果我们把下面一组照片顛倒过来加以研究，就能比较清楚地理解这个问题。<br>这些照片是在一天之内不同时间，从同一位置<br>拍摄的同一景物。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123058.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>像图一六五那幅肖像一样，颠倒过来观察，你就不会把它当作实物看待，过多地注意它的结构了。<br>一幅作品的构图好坏，往往当你不去注意主体为何物时才能看得更清楚此。<br>当然这并不意味着主体与构图不需要紧密配合。<br>而是说把照片倒过来，你便能够集中注意它的明暗配置，看出它对整个画面的影响。</p>
<p>每幅成功的作品必须具备几个条件：</p>
<blockquote>
<p>一个是主题的表达和包含的内容，一个是构图，还有一个是印放质量。当然还有其它许多方面。</p>
</blockquote>
<p>伟大的作品，是那些把画面中每件事物以及它们相互的关系结合得极为高明的那些作品。</p>
<p>从前面一系列照片中，我们学到的最重要的一条经验是：</p>
<blockquote>
<p>必须认识到，明和暗的意义远远不止是使被摄物具有立全感或者美化被摄物。明暗配置对整个照片的结构有着巨大的影响。</p>
</blockquote>
<p>一般说来，对被摄体的处理越发细致具体，例如清晰地照明和逼真地反映，作品的艺术效果就可能越发浅薄单调。</p>
<p>有时候美化被摄体是摄影的重要作用。正因为摄影在这方面的作用要比其它造型手段有效得多，所以它才受到重视。</p>
<p>作品的艺术性关系到整个画面空间，绝不是主要物体得到满意的表现就算了事。<br>正像画面中多余的物体能降低主体的感染力一样，明暗配置不当也能削弱构图效果。<br>因此、摄影家不能只限于判断画面上主要部分的明暗，他必须对照片每个部分的明和暗给以同等重视，才能判断哪些有利于整体效果，哪些不利于整体效果。</p>
<p>因为构图要素和构图原理都是抽象的概念，所以需要从完全抽象的角度去考察它的性质和作用。<br>如果把具体可辨的物体从画面上排除掉的话，这种概念才能表现得更清楚，理解得更明确。<br>因为这样做的结果使我们有可能以更大的注意力去研究某一个别的构图原理。</p>
<p>在下列各图中，线条结构是相同的。它们之间最大的区别是明暗配置不同。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123127.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>第一种明暗配置是把中间那块大图形涂得比周围色调更加以突出。大图形边界之内的色调变了。<br>虽然画面的一角也有块相同的色调，但它并未接触大图形的边缘。<br>把深色调集中在一个大范围之内，就能把观众的视线紧紧抓住，因为比起其它部分来，它有更大的吸引力。<br>注意力被集中在深色图案部分，它压倒了周围的浅调区域。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123140.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>对同一图形，也可用颠倒黑白的办法，就是让中间图形亮，周围环境暗的办法，使它仍然占据优势。</p>
<p>用这种加强对比的手法，我们能把观众注意力引向画面的任何一部分。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123155.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123218.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>明暗配置并不要求以基本图形为依据，它是可以随意安排的。<br>有些图形的色调可以局部改变，有些图形的色调可以全部改变。<br>把基本图形交错形成的那些小图形搭配起来，我们就能创造出新的图形。</p>
<p>从构图上说，可以让画面的一半是亮调，一半是暗调。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123229.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>也可让画面从亮到暗逐渐变化。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123239.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>让明暗各点适当地分布在画面上，就能在画面不同部位形成对比强烈、明暗交错的生动影调。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-01/20240801123256.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>有人可能认为，只有在手绘图画中才能不受约束地配置明暗。<br><strong>完全不是这样！</strong><br>虽然摄影家要控制照片中每个明暗变化并非易事，但实际余地要比人们想象的多。</p>
<p>想要取得上列照片所表现的那些变化，只要把自然光线稍加改变，就可以达到目的。<br>此外，还可以自由选择拍摄位置以增加变化的机会。</p>
<p>在静物摄影构图中，为了改变色调，可以调换被摄物品。<br>调整光线不仅能够改变色调，还可以利用阴和影来构成各种图案。<br>选择适当的背景，又为摄影家提供了一个构图的机会，这里除了利用大量素色材素和有图案的材料以外，还可以用周围的环境。<br>在肖像和人体摄影构图中，作为构图要素的色调，能够通过衣着、照明、背景以及画面点缀物来进行调整。<br>一张成功的作品，往往需要事前周密地安排。</p>
<p>最后，在印放过程中，我们经常还要进行机动灵活的加工处理。<br>明暗配置在表现感情方面是很有影响的一个手段。<br>平静还是活跃，强烈还是温柔，整齐还是不规则⋯⋯所有这些，甚至不止这些，都可以通过有效的明暗配置来达到。<br>这方面的潜力是无限的；如果说有限的话，那是因为摄影者本身的洞察力有限。</p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 结束语</title>
    <url>/2024/09/04/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E7%BB%93%E6%9D%9F%E8%AF%AD/</url>
    <content><![CDATA[<p>要使好的作品变成杰作，还有一个因素是必不可少的。<br>这个因素在前面各章中虽然没有直接阐述，但曾多次提及。<br>因为找不到恰当的名称，我们姑且称之为“魅力”。<br>它是一种能达到而很难超越的艺术境界。</p>
<p>纵观历史，曾有多少艺术家在各方面成绩卓著！唯独他们的摄影作品却难于轰动。<br>很多有才华的作家，尽管学会了写作的各种原理，也应用于写作实践，但却不能创作出堪称文学巨著的任何作品。<br>不少艺术家的某一幅摄影作品确为杰作，而其它作品则不过平平而已。<br>尽管他们既了解各种原理，又能一如既往地付诸实践，但不成功的作品还是屡见不鲜。</p>
<p>很明显，一旦摄影家的技术与灵感与主题奇妙地结合起来，必然会出现不寻常的作品，毫无疑问，这样的作品一定是伟大的艺术品。<br>它常常表现出一向无法表现的或被忽视的艺术效果。</p>
<p>对于那些只拍摄“美好事物”的普通摄影爱好者来说，这种情况即使会出现，也是非常罕见的。<br>而对于一个经验丰富的摄影家展出的每幅作品几乎都具有无与伦比的艺术效果。<br>但这并不意味着他们的拍摄对象样样绝妙，不过他们有足够的聪明才智善于汲取精华，剔除糟粕。</p>
<p>我们所知道的一切有成就的摄影家，都对摄影构图的抽象原理和要素有极深的造诣；他们重视这些原理和要素的研究并善于运用它们。<br>这些要素和原理至少使作品具有魅力的可靠手段。每一个艺术家都有个人的倾向性和所偏爱的构图组合形式。<br>这些会在他的大部分作品中表现出来，成为他的作品标志，并使他的作品具有独树一帜的个人特点。</p>
<p>在摄影构图的研究中，存在着一种潜在的危险，那就是把掌握要素及其应用理解为一种纯粹的机械过程。<br>把这样的一门学问竟降格为一道道的工艺程序，以至于在那些还没有出现流水作业法的研究领域里，有些人竟要设法发明出一个流水作业式的程序来。</p>
<p>艺术是一个复杂的研究课题，它始终抵制甚至反对把这种研究局限在固定程序之内的作法。<br>仅仅把各种形状、线条和质地罗列在一起，即便安排得富于对比和节奏，并不能算是艺术创作。<br>假使优秀的摄影作品能用某种规定的程序一蹴而就。<br>那么，能够创作出优秀作品的人势必比现有的人数要多得多。</p>
<p>有些摄影者错误地认为，由于采用了非写实的拍摄方法，他们便是在自然而然地创造艺术了。<br>然而，艺术创作决不是自然而然的东西。<br>拍出的照片，无论是把明确可辨的事物抽象化，还是把纯粹的几何形状组合起来，都无关紧要。<br>关键的问题是要使抽象的东西转化为人们的感受。<br>在拍摄过程中，如果不能把指导思想放在感染观众这一点上，作品势必会显得死板单调。</p>
<p>艺术魅力的大小主要取决于拍摄者在创作瞬间对主题感受程度的深浅。<br>不管拍摄内容是具体真实的还是非写实的，使艺术家的灵感受到激发的是拍摄内容的抽象形式。</p>
<p>正像诗人找寻词藻去表现他胸中的诗情一样，摄影艺术家总是寻找一定的形式来进行视觉艺术上的表现。<br>他在构图中可以使用夸张的手法，而不要拘泥于原貌，这正是显示了人类能够以独特的形式表现拍摄内容的巨大才能。</p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 统一</title>
    <url>/2024/09/01/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E7%BB%9F%E4%B8%80/</url>
    <content><![CDATA[<h2 id="从单数到多数"><a href="#从单数到多数" class="headerlink" title="从单数到多数"></a>从单数到多数</h2><p>学习摄影的初期，人们总是避免拍摄这样的照片：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113414.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>原来的意图是打算把一个景物拍成一张照片，而结果却好象两张不相关的底片印到一张相纸上了。<br>一条醒目的白线横在画面的中央，使上下两半部大小相等，看起来更象是两张照片了。<br>这个问题在拍摄自然景物时，比如在地平线居中，天空和地面平分秋色的情况下最容易碰到。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113433.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果两个部分并不相等，就不大容易看成是两张照片了，然而仍然缺乏整体感和组织结构上的统一性。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113451.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>同样的问题在有垂直分界线的照片中，也可以见到，虽然碰到的机会要少一些。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113506.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这所公寓楼房左侧尽头处有条白边，看起来正象是两张单独照片的中间分界线。<br>剪裁一下，让公寓楼所占空间狭窄一些能使情况有所改善，但讨厌的分隔现象依然明显存在。</p>
<p>如果画面的透视是倾斜的横线，两部分互相脱离的感觉可大为减少。<br>然而，仍然存在上面的亮区和下面的暗区之间缺少联系的感觉。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113518.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>问题的关键在于这些构图没有遵循这样的原则：<br>即直线，特别是和边框平行的直线，不能毫不间断地从画面的一边伸向另一边。<br>一旦这种直线的延续性中断，而且某一部分画面的图形伸进另一部分画面，整体感觉牢固地建立起来了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113528.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113539.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果有较暗的图象嵌入较亮的区域，同时有较亮的图象嵌入较暗的区域，会产生一种更强的整体感。<br>在暗处安排上几个独立的明亮物体，或在亮处安排上几个较暗的物体，统一感还可以进一步增强。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113551.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果明亮图形和较暗背景以及较暗图形和明亮背景之间更大程度地相互交错，整个画面会更加生动活泼。<br>原来的一大片连续不断的单调的画面现在穿插了很多引人注目的内容。<br>由于这个原因，上图看起来比下图要宁静、舒适得多。<br>尽管明暗部分的边缘相交错，但画面仍然保持着两个基本的、区别明显的明暗区域。<br>明暗两个部分多外互相穿插交错，所以互相分离的感觉便不复存在了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113604.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>幸好，夹在两个烟囱之间的克莱斯勒大楼和泛美大楼传达了人类活动的信息，保持了主题的统一感，而不断重复出现的垂直结构又加强了方向上的统一感。<br>画面上表现出来的许多明暗层次产生出巨大的活力，但也因此削弱了象图四六六中那种明暗结构的高度统一感。</p>
<p>这正是一个摄影家经常需要做出判断。<br>有所取必有所舍。<br>我们不可能运用高度统一的明暗结构表现出在图四六七中所见到的那种活力。</p>
<p>从理论上讲，我们倒是可以连续使用这种方法使大片画面不那么连贯严密，甚至不惜使主体变得松散，近乎不太规则。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113615.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>一般说来，窗户形状的有节奏的重复可以加强统一感。<br>但是图中，窗户太多，差异太大，方向太杂，所以视觉效果十分混乱。<br>再加上明暗的统一遭到破坏，所以我们可以说这张照片简直是杂乱不堪。<br>这里找不到趣味中心，也看不出拍摄者要表达什么思想，连大城市的繁化也丧失殆尽。</p>
<p>可见，一个好的主意或作法，如果一味地抱住不放也未必就能改进效果。<br>我们难免会遇到这样的情况，譬如一个方案解决了原有的问题，但接着它本身又成了一个新的问题。<br>为了处理一个缺乏统一感的画面，往往先作一些调整，去掉毛病，然后，再进一步作同样性质的调整，使问题解决得比较满意。<br>但如果沿着这条路不断走下去，势必削弱，甚至最后完全破坏了统一性。</p>
<p>统一性就是拍摄意图的单一性，并通过照片的各个方面来表达这个单一性。<br>摄影家在为照片选择人物或环境时，应该注意保持主题的始终如一，这样才不致偏离中心思想。<br>现在，你会更加明白，我们讨论对比、节奏、趣味中心和布局等问题时提到过的许多例子，其目的原来都是为了获得统一感。</p>
<p>一幅缺乏统一感的照片，其效果正像说话和写文章缺乏统一性一样，往往概念不清，使人不得要领，不能形成视觉概念。<br>本来应该统一起来的各个部分，变得支离破碎，毫无意义。</p>
<p>除了本章前述方法以外，还有很多方法可以加强照片的统一感。<br>虽然各种方法都服务于一个基本目的，但因为每个方法涉及的内容并不相同，所以途径各异。<br>由于画面的结构不尽相同，所以我们这里提出的具体方法只能适用于某一具体的构图。<br>下面所讨论的内容不过是些一般化的指导，目的是帮你打开解决问题的思路。</p>
<h2 id="拍摄对象在主题中的统一"><a href="#拍摄对象在主题中的统一" class="headerlink" title="拍摄对象在主题中的统一"></a>拍摄对象在主题中的统一</h2><p>取得统一感的一个明显的方法，就是只拍摄和中心思想有关的人和物，尽可能排除和主题没有直接关系或没有直接益处的人和物。</p>
<p>下图表现一群工人正在给成型的木板涂刷粘合剂，要把许多层本板粘合起来，然后再做成龙骨模型。<br>这里要表达的基本意思是粘合成型板这一工艺过程，没有包括可能分散或削弱主题统一性的东西。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113629.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>工人们穿的衣服都很相似，差别很小，除了一人具以外都戴着帽子。<br>每个人都使用同样的工具和手提桶，涂刷同样的粘合剂。<br>每个人涂胶工作的强度都差不多。<br>因为两层木板要粘合起来，所以它们的形状也十分近似。<br>照片上的每件东西都围绕着一个活动，中心思想就是表现在粘合木板之前涂刷粘合剂。<br>像这样专门表达一个单一的概念，是不难求得主题的统一的。<br>有些因素是有损统一的，试列举一二。</p>
<p>在图里，作者没有把注意力集中到任何一个人身上，在姿势或布局上没有作任何精心安排，没有试图突出任何人的地位或重要性，也没有表现任何人的个性和特点。<br>上述内容无论哪一项如果出现在画面上，都会自成中心，从而破坏活动的统一性。<br>在这张照片里，环境的布置只限于该工序最必需的几件设备；<br>没有包括与本工序无关的活动。<br>机器、工具、帆、绳子、其它船上设备或造船设备都没有进入画面。</p>
<h2 id="相似形状和相似方向的重复"><a href="#相似形状和相似方向的重复" class="headerlink" title="相似形状和相似方向的重复"></a>相似形状和相似方向的重复</h2><p>在第十一章《节奏》中，我们看到相似的形状可以放在一起，成为具有一定间隔的组合。<br>这些组合的重复或延续能产生一种节奏，表现出动感。<br>由于这些组合和节奏的间隔很相似，又由于这种动感趋向于把构图的各个部分结合成一个一致的整体，所以这样的构图显现出统一性。</p>
<p>但是，并不是所有相似的形状都具有规律性的间隔，都能够成节奏的。<br>有时候，尽管相似形状重复出现，而节奏却不能形成特定的节奏，相似的形状却有了相当的重复，足以建立起一个清楚明确的整体。</p>
<p>在图中，形状和垂直体的重复就是一个强有力的统一因素。<br>看看这张照片，没有人会对照片所要表现的内容提出疑问。<br>这里突出的和吸引注意力的正是主体的一致性，没有炫耀其中某一个形状。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113647.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>可以看出，在下图中，是应用了上述原理的，但却出现了本章本始时提出的问题。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113659.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这张照片的上下两半部，都可以作为单儿的照片而存在，因为上下两个部分没有互相穿插交错之处。<br>这样的照片本来是谈不上具有整体感的。<br>但是，两个相似的船形重复出现和人体的位置重复出现，而且背景上，海滩和海水的水平线条也重复出现，这都给画面带来一种明确的整体感。<br>另外，下面一条船的上部边缘很亮，它和上边一条船的反光相结合，更增强了整体感。<br>两个明亮的部分结合成一个光亮的背景部分，和下面小船灰暗的船底形成了强烈的对比。</p>
<h2 id="通过组合求统一"><a href="#通过组合求统一" class="headerlink" title="通过组合求统一"></a>通过组合求统一</h2><p>我们常常需要拍摄一个由很多单个物体组成的题材。<br>如果把每个物体的吸引力和情趣都单独表现一番，那么，这张照片势必一团混乱。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113713.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>要善于删节。<br>这种手法不论是为了突出某个内容，还是为了使画面统一都是需要的。<br>突出和统一并不是截然对立的。<br>为了集<br>中研究，可以把拍摄对象适当地组合起来，使每一组合中包含若干个有关的拍摄对象，所以，大部分拍摄对象的个性不得不忍痛放弃。</p>
<p>这样，观众就不会看得眼花缭乱，而可以从容地把注意力集中在少数几个组合上。<br>少数几个组合的吸引力要远远超过众多的拍摄对象。<br>画面一旦有了吸引力，就可以引导观众去观察各组中的个体了。</p>
<p>可以按照下列方式进行组合：</p>
<p>按尺寸大小：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113724.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>按形状异同：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113734.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>按线条的特性：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113744.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>按物体的功能：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113753.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>按共同的兴趣：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113805.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>每个组合具有内在的统一性并由一个背景加以衬托。<br>这个背景可以是画面中一个较大的景物，也可以是任意选择的一个形状，但要具有适当的明晰度，以及一定的色调和质感。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113814.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>每一组合中最外侧的形状，就是该组合的轮廓，这个轮廓本身应该极富情趣，同时要与画面中出现的其它组合互相协调。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113828.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>组合的轮廓必须仔细设计，否则，整个组合会显得笨拙乏味，就会抵消它的效果和情趣。<br>如果它的边缘明暗交替，和背景时而融合时而分离，就会因为边缘的色调太复杂而妨碍了统一感。<br>正是上述两种毛病使构图显得很不高明。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113839.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果在拍摄对象之中有很多相似的地方，那就可以把它们划成一个或多个组合，从而建立起重复的或渐变的节奏，或者把它们安排成一个流畅的曲线。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113851.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果节奏不是十分明显，统一感就无法建立。<br>图中的混乱就在于，看不出外侧半圆的物体是通过重复的方式而互相联系的，还是通过放射的方式与内侧的半圆相联系。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-01/20240901-113901.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="统一的多变性"><a href="#统一的多变性" class="headerlink" title="统一的多变性"></a>统一的多变性</h2><p>统一感一旦建立起来并且使摄影家感到满意时，任何变化都会把它们打乱。<br>正是这个缔造组合的力量，可能转而产生反效果。<br>原来联系在一起的物体，由于其它物体的介入而失去原有的联系，从而形成新的组合。</p>
<p>请仔细端详图四八四中的两个人。<br>他们坐在长凳的两头，并没有互相靠近，但是，由于他们同坐在一条长凳，由于长凳上的水平线条，由他们都是单影只而具体形相似，所以他们又是统一的整体。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124203.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果我们在一个人的身旁加上另一个，统一性便函发生了戏剧性的变化。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124217.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在右侧两个人成一一个整体。原来两个人之间的间隔变得十分明显，似乎把两个人隔开了。<br>在左侧那个人的旁边加上第四个人，原来的统一便彻底打破了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124225.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在，每一对人之间的距离比原来两人之间的距离小得多，所以新的两对各自统一起来，而原来两人的间隔变成了背景的一部分。</p>
<h2 id="通过对比求统一"><a href="#通过对比求统一" class="headerlink" title="通过对比求统一"></a>通过对比求统一</h2><p>统一感的获得取决于画面各部分相互之间以及各部分和画面整体之间的关系。<br>我们发现，利用大小的相似和形状的相似能够很容易地建立起这种关系来。<br>每当重复的物体和有区别的物体出现时，我们的眼晴能够迅速察觉一个形象的重复出现，并且能够捕捉随时出现的细微变化。</p>
<p>对立物之间，有时候也是自动地互相联系着的：<br>在科学上，是正和负的关系；<br>在哲学上，是肉体和精神的关系；<br>在艺术上则是明和暗、快乐和抑郁、大和小、上和下等等的关系。<br>其实，从效果上看，这些就是对比关系，这种关系至少和相似关系一样容易理解。<br>白色衬在黑色上，比白衬白、黑衬黑更容易接受。<br>所以对比或差异也是求得统一感的一种有效手段。</p>
<p>要深入研究一个由许多个体组成的主题时，我们可以按照大小、形状、色调和方向来进行组合，找出它们之间的对比关系，并且让各个组合按照对比方式互相衬托。</p>
<h2 id="通过一体化求统一"><a href="#通过一体化求统一" class="headerlink" title="通过一体化求统一"></a>通过一体化求统一</h2><p>一般说来，画面上个体的数目越少，照片的吸引力就越大。</p>
<p>如果照片内部互相竞争的个体减少了，照片就能发挥更大的视觉效果，就更能吸引观众的注意。<br>单独一个形象会一下子抓住观众的注意力。<br>再加上一个形象，目光就不能不从第一个转向第二个，然后再回到第一个上去。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124238.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124249.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>个体增加得越多，越需要花时间去分析拍摄意图和形式之间的关系，产生混乱的可能性也就随之增加。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124300.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124310.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>所以，需要通过分组的办法尽量减少单独存在的个体的数目。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124321.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>像各种事物都存在物极必反的道理一样，把所有个体完全统一在一起又嫌过分了。<br>把所有物体都纳入一个整体，会显得过分的密集，使人很不愉快。<br>因为画面中的物体不是整体化而是拥挤化了，所以必然会显得杂乱不堪。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124330.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在拍摄意图和画面效果两个方面，我们必须进行不断的试验和评价，找出最好的解决方案。<br>靠原理不能解决具体问题，原理只能一般地指导我们的思想方法。</p>
<p>需要用多少物体去构成一个单一的单位，怎样搭配组合，以及照片中需要几个这样的单位，这些都是摄影家在力求实现自己意图时必须作出的抉择。<br>在解决方案中，有一部分要取决于主题本身的需要，而大部分则取决于摄影家本人的风格和决心。<br>我们的目的是要成功地体现中心思想，所以背离这个目的的任何做法都应坚决避免。</p>
<h2 id="明和暗的统一"><a href="#明和暗的统一" class="headerlink" title="明和暗的统一"></a>明和暗的统一</h2><p>我们在研究明和暗的时候曾经注意到，尽管线条结构保持不变，但设计出来的图案却可以千变万化。<br>在有些设计中，整个画面布满了亮调和灰色。<br>这虽然会带来活力，但却显得松散。<br>在图中，尽管形状很统一，各形状大小的相互关系也合适，但画面总的统一感并不十分强烈，因为明和暗的分布过于零乱。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124343.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>的设计中，使用了同样的线条结构，但若用亮调、暗调和灰色把一些形状联结起来，使图形的总数大大减少，画面会显得更统一，更简洁，更稳定。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-02/20240902124352.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>色调的连贯性是表现统一感的有力因素。<br>如果求得统一感是首要目的，而且又没有特殊需要必需造成对比，我们就可以让明和暗渐次过渡以实现整体化。<br>如果必需把几个独立的物体拍在一起，而又缺乏适当的线条、形状和节奏可以帮助实现统一的时候，这种方法就尤其有用。</p>
<p>柔和的现场光只是影响照片影调的一个因素。<br>而经过安排的照明，无论是利用自然光还是人造光，都可以改变任何物体的影调，必要时，能使明亮的物体变暗，暗调的物体变亮。<br>摄影家应努力地发掘改变色调的各种机会，以便使构图要素和构图原理有利于表现主题，增强画面的表现力。<br>只有当线条、形状和色调互相密切配合，而且和主体交织在一起，形成一个能表现中心思想的协调的画面时，才能实现美学上的统一性。<br>只有局部烘托整体，整体寓于局部，观众才能立即感受到画面的和谐和完美。<br>只有这样的构图，才算达到了完美和统一。</p>
<h2 id="通过流畅线条求统一"><a href="#通过流畅线条求统一" class="headerlink" title="通过流畅线条求统一"></a>通过流畅线条求统一</h2><p>流畅的线条始终是达到统一的可靠手段，正像它对于节奏的作用一样。<br>流畅的线条在画面上移动，勾划出毗邻物体的分界线。<br>由于毗邻物体共用同一线条，使这条线成为整体内部每个局部的必然组成部分，因此，这种构图便具有强烈的统一感。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-03/20240903123109.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>每一个旅行者，或徒步或骑车或乘车，都会意识到，他曾逗留或经过的地方，都因旅行路线之间的联系而存在一种统一的感觉。<br>这种统一感和道路本身曲折的地理方向毫无关系，和毗邻两地的位置也没有关系。<br>这种统一感的联想可能源出于两端的起迄点。</p>
<p>其所以有这种统一感，很大程度上是和沿途的行动路线以及逗留的地点有关。<br>把几个地方联系起来的正是运动本身。<br>在构图中出现的流畅线条也具有这种效果。<br>观众用目光追踪着弯弯曲曲的线路，同时产生了一种实地运动的感觉。<br>把画面中的各部分相互联系起来，也能产生一种统一感，就好象我们是在各个部分之间实地运动一样。</p>
<p>下图表示若干独立的物体被安排在毫不相干的位置上。<br>无论怎样用心观察，我们的眼睛也无法把它们连接成一个有意义的整体。<br>所以，这张照片的构图杂乱无章。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-03/20240903123117.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果我们用细绳，线带或缎带穿过每个点，把它们连成一条流畅的线条，统一感转眼就形成了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-03/20240903123126.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>流畅的线条常常互相交叉或者在某点上互相靠近，于是形成了封闭的或半封闭的图形。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-03/20240903123132.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在这种情况下，这个图形内的一切内容，不管怎样零乱，都趋于统一。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-03/20240903123141.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在以上关于流畅线条的讨论中，我们只涉及了一些容易看出的、有形线条的作用。<br>下文讨论的是通过某些更为微妙的方式，去获得流畅线条的另一种效果。<br>这种效果尽管人人都可感受，却只有构图能手才能充分理解。</p>
<p>这是指从相邻的形状、阴影和间隔的边缘上引起的流畅线条，而不是线绳或缎带那样细长而单一的东西所形成的线条。<br>这种线条可以从一个物体上引出，沿着其它物体的边缘移动，给人的感觉象是一个有组织的，有节奏的运动，这种运动在画面之间延续着，从而把各个物体相互联系起来。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-03/20240903123152.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>图中有一大堆木材，它的情趣恰恰源于这种运动，这种运动包含了不只一个，而是若干线条。<br>我们可以从任何一个圆木的边缘开始观察，顺着这条线看过去，你的目光马上会被吸引着去追踪那些木头的轮廓、间隙和阴影。<br>我们把照片简化成两个最基本的色调，使形状和质地更加抽象化，统一感也就更容易被察觉了。</p>
<h2 id="背景对统一感的作用"><a href="#背景对统一感的作用" class="headerlink" title="背景对统一感的作用"></a>背景对统一感的作用</h2><p>很多摄影者认为背景不过是一个未被主题占据的空间，对构图来说并无利弊可言。某些背景被认为起着分隔两个物体的作用。<br>些外，这些人总是设法把背景减少到最小限度。<br>他们认为主体越大越好，拍摄对象的外缘应该紧靠边框，裁掉背景，把注意力完全集中在拍摄对象身上。</p>
<p>这些都是非常错误的！</p>
<p>背景是一种微妙的，但却是强有力的构图因素。<br>在《形状》一章中，我们看到物体之间的空档就是背景形状，它足以影响画面的整个面貌。<br>物体的外缘和照片边框之间形成的空档也有类似的性质。</p>
<p>背景空间对统一感有着深刻的影响，这一点从下面的试验中可以看出来：<br>收集若干物品，每一个物品的形状和色调都完全不同，而且它们的作用应毫不相干。<br>把它们摆在一张桌子上，衬上一个简单而色调一致的背景。<br>注意尽可能不要建立什么统一感，避免出现组合，尽量不要重迭。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-03/20240903123202.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>用取影器观察构图，同时注意在物体外侧的周围留出相当的空间。<br>拍过以后印出两张照片。<br>一张紧靠物体剪裁，另一张在物体周围留出相当大的空间作为背景。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-09-03/20240903123219.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>注意观察：第一张照片显得散乱，并缺乏统一感。<br>也许需要极大的努力，才能在形状、色调或质地方面找出相似因素，但这样得出的结果只能是一种人为的条理化，而不反映画面各物体之间实际的相互关系。</p>
<p>我们并不想把第二张照片看作成功之作。<br>它原来就缺乏统一感，现在零乱的感觉依然明显如故。<br>但是你会注意到，它给人的零乱感觉要少得多！<br>物体四周有个空间，似乎使物体靠近了。<br>因为这部分空间比任意两个物体之间的空间都大得多，所以这张照片中的物体和第一张比较起来显得要紧凑得多。</p>
<p>这并不意味着要大家把每一张照片的背景都留得很大。<br>这不过是说明了背景空间在改变物体形象方面的作用。<br>如果物体之间的间隔很少而且安排得很紧凑，那么背景可以拍得小一点。<br>这时，那小小的背景区域看起来像给每个物体周围加上了更大的“天地”，并且减少了拥挤和密集的感觉。<br>拥挤和过分松散对于构图同样是有害的。</p>
<p>如果物体之间的空间比较大，足以削弱统一感，显得松散的话，那么，背景也可以放大一些。</p>
<p>在构图中，统一感和其它原理密切相关，必须通盘考虑，不可有所偏废。</p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 艺术</title>
    <url>/2024/07/14/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="艺术形式"><a href="#艺术形式" class="headerlink" title="艺术形式"></a>艺术形式</h2><blockquote>
<p>艺术的形式也是不断变化的。<sup>1.1.2</sup></p>
</blockquote>
<p>为什么一件作品可以称为艺术品，而在许多方面都和它相似的另一件却不是?</p>
<ol>
<li>艺术和自然的异同</li>
<li>视觉形象思维和文字概念的区别</li>
<li>艺术和手艺的关系</li>
</ol>
<h2 id="艺术与自然描绘"><a href="#艺术与自然描绘" class="headerlink" title="艺术与自然描绘"></a>艺术与自然描绘</h2><blockquote>
<p>艺术家们摆脱了如实记录的重担以后，便转而探索艺术的更本质的特征。</p>
</blockquote>
<blockquote>
<p>自然界有它本身的美，并不在于人们是否去捕捉这些美。</p>
</blockquote>
<blockquote>
<p>无论是剪裁遮挡还是增添什么景物都无法弥补拍摄时所缺乏的东西——那就是题材固有美之外摄影家心目中所认识所发现的美的因素。</p>
</blockquote>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/2024-07-14_1.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/2024-07-14_2.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>摄影者头脑中富有生动的艺术构思, 那么即使看起并不没得自然景色,人和物也能拍成很好的佳作.</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/2024-07-14_3.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="艺术与抽象的视觉美点"><a href="#艺术与抽象的视觉美点" class="headerlink" title="艺术与抽象的视觉美点"></a>艺术与抽象的视觉美点</h2><blockquote>
<p>问题的关键是，艺术效果完全取决于艺术家是否从这个题材中发现了和感觉到了抽象的视觉美点，以及处理它们的能力；经过这番处理观众才能看到艺术家曾经看到过的东西，激发出和艺术家同样的感情。</p>
</blockquote>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-14/2024-07-14_4.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<blockquote>
<p>虽然有时候照片里看到的东西难以解释，简直象是魔术一样，但有许多东西仍然是可以弄清楚的。有些摄影家生来就是很敏感，他们能在看来无所作为的地方一下子发现奇迹。有些人需要经过一番启发才能认识潜在的视觉因素。然后也能不太费事地发现它们。大多数人则必需给以系统的教育，提高他们认识视觉美点的敏感性，用这种方法培养他们的辨别能力。</p>
</blockquote>
<h2 id="构图-从混乱中找出秩序"><a href="#构图-从混乱中找出秩序" class="headerlink" title="构图 从混乱中找出秩序"></a>构图 从混乱中找出秩序</h2><blockquote>
<p>构图是一个思维过程，它从自然存在的混乱事物中找出秩序；</p>
</blockquote>
<blockquote>
<p>通过构图，摄影家澄清了他要表达的信息，把观众的注意力引向他发现的那些最重要有趣的要素。</p>
</blockquote>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 节奏</title>
    <url>/2024/08/27/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E8%8A%82%E5%A5%8F/</url>
    <content><![CDATA[<p>虽然我们每个人对于什么是条理性的看法有所不同，但我们都自然而然地、心甘情愿地接受了它的结果：</p>
<blockquote>
<p>秩序</p>
</blockquote>
<p>人生大部分时间是用于安排切身环境，使用各种工具以及进行各种活动。<br>我们从事这些活动的目的，不仅为了提高成效，而且为了从那些有规律有组织的生活方式中求得愉快和满足。</p>
<p>除了切身环境以外，我们还从大自然或人类自己巧妙安排的生息条件中得到快乐。<br>从生的灌木，茂密的树林除了吸引生物学家以外，没有其它诱人之处。<br>但是，当我们置身于牧场，看到眼前风吹草舞，周围山峦起伏，我们都会心旷神怡。<br>蜿蜒的田垄，美丽的公园，宜人的城镇都能使人赏心悦目。</p>
<p>如果我们对生活的某一方面难以驾驭，就会产生不稳定感。</p>
<p>对此，大多数人都会感到不快，都要设法避免。<br>所以他们都尽力追求一种自己能够控制的安定而有秩序的生活。<br>正因为艺术家感到了这种心理上的需要，他总是有意识地赋予他的作品以条理感与和谐感，因为它们能满足人们在这方面的要求。</p>
<p>当自然的或人为的混乱发生的时候，一个不太敏感的人只是在内心里承受了这种不愉快，继续生活下去。<br>他既没有能力也无意于探求究竟，特别当他能找到现成的有秩序的去处可以满足他的心理需要的时候，他也就随遇而安了。</p>
<p>而对于艺术家来说，他却必须在无秩序之中寻求秩序，在一片混乱之中看出生活某一侧面的反映；<br>反映出来的东西可能是讨厌的，使人不愉快，甚至可能难登大雅之堂的。他能抛开世俗的见解，发现被忽视了的美。<br>他应该探索不同于前人的观点，避免那种只有门外汉才感兴趣的老一套的手法。</p>
<p>面对着形状，色彩，质感各自不同的大量拍摄对象，摄影家的脑子里总是不断地盘算着怎样从杂乱无章之中理出和谐的因素来，这就是丑中之美；<br>而这里所谓的美就是条理感。<br>在混乱之中，特别当主题或景物本身缺乏固有美的时候，这种条理感是很难发现的。</p>
<p>把画面各个部分组织起来，也是构图的实质所在；<br>只有这样，被摄事物和你的既定思想才能得到成功的表达。<br>补充景物可以出现在画面上，但它们只能处于次要地位。</p>
<p>在前一章，我们曾经讲过怎样通过有效地利用差异而求得秩序。<br>相反的事物，由于它们截然不同而被突出，使人不至于忽略它们。<br>观众也会因此而比较容易地看到摄影家想让人们看到的东西。<br>恰当地安排对立的事物，就能创造出由于矛盾着的因素构成的均衡而稳定的统一体。<br>垂直的物体和水平的物体联系起来观看最有意义。<br>黑暗这个概念是只有和光明联系起来才能理解。<br>巨大所包含的尺寸是和某个渺小物体相对而言的。</p>
<p>题材中对立因素的数量和对立的强烈程度决定着它们被强调的程度。<br>如果一张照片的每个部分包含的对立面太多，就会造成混乱不堪的局面。<br>但是，如果一个题材适合于表现混乱，而混乱正是摄影家想要表达的气氛，那么，就最大限度地利用差异和对立吧！</p>
<h2 id="通过相似点形成和谐感"><a href="#通过相似点形成和谐感" class="headerlink" title="通过相似点形成和谐感"></a>通过相似点形成和谐感</h2><p>前面讲的是差异的作用。<br>相反地，把相似物体适当地结合起来也能取得和谐的效果。<br>这里，我们要把特征相近的物体和构图要素加以归类和研究。</p>
<p>其实，这两种情况并没有矛盾。<br>因为不管碰到的是什么题材，摄影家为了拍出最好的照片，都是要把它们当作视觉材料加以发掘和利用的。<br>要作出符合摄影美学的处理，关键在于题材本身能够说明什么，摄影家个人认为有意义的是什么，他选择什么方法表达自己的意图。</p>
<p>人们在下面这样的画面中会看到那种由于不同图形的堆积而造成的混乱现象；<br>画面中的许多图形在大尺寸和形状方面过于相似，致使人们无法从中找到占据优势的形象。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123753.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>因为题材本身没有提供适当的材料，无法建立有效的对比。<br>所以艺术家要善于观察，要在一片混乱之中去发现一些具有共同特征的图形，并以适当方式组织起来。<br>它们可能在大小、形状、方向、色调或质感方面有相似之处。</p>
<p>让我们假设，最符合这些条件的是画面中那些圆形。<br>它们的形状和大小大致相同，而且能和其它形象区分开来，有可能找出它们的内在联系。<br>这里使用的方法和前一章不同。<br>我们不是把一个物体突出并加以强调，而是留意找出可以结成一体的成组图形。<br>我们可以通过滤镜对负片进行控制，或通过印放时处理，或者两者兼用，来提高这些圆形的亮度，使它们具有相似的影调，同时把画面其它图形压暗。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123802.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>于是，明显的相似关系就表现出来了，更值得人们仔细观察。<br>由于图形相似，间隔相等，给人以明显的有组织的感觉。<br>而且其余图形都变成了背景，在背景的衬托下，虽然这些圆形之间并无实际联系，但我们观察整组图形时，能得到一种波浪式运动的印象。</p>
<p>像音乐听众预测节拍一样，摄影作品的观众也能在一组相似形象中辨认某一形象，并且预感它的再现。<br>经过合理安排后，有节奏的动感，能够引导观众的视线沿着画面移动，满足他们的视觉感受，抓住他们的注意力。</p>
<p>圆形和间隔的不断重复，从无秩序中引出了秩序，给人以很大的满足。<br>因为它是音乐和诗歌中的节拍在视觉上的表现，所以把它叫做节奏。</p>
<h2 id="节奏"><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h2><p>作为艺术家，我们不可避免地要受含有节奏的自然力的影响。<br>昼夜交替，四季循环，海浪拍岸，心脏搏动，它们都有自己的节奏，而且我们也感到非常协调，一旦稍有违拗就会产生危机。<br>在我们日常生活中的节奏中，时区的变化极其重要，以至乘喷气客机远游的旅行者，需要好几天的时间进行体内调整，才能适应这种改变。</p>
<p>我们工作和游乐的每一个方面，都是以节奏为基础或服从于节奏的，它甚至成了控制世界上各种物体间相互关系的力量。<br>光、热、声、磁都是节奏的不同形式，它的轻微变化都会导致很大的差异，睡眠和觉醒的周期性交替是人类生存的基本条件。</p>
<p>节奏是一人有秩序的进程，它提供着可靠的格局和步调。<br>一旦建立起一定的节奏，我们就能够预见它的连续出现。<br>保持了节奏，我们就会感到愉快。</p>
<p>由于节奏具有高低起伏的一定格局，它就成了激发情感，表达情感的理想手段。<br>它除了具有实际的感情方面的作用以外，也是表达感情的艺术领域里最有影响的因素。<br>节奏能激发和丰富人们的想象力。</p>
<p>大部分人生来就具有节奏感。<br>试从背后观察一个体态协调的人走路的姿势，并且注意他是怎样保持节奏的。<br>不但脚跟着地的声音有节奏，而且双臂的摆动、肩膀和髋骨对称交替地倾斜和脊椎的扭动都有明显的节奏。<br>不同年龄的人走起路来节奏是不同的。<br>在青年的早期，男女间的差异就已经出现，到了成年时期，这种差异就更加明显了。<br>在同年龄同性别的人当中，每个人又养成了自己独特的走路节奏。</p>
<p>人类每一个活动都和某各节奏形式有关。<br>请注意那木匠锯木，船工划船和游泳比赛，观察他们是怎样有规律地一动一停，从而使他们的活动变得轻松自如。<br>节奏能使从事活动的人和旁观者同样感到愉快。<br>我们会情不自禁地被那种和谐摆动所吸引。</p>
<p>正像一个缺乏节奏的人跳舞时显得滑稽可笑一样，一幅本来包含着形成节奏的条件但却没有形成节奏的照片，同样如此。<br>这种照片，给人的印象是不舒服的。对整个照片来说，线条、形状和色调等也就无法形成有节奏的感染力。</p>
<p>在有节奏的作品中，不见得每个物体都十分相像或每个间隔都完全相等，也不见得都是严格地重复出现的。<br>它不是机械式的，而是微妙的差别和变化，正是这些差别和变化给作品增添了趣味。</p>
<h2 id="节奏的视觉快感"><a href="#节奏的视觉快感" class="headerlink" title="节奏的视觉快感"></a>节奏的视觉快感</h2><p>照片不一定必须具有某种含义。<br>照片的基本目的，除了某些具体用途之外，就是为了让人观看时得到视觉上的快感。<br>当然，由于内在的原因，各人的视觉经验是不同的。<br>但这种经验大部分都伴随着某种情绪的反应。<br>喜欢，还是不喜欢，往往是从这种经验出发的。</p>
<p>比起其他构图原则来，节奏更能引起视觉的快感。<br>它有很大的活力，即使最平淡的题材，只要发现了和再现了某种节奏，照片就能给人以深刻的印象。</p>
<h2 id="重复的节奏"><a href="#重复的节奏" class="headerlink" title="重复的节奏"></a>重复的节奏</h2><p>节奏最简单的形式，是通过某一形象，以相同的间隔重复出现而形成的一定格局。<br>我们可以把图三八二中那些圆形用任何形状来代替。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123819.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这些图形不一定要排列成一个流畅的曲线<br>可以排成一条水平线：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123828.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>一条垂直线：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123836.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>一条斜线：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123852.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>或者一条弧线：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123901.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>由两个物体构成的画面只能有一个间隔。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123911.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>虽然物体的形象重复出现了，但间隔只有一个，并没有重复，所以还不能形成节奏。<br>至少要有三个物体重复出现，而间隔至少重复一次，才能形成节奏。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123922.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>任何物体，任何构图要素都可以用来构成节奏。<br>形状、线条、影调、质感的重复出现并有重复出现的间隔，都能构成节奏。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123929.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>篱笆、成排的柱子，有拱顶的长廊，建筑物的窗户等，都是明显的例子，说明利用重复可以形成节奏。<br>有时候物体和间隔排列得过于精确，看来反倒有些呆板。<br>一个篱笆上的桩柱和间隔在排列上如果稍有些变化，看起来要比建筑物上尺寸间隔完全相同的一排更为有趣。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123944.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827123955.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827124004.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>捕虾浮标的照片就是这样。<br>在这张照片中，浮标整整齐齐地挂在捕虾人的板棚外边，浮标相似，间隔相等，构成了典型的由重复形成的节奏。<br>假如在安排上稍加调整，特别使间隔有些差异，会给画面增添生气。<br>每个浮标略微上下错开，特别是在上端部分，形成了一个波浪状的白色条带，和它下面稍有变化的白色背景相呼应，有几个空档未挂浮标，这表明浮标在不使用时是挂着保存的，更重要的是留些空间在构图上有利于打破呆板的相似状态。<br>在港口这幅照片里，小船重复出现，使垂直桩柱重复出现所形成的节奏更加强烈。</p>
<p>正像过多的差异会引起混乱一样，过多的相似也显得缺乏趣昧而导致单调。<br>在一块草地、一片茂密的花坛或一堵墙的照片中，不管人们能够找出多少构成节奏的因素，由于过分的相似还是不利于构图。<br>过分的统一与和谐能把艺术效果减到最低限度。</p>
<p>在自然界，这样的景色可能是美的，因为人的目光并不在它的上面停留多久。<br>人们会很快地把目光移向其它风景，从而进行了调剂。<br>留在人们头脑中的印象并不是照片上拍摄下来的景物，而是草地、花坛或砖墙与邻近景物的结合体。</p>
<p>摄影家必须提防人们的心理习惯对各种感觉的影响。<br>要花很长时间，积累很多经验，才能认识到下面这个事实：我们通过视觉所接受的东西，事实上包含了很多心理上的反应。<br>心理反应之一是上面所提到的：人们对邻近物体的印象，能对所选定的拍摄区域产生影响。<br>其二是一种错觉：鉴于人的眼晴能够集中注视一个单独的物体或一组物体而把不需要的细节略而不顾，因而误以为相机镜头也能这样。<br>还有一种心理反应是：当人们过于匆促地观察了一个题材中过分重复出现的各个相似部分时，往往会忽视其中的差异之处，而这种差异可能产生非凡的效果。<br>拍摄范围的缩小和画格的局限，都会使照片和实际景物之间发生很大的差别。</p>
<p>但是，我们必须再说一遍：</p>
<blockquote>
<p>艺术中没有绝对的东西！</p>
</blockquote>
<p>虽然有人认为完全的相似在大多数情况下会产生单调感，但也并非经常如此，有时候艺术家正是利用这种单调的成分构成影象，来表达一种独特的富于吸引力的质感。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-27/20240827124017.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="间隔的重复"><a href="#间隔的重复" class="headerlink" title="间隔的重复"></a>间隔的重复</h2><p>间隔在节奏中所起的作用，比人们能够相信的要大得多。<br>事实际上，在形成节奏方面，间隔和物体起着同样的作用。<br>如果物体有规律的重复出现而间隔不是这样，那就没有节奏了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123757.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>遇到这种情况时，要进一步留心寻找这些间隔之间的有没有某种有秩序的关系。<br>如果找不到直接的重复，那也许是以更复杂的形式出现的。<br>物体是简单地重复出现的，而间隔则是交替出现的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123807.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123823.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>另一种变化形式是间隔的宽度逐渐增加。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123831.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h2><p>景物的重复出现，不一定只包含一个形状或一个线条。<br>以某种方式结合在一起的成组的景物，或由几个成分组合起来的景物，也可以作为一个单元重复出现。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123839.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123900.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>各个赛艇的主帆、三角帆，桅杆和船体组成复合体，以相等的间隔重复出现。<br>无论当作一个复合体来看，还是当作一系列个体来看，这张照片中都不乏引人注意的节奏。<br>看看你周围的环境，注意由重复出现的东西所形成的节奏，这种例证在你的日常生活中简直比比皆是。<br>糊墙纸、室内装璜用的印花布和纺织品，帷幕、衣服、地毯的图案、暖气片的格子、电视机、空调机、压花模制品、一排排的书⋯⋯真是不胜枚举。</p>
<p>仔细琢磨下面的至理名言是很有意思的：<br>任何研究项目达到较高水平的时候，都会使我们在洞察力和知识水平方面更接近自然。<br>我们在艺术作品中发现的任何一种有条理、有秩序的东西，都会有一个完全相对应的东西早已存在于自然法则之中。</p>
<p>如果我们透过表面观察一下植物世界和动物世界的结构，我们会发现，大部分动植物是由符合基本模式的单元构成的。<br>物种之间的差异，只是由于其组成单元的形式和重复的性质有所不同而已。<br>没有两个物种是完全相同的，而物种的变异则是无限的。<br>请注意观察像种籽的荚、松果、花朵、植物各种器官的交接处、贝壳、海星、昆虫和蜂巢这一类东西。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123911.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123921.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>摄影家对大自然的奥秘和它所包含的条理性必须格外敏感。<br>如果亲身接触了生活的节奏，他的想象力就能得到解放，就能在庞杂的事物之中发现相似的条理性；<br>而对于常人来说，这些不过是一片混乱而已。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123931.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123942.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>像在音乐中一样，在视觉艺术中重复是节奏的最简单的形式。<br>因为艺术品的价值不在于它的复杂性，所以运用简单的或明显的节奏，并不等于把这幅作品降为低级品。<br>最终的评价标准要看节奏是否适当和效果如何。</p>
<h2 id="交替形成的节奏"><a href="#交替形成的节奏" class="headerlink" title="交替形成的节奏"></a>交替形成的节奏</h2><p>交替给节奏带来了多样性。<br>这种多样性存在于形状、线条、方向、位置、色调或质感的变化之中。<br>由于着重点略有变动，所<br>以这种变化有助于减少单调感。</p>
<p>交替形成的节奏，涉及两个独立的物体，它们交替出现。<br>它们可能是大小相同而形状不同：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123951.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>形状相同而大小不同：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829123958.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>或者是位置的交错：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124007.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>也可以由一个形状和一个线条构成：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124015.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>或者是一个复合体和一个简单物体交替出现：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124022.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124033.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124041.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>摄影家能够不断地发现并创作出不同的节奏来，特别是当他有机会把音响节奏和拍摄题材的视觉节奏结合起来的时候。<br>这种相互结合的机会在音乐、舞蹈和工业机械题材中是偶而可以碰到的。<br>只要摄影家有幸碰到表现这两种节奏的构图，他就有了创作优秀照片的绝好机会。</p>
<p>从某种意义上说，交替只是重复的另一种形式，因为交替出现的两个物体连同它们共同的间隔，可以被看做一个复合体。</p>
<h2 id="渐变形成的节奏"><a href="#渐变形成的节奏" class="headerlink" title="渐变形成的节奏"></a>渐变形成的节奏</h2><p>一种更有特点的节奏来自从始至终的渐变之中；物体的大小、形状、影调、方向甚至含义都在递增或递减，就像音乐里的渐强和渐弱那样。<br>它通过下列这些有生气的变化来吸引观众的注意力。</p>
<p>大小的变化：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124049.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>方向的变化：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124056.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>形状的变化：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124103.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>影调的变化：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124112.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>以及薄厚的变化：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124125.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124138.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124151.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-29/20240829124159.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="辐射形成的节奏"><a href="#辐射形成的节奏" class="headerlink" title="辐射形成的节奏"></a>辐射形成的节奏</h2><p>请看这幅城市街道的照片。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124354.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这样拍下来的照片中，透视体系的消灭点正好靠近画面中心。</p>
<p>请看除了竖线以外，实际上所有线条都是从这个消灭点——纽约泛美大楼前面的中央火车站辐射开来的，中央火车站变成了趣味中心。<br>无论你的注意力集中在画面的什么部位，总会被拉回到这个中心点上来。</p>
<p>这个中心点本身并不能使照片富有趣味，但它表现了线条辐射出发点和辐射线条所形成的节奏对整个画面的强大控制力。<br>日出日落的光芒、车轮的辐条、各类花朵、蜘蛛网和贝壳，都是这种节奏形式的明显例证。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124407.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124418.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124435.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>所表现的辐射感，不是由线条构成，而是由明暗构成。<br>它是用一个普通底片在印放过程中制作的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124446.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="中轴线上的辐射"><a href="#中轴线上的辐射" class="headerlink" title="中轴线上的辐射"></a>中轴线上的辐射</h2><p>在自然界，从一个中轴线向外辐射的形式很多。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124457.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>重复辐射：这种辐射在许多植物里能够找到。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124511.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>有时候，它们互相交替地改变着位置。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124522.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在树木的结构中，经常可以看到从一个中轴线上发出的辐射伴随着交替和渐变。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124530.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>中轴线结构具有一种和家族谱系类似的力量。<br>线条从轴线上射出，同时却仍然紧密地控制在轴线上。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124539.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>从中轴线上发出辐射的一个例子。横木、绳索、云梯都连在桅杆上。<br>当然还有其它许多节奏加强总的辐射结构。<br>由于透视的关系，桅杆显得逐渐变短变细。<br>横木越往上显得越短。<br>最后，成组的线条从桅杆各段的固定点上辐射开去。</p>
<h2 id="视觉的动感"><a href="#视觉的动感" class="headerlink" title="视觉的动感"></a>视觉的动感</h2><p>当节奏作为一个构图原则把相似的物体组织起来以达到统一协调的目的时，它就同时产生了一种运动或流动的特性。<br>通过节奏，观众的注意力从画面上的一个物体被引向另一个物体。<br>像音乐和舞蹈一样，它的运动节奏有的断断续续，有的流畅无阻；有时快，有时慢；有时连绵不断，有时嘎然休止。</p>
<p>所有前述节奏的运动形式，都是由物体和间隔组成相对固定的图案反复出现而产生的。<br>这些图案一般都是由线条和形状组成的。<br>运用色彩、质感，有时候运用色调使它们重复出现，能获得更微妙更动人的动感。<br>任何一个形象只要按照一定的秩序连续出现就会产生动感。<br>对于这种引起动感的结构，大部分观众可以感觉出来，但只有少数观众能够欣赏。</p>
<p>然而，还有一些运动形式，它和节奏有联系，但却不限于只是反复出现。<br>它的流动路线难以预料，结构并不规则，而是以一种比较自由的形式出现的。</p>
<p>生活中很少有静止的东西。<br>即使一个物体被固定在一个地方，那也可能仍是一个更大的动体的一部分。<br>如果它实际上并不运动，但视觉上可能会感到它在运动，像观看风景一样，因为人在运动，景物也会给人以运动的印象。<br>一个人坐在车上，透过车窗看风景，他会觉得是景物在动，而不是车子在动。</p>
<p>运动能对我们产生情绪上的反应。<br>有时候，我们对某种不熟悉的运动所产生的反映能强烈到使人严重发病的程度。<br>而对其它一些运动，则觉得舒服，满意或者感到富于刺激性。<br>在视觉上，有的云纹图案能使人头晕目眩。</p>
<p>有些色彩组合能使视网膜发生震颤——一种痛苦的反应，这使我们知道是眼睛的机能发生了障碍。</p>
<p>作为生活的反映，艺术不可避免地要表现运动。<br>如果题材里并不包含运动，那么作品结构中也要含蓄地表现动感。</p>
<h2 id="含蓄的运动"><a href="#含蓄的运动" class="headerlink" title="含蓄的运动"></a>含蓄的运动</h2><p>电影特有的本领是摄取和表现实际运动。在拍电影时，有无限的运动形式，可供摄影家选用。<br>相机摄影无法记录实际的运动，但它有着表现含蓄运动的巨大能力。<br>它的办法是运用一种带方向性的途径，让观众的眼睛和注意力沿着这个途径而运动。</p>
<p>一幅静止的照片表现运动的最明显的办法是把连续不断的实际运动分阶段照在一张照片上，其中每一阶段代表整个运动的一个静止的片断，我们大家都熟悉用频闪灯光拍的照片，像挥动高尔夫球和棒球棍的瞬间，人们登上阶梯的动作等，都表现了运动。<br>观众的目光从运动的一个阶段移向另一个阶段，便得到一种实际运动相同的感受。<br>因为观众能从静止的照片中得到参与实际运动，至少像是在观看实际运动那样的感受。</p>
<p>既然同一影象逐渐变化能够产生运动效果，那么，从这样的推理出发，由渐变形成的节奏就能使眼晴和头脑产生同样的反应。<br>在由重复和交替形成的节奏中，运动感不那么明显。<br>但对它们有一种连续不断的感觉，这就是一种稍有不同的运动感。<br>相似的物体和相似的间隔形成了一种连续性，使我们的眼晴和头脑一段一段地看下去，紧追不舍。</p>
<p>所以，运动就成了控制注意力，使它从一个物体转向另一物体的重要因素。<br>一个箭头或一个有指向的手指能把注意力引向指着的方向。<br>同样，任何运动，像人的散步，动物的奔跑，车轮的转动也能使注意力集中在运动的方向上。<br>眼睛总是倾向于追着人或物运动的方向观察的，甚至追着它们面前的方向去看。</p>
<p>任何具有强烈方向感的形状都能把人的注意力引向它所指着的方向，这是很难抗拒的。</p>
<h2 id="随意线条中的节奏和动感"><a href="#随意线条中的节奏和动感" class="headerlink" title="随意线条中的节奏和动感"></a>随意线条中的节奏和动感</h2><p>仔细观察乱写乱画出来的东西，能学到很多关于节奏的知识。</p>
<p>下面这些线条是人们心不在焉时下意识地涂沫出来的。</p>
<p>有些完全没有条理，说明缺乏控制：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124549.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>有些是摸仿流行的绘画形式的：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124558.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>还有一些是有严格控制的，完全是早年学画时用来造型的那些线条：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124606.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>对优美流畅的运动有所感受的那些人或参加过这种运动的人，随意画出来的线条可能是格外流畅的。<br>这样的人经常流露出他们内心对类似舞蹈节奏那样的情感反应。<br>这种情况往往出现在舞蹈家、溜冰者，有些演员和音乐家当中。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124615.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>有时候，它是人们内心活动途径或姿态的表现形式；有时候是内心体验到的节奏活动的视觉表现形式。<br>当我们看到这些流畅的线条时，目光就要被其中的运动路线所吸引，从而产生情感反应。<br>我们之所以情不自禁地要对它作出反应，是由于它们那样的千姿百态，深深地触动了我们的感情。<br>节奏能被感觉到，是因为这种线条以不同的方式奇妙地反复着，波浪式地推进着，并且改变着它的方向。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124625.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>改变着它的速度：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124632.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>改变着它的式样：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124640.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>随便把大约两码长的一根绳子或一根线抛在桌面上，看看它所形成的线条。<br>连续这样做几次，观察它形成的曲线和背景空间的形状。<br>不久，你就会被你所看到的节奏所吸引。而且从此以后，当你在其它题材中看到随意线条和形状时，你就能比较敏感地发现其中的节奏。<br>纱线、绳索，铁丝、电线都具有线条特征和质感上的各种变化。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124652.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>把两股或三股上述物品拧成索状，使每股的粗细、色调和质地各不相同，则可获得动人的类似音乐对位法的动感效果。<br>把一块丝绸织物抛在桌子上，用斜射的灯光照射，使皱褶投下影子。<br>再注意弯弯曲曲的皱褶怎样构成引人入胜的节奏。</p>
<p>运动的路线不一定要多么复杂。<br>图中的篮子，无论是图形本身还是背景空间的形状都很动人。<br>更重要的是，突出了由轮廓构成的流畅曲线的节奏。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124700.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>请再看，从骨架的中心向外辐射的线条以及在骨架上编出的同心圆又构成了补充节奏。</p>
<h2 id="随意形状中的节奏和动感"><a href="#随意形状中的节奏和动感" class="headerlink" title="随意形状中的节奏和动感"></a>随意形状中的节奏和动感</h2><p>在图中，我们看到通过形状的逐渐变化怎样产生了具有节奏性的动感。<br>我们的注意力从一个形状转移到下一个形状。<br>通过连续不断的形状之间的相似而保持了统一性。<br>然而，每个形状又有足够的差异，使人有所期望，才能把这些形状一个接一个地看下去。</p>
<p>在自然环境中，要找到这样均匀渐变的形状是不容易的。<br>在比较一致的群体中，每一个物体都是显著不同的。<br>然而把人的视线沿着一条有动感的路线引导下去的那种感觉还是有的。</p>
<p>物体的造型特点和它的总的倾向，诱使我们去看它指出的另一个物体。<br>另一个物体又动员我们去看再下一个。<br>虽然题材中并没有实际的运动，但是，人们会感到有一种力量推动着他们去追随每一个物体的运动方向。</p>
<p>这种现象在图中很明显。不论我们的目光第一次落在照片的什么部位，它都会被拉到邻近的一个形象上去，然后又拉回来。<br>特别敏感的人会有一种波浪式的起伏的运动感，好象自己在船上扬帆漂游一样。<br>因为现面中的形象具有方向相反的特点，我们的注意点便摆来摆去，直到把画面浏览几遍为止。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-30/20240830124717.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在自然界，你不难发现许多题材中都有随意线条和形状，其中都包含着潜在的运动。</p>
<p>建议你们去看看：</p>
<blockquote>
<p>飘动的横幅、旗帜、飘带、三角旗；<br>舞蹈家——独舞和群舞；<br>水浪，云彩和飞机拖着的雾化尾巴；<br>弯曲的道路，特别是立体交叉枢纽；<br>耕出犁沟的农田、土层；<br>岩层、石头上的裂缝；<br>乐器。</p>
</blockquote>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 设计原理</title>
    <url>/2024/08/08/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="构图手段"><a href="#构图手段" class="headerlink" title="构图手段"></a>构图手段</h2><p>有时候，视觉要素（我们刚刚讨论过）和构图原理（我们将在以后各章里讨论）的作用容易被混淆。<br>视觉要素就是形状、线条、明暗、质感和立体感；<br>它们可以被看做是照片的组成部分，正像我们把构成主题的景物看成是照片的组成部分一样。<br>构图原理就是对比、节奏、优势、平衡和统一；<br>它们是艺术家把各个分散的部分组成一幅完整照片时所采用方法。</p>
<p>历史上，大多数艺术家使用这些术语来讨论和分析艺术作品，进行艺术教育。<br>有些人则有意避免在艺术的各个部门里使用这些词汇，然而他们虽然不用这些惯用术语，而是使用略有不同的什么说法，但它们的目的还是一样的。<br>另外一些人，给同一个东西换上不同的名字，例如有时候把形状叫实体，有时候又把立体物叫实体。<br>有时候把明暗叫色调，把节奏叫动感。<br>还有一些人认为视觉要素中应该包括空间和运动，构图原理中应该包括比例、变化和尺度。</p>
<p>这些术语除了起参考作用外，本身并不重要，要重的是它们所表述的特性。<br>也许有一天，新的、更精确的术语能被创造出来，并且能被普遍接受。<br>在这以前，艺术家在自己的创作和讨论中，仍有自由使用任何他认为合适的术语去称呼那些要素和原理。<br>不管使用什么术语，如果没有和形状、线条、明暗、质感与立体感相对应的名词，就无法想象这些视觉概念为何物。</p>
<p>从某种意义上说，视觉要素（不是指术语）是传达视觉信息的语汇，正像词是传达语言信息的语汇一样。<br>在特定环境下，语言交流中的一个词，通过它的声音或含义就能圆满地传达一个概念，不需要更多的词。<br>同样，只用一个形状、线条或立体物也能表示一个视觉概念。<br>有时候，这种极其简练的表现手法不仅是可能的，而且是非常必要的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-08/20240808122639.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在语言交流中，为了拓宽和加深内容，多数情况下还需要使用更多的词。<br>这时，这些词就必须按照语言规范加以组织，才能保证既不违背也不歪曲作者想要表达的原意。<br>这样一来，句子和段落的结构以及其它语法原则就成为必不可少的了；<br>当然他们本身并不是目的，而是促使行文通顺的前提。</p>
<p>对视觉要素来说，情况大体相同。<br>形状、线条、质感和立体感的配合使用，能够起到互相加强效果的作用。<br>如果它们不是按照某一前提加以组织，艺术家的意图就无法表达。<br>对比、节奏、优势、平衡和统一这些原理，是艺术家用来把所有设计要素结成一个和谐的整体的工作方法。<br>这整个工作过程——选择能够表现摄影家意图的视觉要素，根据各项原理，加以适当安排——就是照片的构图。</p>
<h2 id="构图方法"><a href="#构图方法" class="headerlink" title="构图方法"></a>构图方法</h2><p>“构图”和“设计”可以通用，它们的含义是一样的。<br>在某些情况下，设计被理解为装饰（即创作单独使用或联合使用的图案），或对某一结构外表的修饰。<br>但设计的更精确的概念是它的原始含义——构思，即艺术家为了明确而动人地表达自己的思想而适当安排各种视觉要素的那种构思。<br>即艺术家为了明确而动人地表达自己的思想而适当安排各种视觉要素的那种构思。</p>
<p>构图不是苦思冥想之后就能轻易编排成功的一道工序。<br>构图不是给一个有毛病的照片开列的处方。<br>构图也不是一个用来建立质量标准的尺度。<br>摄影家不能认为视觉概念是一回事，而构图是另外一回事。<br>它们二者是完全互相依存，彼此不能分开的。</p>
<p>由于构图原理被笼罩上一层玄虚的气氛，构图过程被说得比它原来的含义更为复杂。<br>事实上，它本来的含义只是使用视觉要素的一些方法，目的是吸引注意力并抓住注意力，使得艺术家对现实的见解和看法作为一种思想向观众表达清楚。<br>如果必须作出选择的话，毫无疑问，摄影者的思想及其表现方式要比那些原理更为重要。</p>
<p>构图方法本身是很有意味的。<br>艺术家不仅要有一个意图，而且要把这个意图用独特的、有趣的方式表现出来。过去，题材完全压倒了画面的组织结构。<br>今天，画面的组织结构本身已经变得十分重要，它可以单独成为照片的基本趣味所在。</p>
<p>在一幅关于某一题材的照片里，摄影家总是把你的注意力引向某一形象。<br>那里因为这个形象曾经使他激动过。<br>这种激动，部分来自题材固有的内容和趣味，部分由于摄影家已发现了特别动人的结合在一起的线条、形状、色调、质感和立体感。<br>如果画面的结构不美，那照片就不会受人注意，或者说摄影家的感受就不会得到表现。<br>通过对比，不同的视觉要素要显示得更加清楚；<br>通过有节奏的运动，必须使观众的注意力环绕照片而移动；<br>应该给人一种单一的统一的印象，免得造成概念上混乱；<br>画面中只能有一个形象占据主导地位，否则，就会使人迷惑不解。</p>
<p>构图原理不是随心所欲地凭空设想出来的。<br>它起源于人们对有条理的安排所作的反应。<br>它来自几个世纪以来艺术家对他们的追随者的教导，来自对几千年的艺术名作的研究。<br>无论早期的或现代的艺术家，都把它作为一种手段，用来给作品创造出趣味，保持趣味。<br>毫无疑问，它并不是狭隘刻板的、限制艺术家创作的清规戒律。<br>运用构图原理，能把具有不同大小和不同吸引力的形状、不同的色调和质感以及形形色色的拍摄对象联系起来，使中心思想占据主导地位。</p>
<p>如果没有这些措施，照片中具有不同吸引力的各种形象都要求受到注意，其结果只会导致混乱。</p>
<p>为了集中研究而突出一个单一的要素，是不得已而为之的。</p>
<p>在下面这些图例中，如果只随便浏览一下，视觉要素之间的区别是不容易看得出来的。<br>一根线条，要粗重到什么程度才被认为是一个形状呢？</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-08/20240808122707.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>多少线条联结在一起就失去了线的特性，而出现了质感和色调呢？</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-08/20240808122718.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>当一条线自行蜿蜒交叉时，它还是一条线吗？或者已经变成一个形状了呢？</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-08/20240808122727.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>一个形状需要多少层次才能转化为一个立体物呢？</p>
<h2 id="个别原理之间的各个有关方面"><a href="#个别原理之间的各个有关方面" class="headerlink" title="个别原理之间的各个有关方面"></a>个别原理之间的各个有关方面</h2><p>类似的问题存在于设计原理的研究中。<br>当我们集中注意一个构图原理，研究它的态势的时候，这个原理似乎是一个独立而明确的东西。<br>事实上，构图中所有个别原理都是统一地、互相联系而起作用的，因而，构图上每一个别原理都可能具有几种身分。<br>构图包含着复杂的相互关系。<br>由于这些关系结成一个严密的整体，很可能给人一种貌似简单的假象。</p>
<p>摄影家有权选择一个原理作为照片的主要趣味之所在。<br>例如，他可以选择一组线条、形状或立体物，利用它们相互关系中的节奏感或相似之处，去吸引观众的视线。<br>或者他把注意力集中在两根线上，通过生动的对比，强调它们的不同。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-08/20240808122751.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-08/20240808122808.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在构图时，把各个部分组成一个整体所需要的时间，因摄影家、题材和可以控制的条件不同而有所不同。<br>有时候，瞬间出现的题材迫使你迅速作出判断和反应。<br>通过认识和实践所养成的高度敏感性，使摄影家能够在觉察的瞬间完成拍摄。<br>在另外一些场合，也许要用几小时进行调整，等待光线有利时，才能曝光。</p>
<h2 id="先入之见的构图模式"><a href="#先入之见的构图模式" class="headerlink" title="先入之见的构图模式"></a>先入之见的构图模式</h2><p>像各个活动领域一样，在构图学方面的著作家和教师们曾经系统地阐述过构图的程序，指望艺术家们能够有意识地把它用到作品结构中和作品分析中去。<br>他们希望通过具体的指导，收到具体的效果。</p>
<p>对发现这种程序的艺术家来说，这种程序可能是很有用的。<br>但是要把这种个人的工作方法强加于别人，就不妥当了。<br>如饥似渴地探求知识的人可能被这些圆满而有条理的方法所打动，但他最后必然会认识到，这样的方法把思维过程限制在事先想好的别人模式里去了。<br>这种方法的艺术效果比在事先画好的草图里“对号着色”好不了多少。</p>
<p>初学者往往不是专心致志地亲自处理视觉刺激源，而是寻求适合模特儿的现成样本，用来死记硬背。<br>往往不是用惊奇感和好奇心（这正是艺术家对环境的反应）在平凡的事物中进行探索，而是被引导去从壮丽的自然现象中和古怪的人为事件中，寻找可以模仿的题材。</p>
<p>根据一般经验，视觉刺激源是无限的。<br>人们需要透过外表去仔细研究，才能认识主题，发现各别部分的视觉美点，以及这一部分对另一部分的影响。</p>
<p>当你碰到一个引你注意的题材时，要摆脱对于你所见过的那些成功之作的回忆。<br>靠你自己的观察力研究选定的范围，直到你对那个值得认真观察的部分作出反应。<br>不要企图使主题适应你心中已有的某一概念，应当让主题向你展示它的独特之处。<br>最重要的是集中注意抽象成分之间的联系，设法把它们从周围空间中突出起来。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-08/20240808122830.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="图片分析"><a href="#图片分析" class="headerlink" title="图片分析"></a>图片分析</h2><p>另外，在图片结构的研究中，过于复杂的分析，也是没有益处的。<br>分析构图的人，有时候用文字，大多数情况是用指示方向的线条和勾出来的平面，来解释他个人对某一张照片的感受。<br>他以为其他人会用同样的方式理解这张照片。</p>
<p>正像我们每个人对大自然的特征和气氛反应不同一样，对于表现这些特征的照片的感受也是各不相同的。<br>虽然艺术家在一张照片里所用的表现方法是他自己的，观众的有选择能力的眼光，仍然要作出自己的判断。<br>这一点可以从下列事实得到证明：<br>许多分析家都用线条分析的方法分析同一张照片，但得出的模式和结论却是不同的。</p>
<p>这种用于分析的线条是一种干扰因素，它扰乱了对照片进行正常观察。<br>如果一张照片不能以艺术家所赋予的那种方式受到鉴赏，再多的线条分析和口头解释也无济于事。<br>如果照片的主人喜欢用乱涂乱画的线条分析法去欣赏自己的照片，那是他个人的权利。</p>
<p>但是，若把个人的偏爱强加于人，而且便说这是传授知识或进行教育，这无异于亵渎教育工作。</p>
<h2 id="心理学的探讨"><a href="#心理学的探讨" class="headerlink" title="心理学的探讨"></a>心理学的探讨</h2><p>关于感觉过程中心理因素的作用，有许多值得讲的。<br>事实上，每个视觉结构的基本原理，都能被科学地解释。<br>主要由完形心理学家所创造的那些概念是用一些生僻的术语表达的，因此，需要仔细研究才能理解。</p>
<p>的确，艺术家需要懂得自己的反应，也需要懂得别人会怎样反应。<br>但深奥的科学研究，特别在学习构图的初期阶段，是容易把人弄糊涂的。<br>它使艺术家过于关心推理，而转移了对于创作的注意；<br>不是认真地进行创作，而是过多地听从他人的见解。</p>
<p>有高度修养的艺术家，对于自己的目的和方法深信不疑。<br>他们可以一边进行深入的心理学的哲学的探讨，一边通过积累经验来提高自己。<br>而那些不太自信的人会发现，这样有意识地运用构图知识，会限制凭直觉办事的那股冲劲。</p>
<p>完全被科学解释湮没了的构图原理，就变成了僵硬武断的规则，只能束缚而不促进创造性。<br>艺术需要一种魅力，这种魅力是在不可预见和无法解释之中形成的。<br>理性是科学的支柱，但无论如何它不是艺术的必要组成部分。<br>艺术是表现思想感情的，甚至不必要求它符合逻辑。</p>
<p>艺术属于人文主义范畴。<br>每个艺术家应当立足于个人的直观判断，而不应依赖别人的感受。<br>无论是有意运用别人的知识，还是作出心理学的假设，都不应影响美学上的抉择。<br>说到底，每个艺术家都是按照他认为的正确的方法行事的。</p>
<p>视觉认识能力，不仅包括对视觉要素的认识能力，也包括对视觉要素的组织能力，都是可以通过指导得到提高的。</p>
<p>正是为了这个目的，我们将在以下各章中继续讨论构图原理。</p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 质感</title>
    <url>/2024/08/02/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E8%B4%A8%E6%84%9F/</url>
    <content><![CDATA[<blockquote>
<p>质地存于万物之中，它正象万物本身的存在一样地普遍。大凡存在的东西都有各自的质地：光滑的、粗糙的、闪光的、波纹的、崎岖不平的、干枯的、滑溜的、含砂的、绒毛状的。起皱纹的、木纹状的或别的样子的，数不胜数。</p>
</blockquote>
<h2 id="触觉鉴别"><a href="#触觉鉴别" class="headerlink" title="触觉鉴别"></a>触觉鉴别</h2><p>质地的概念是和触觉有关的，和皮肤表面接触时的一种感受有关。<br>触摸物体表面或在其上滑动，能使我们产生另一种鉴别作用，它和视觉、味觉、嗅觉、听觉相辅相成。<br>一种完全的鉴别能力往往需要依靠两种或更多的感觉器官共同行动才能形成。</p>
<p>例如，一块抛光了的杂色大理石，看起来不平，但摸起来很滑；<br>一匹驯养的马，看起来皮毛光滑，但摸起来又粗又硬；<br>塔夫绸的窸窣声加上其它因素才形成它干净利落的感觉。</p>
<p>有时，触觉能识别一种材料的真实性质，而眼睛往往有错觉。<br>石膏和木头常常可以漆得很象大理石。<br>仿造的技巧可以高明得以假乱真，可是，用手一模，马上真相毕露。<br>考察一块料并评价它的质量就要依靠触觉。</p>
<p>通过长期的体验，我们培养了一种鉴别质地的记忆能力，这和我们的视觉、味觉、嗅觉和听觉的记忆能力十分相似。<br>闭上眼睛，在既没有味道也没有声音的情况下，我们甚至也能摸得出缎子、羊毛、砂纸、玻璃、金属、混凝土和纸张。<br>如果给婴儿换走一块他所熟悉的毯子，尽管颜色和重量都一样，但就是因为质地不同，婴儿也会觉得不舒服。</p>
<h2 id="触摸欲望"><a href="#触摸欲望" class="headerlink" title="触摸欲望"></a>触摸欲望</h2><p>为了自我满足，为了感官上的愉快，或者为了辅助视觉，人们往往有一种内在的，要求触摸物体的强烈欲望和一种去体验质地的好奇心。<br>在我们的幼年时代，这种欲望是不受禁令约束的，但当我们成年后，社会条件教导我们要约束自己的本能。<br>虽然人体的各种倾向性受到了遏制，但好奇心和欲望仍然是强烈的。<br>人们需要满足自己的这种触摸要求。</p>
<p>面对娇嫩的皮肤、闪光的缎子、高级的皮毛或成把的鹅卵石，很少人能自我克制，总想去抚摸，把玩。<br>躺在草上只欣赏泥土的芳香和宁静的色调是不够的，我们还要情不自禁地去抚弄叶片并试验它们的耐力。<br>那些情趣粗犷的人喜欢穿斜纹精布、粗花呢和灯心绒的衣服，因为它们粗糙的手感和不规则外观体现了一种独特的心理状态。</p>
<h2 id="质地激起的情感反应"><a href="#质地激起的情感反应" class="headerlink" title="质地激起的情感反应"></a>质地激起的情感反应</h2><p>质地对我们能产生强烈的影响，不论这种影响是积极的还是消极的，都不容忽视。<br>我们对物体表面的特征有时喜欢，有时反感，有时有其它的反应。<br>触摸反应和情感的联系如此密切，以致我们会对某些质地感到满意，而对另外一些质地产生反感。质地能使人兴奋和冲动。<br>有些人看见青蛙、蛇或者腐烂的水果会产生一种无法控制的厌恶感受，而抚弄新鲜的玫瑰花瓣能使人镇静和宽慰。<br>虽然对条件的联想也可以引起这样的反应，但这是另外一个问题。<br>事实是，这种反应很常见，这种反应很常见，值得我们密切注意。</p>
<h2 id="触觉和视觉的相互关系"><a href="#触觉和视觉的相互关系" class="headerlink" title="触觉和视觉的相互关系"></a>触觉和视觉的相互关系</h2><p>一切感觉相互之间都有密切联系。<br>看到酸黄瓜那湿漉漉、滑溜溜的外表，会刺激味蕾而使人垂涎三尺；<br>看见切开的洋葱就想起它那辛辣催泪的味道。<br>用不着举起一块石头去估量它的重量，一眼就能“看出”它是个憨然重物。<br>只消看到海滩的细砂就会联想到漂浮在手指和脚趾之间的晶粒。<br>看到锋利多齿的石头就足以使脚底的肌内收缩，这是因为想起了赤祼的双脚曾被这种刺人的石头边缘触痛过。<br>看到贝壳会唤起人们对它的外形和质地的感觉。<br>人体的大部分感受都是通过各别的感觉在体内的传递和交融而形成的。</p>
<p>物体表面的差异尽管纯粹是视觉上的，而且人体也没有机会去接触这个表面，但是这种表面质地的外观本身就足以给人脑传送一个刺激，从而使人得到一种触觉反应。<br>触感的产生并不取决于手指是否接触物体。<br>虽然我们并没有实际接触物体表面，但对于它的特质仍会产生一种幻觉。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-02/20240802123013.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="视觉质感"><a href="#视觉质感" class="headerlink" title="视觉质感"></a>视觉质感</h2><p>在视觉可辨范围内的任何明暗变化都能产生出一种视觉质感。<br>强光、层次、反射光和阴影——所有这一切都是和质感有关的因素。<br>即使一张照片上只是万里晴空或一汪平湖，也都会有表面软硬感觉的性质。<br>光线因光源不同或它所通过的环境性质不同而有所差异，特别敏感的人善于区别不同光线所形成的质地特性。<br>水也能产生一种视觉质感，它的质感区域相当宽广。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-02/20240802123024.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-02/20240802123044.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>印好的报纸除了具有作为新闻纸本身的特点以外，也可以体现不同的质感。<br>字号、字型、铅条、油墨的浓度、栏目的宽度以及段落的长度等，对于光线的吸引和反射都有显著的影响。<br>同一份报纸的每一单页，由于复制、插图和间隔的密度和性质不同而带来各具特色的质感。</p>
<p>阳光通过网眼窗帘，将窗帘的图案投射到纸上，这样形成的光亮部分和阴影部分，完全改变了原来的视觉质感。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-02/20240802123102.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>用一种工具在质感不同的表面上，或者不同的工具在质感相同的表上上画出一条简单的线条，让它们的长度和方向完全一致，结果却显著不同。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-02/20240802123120.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>仅仅确定影调的明暗值是不够的，质感是构成这个数值的组成部分，它和影调本身同等重要。<br>下面各图的形状，大小和影调完全一样，只是质地不同，所以无论在视觉判断上，还是在触觉反应上，它们所形成的形象就显然不同。</p>
<p>由于质地对视觉形象和感情状态的影响十分强烈，所以摄影家和其它从事视觉艺术的艺术家一样，对于它的效果不能漠然处之。<br>他们对于触觉之间的心理关系必须特别敏感。<br>对于各种材料的感觉及其本质必须有深刻的了解，才能有效地表现它美的素质。</p>
<p>对于那些含有视觉概念和视觉联想作用的要素，艺术家们的确有着高于常人的认识能力，但决不能只凭天赋。<br>要不断地努力提高敏感性，增长才干，观察生活，才能创作出意味深长的，足以鼓舞斗志、激发情感的作品。</p>
<p>不需要通过题材的其它作用，质地本身就能产生一种揭示内在诗意的暗示力。<br>摄影家只要能表现出对有形物体的丰富的感受，也就能再现它们的赏心悦目的激情和美感。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-02/20240802123146.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="工具和质地"><a href="#工具和质地" class="headerlink" title="工具和质地"></a>工具和质地</h2><p>下面是一系列的练习，可以增长你对质地的认识能力和欣赏能力。</p>
<p>用钢笔或铅笔画几个正方形，每边之长大约一英寸。<br>在头两个正方形中画满圆圈，使其大小和密度大致相同，但不要排列成行。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094334.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>然后在第二个正方形的圆圈之间画上小点。观察它的质感有什么不同之外。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094352.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在这个阶段研究质地，不要和自然存在的任何物体联系起来。<br>我们目的只是培养一种敏感，去体验各种质地的有趣变化。</p>
<p>哪怕一点点变化都会产生不同的效果。<br>现在我们不要随意乱画，要使圆圈横竖成行。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094402.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>使圆圈交错成行，质地的变化又自不同。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094415.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>再用椭圆代替圆，在一个正方形中随意画满椭圆，而在另一个正方形中则排列整齐。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094429.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>下面试验用各种不同的形状及其组合，构成各种各样的质地。</p>
<p>用线条：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094437.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>用小点：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094445.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>随意勾画：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094453.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>使用不同的工具，蘸上墨水进行试验，看看结果如何。</p>
<p>用刷子：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094505.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>用枝条：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094514.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>用小链条：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094523.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>或用羽毛：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-03/20240803094531.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>你所创造的任何质地，无论看来多么稀奇古怪，都不要轻视。<br>说不定在什么时候你会在自界里发现和它一模一样的东西。</p>
<h2 id="自然界的质地"><a href="#自然界的质地" class="headerlink" title="自然界的质地"></a>自然界的质地</h2><p>有了创造性意识，就能在平凡的地方发现重要的东西。<br>一个人必须十分留意周围环境中确实存在着的无穷无尽的质地。<br>在你实际拍摄普通的质地之前，如果先做一些简单的练习，以便观察、识别和实际接接触各种质地。<br>这种做法是非常值得和大有裨益的。<br>此后，你才有可能拍出大量的、生动反映质感的作品来。</p>
<p>首先观察你自己房间里各种东西的质地，细看木制家具，观察这种木头和那种木头在纹理结构上有什么不同。<br>在有些胡桃木红木和桦木家具上，极为精细的一层罩光漆能使外表呈半透明状，而且一直深入到木头的深处。<br>展现出一幅幅犹如在表层下浮动的木纹图案。</p>
<p>在你所研究的其它材料中，有各种各样的质地：<br>崎岖不平的、粒状的、平滑的、粉状的、砂砾般的、片状的、布满灰尘的、砾石铺筑的、易碎的、绒毛状的或是毛发状的。<br>它们都有哪些特性呢？<br>通过实际触摸，体会一下下列物体之间的区别：<br>布料与皮革、木头与纸张、黄铜和黑铁、涂漆的表面和抛光的表面。<br>再用视觉帮助验证一下你的触觉，不需要做什么笔头记录，头脑中的印象是最重要的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-04/20240804091413.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>然后，集中精力去体会某一类东西的特殊质地，以纸张为例。<br>在你家里收集到多少种质地不同的纸张？<br>开始试验新闻纸、笔记本纸、证券纸、带封面的杂志纸、蜡纸、冷藏纸、礼品包装纸、货币纸、相纸、吸墨水纸、索引卡片纸、作文纸、照片衬纸、书皮纸、糖果包装纸、包裹标签纸、糊墙纸和图画纸等等。<br>用手指抚模它们的表面，比较它们的特征。<br>用一个25瓦的反光灯照明，观察这些特征和投光方向的关系。<br>观察每一种纸的视觉特征，是半透明还是不透明，粗糙或光滑，其独有的特征是什么。<br>对每一种纸用什么角度照明才能体现你的感受，才能最好地表现纸的性质。</p>
<p>把各种纸揉皱，观察每种纸的褶痕和褶皱的凹处，其结果也是质地的一种表现形式。</p>
<p>选出各种布料——女服、外套、套服、运动衫、衬衫，短外套，帷幕、桌面、毛巾、围巾和窗帘，对它们的南地进行比较。<br>把它们挂起来或折皱，用一两盏灯闪照，研究不同表面的质地，皱褶的特性以及反光能力。</p>
<p>像大多数培养敏感性的练习一样，对质地的这些探究似乎显得愚蠢和过分简单。<br>但是，一旦你这样做了，<br>你就会发现自己迷上了各种质地具有的魅力，并随着理解力和鉴赏力的增长，<br>你那好奇心和调查研究的愿望也将进一步增长，<br>质感的重要意义将越来越清楚地展现在你的面前，<br>你也就会在那些通常易被忽视的方面去进行探索和钻研。</p>
<p>虽然，单独一项质地，没有其它有关因素的衬托，往往也能具备足够的力量创作出一幅有趣的照片，<br>但更经常的情况是形状、线条、明暗等多种品质增加了美的情趣，这种情趣又有力地强化了主体的质地。</p>
<p>选几块织物，要使它们的质地在镶配之后显得很美观，把它们摆在一起，注意突出它们的表面质地。<br>布光照明时，要强调触感的不同。然后拍几张负片。<br>研究印出来的照片，确定你的成功之处，以及为达到预期目的还需要改进的地方。<br>如果你偶然获得意外的成功，就要设法确定如何才能有意识地获得同样的成果。</p>
<p>现在，你已经训练有素，<br>可以到外面去探索那遍地都是的各种质地了，<br>各种质地充满了我们的日常生活，<br>如果人们不是有意地努力发掘它们，<br>它们就会隐没在一片模糊之中以致视而不见。</p>
<p>试比较建筑物的墙壁和屋顶构件的质地，如砖、石、灰墁、木头、瓦片、盖屋板、混凝土、建筑用玻璃、金属，以及石板等。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-04/20240804091440.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>请观察在同一个建筑上的那些吸光的质地和反光的质地的相互作用。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-04/20240804091458.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>人工修筑的马路、人行道和天花板富有各种有趣的表面，从最粗糙到不大粗糙，从不规则到非常规则。<br>例如：</p>
<blockquote>
<p>踏成的路、石板、卵石、有各种骨料的混凝土、陶瓷排水管、水磨石、碎石路面、沥青路面、地板和地毯。</p>
</blockquote>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-04/20240804091519.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>现在，你来观察迷人的自然地面——砂、卵石、树叶、石子、草、苔藓、泥土、干湿土壤、雪——这一切混合在一起，形成无数的质地。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-04/20240804091801.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>有些不习惯于细致观察的人会认为这些树皮不过都是一般的粗糙表层，相互之间没有什么区别。<br>而有辨别能力的人则能识别它们那些具有美学和植物学情趣的差异。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-04/20240804091941.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>同种树叶正面和背面的质地不同，不同树种的树叶不仅形状不同，质地也各异。<br>如果我们走到相当远的地方去观察一簇树叶，还能看出群体物质之间一种新的质地关系，这又和单个叶片的质地大不一样。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-04/20240804092008.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>从远处看可以看到树的全貌，而个别的叶片，甚至一簇簇树叶的质地就不是趣味中心了。<br>一簇簇树叶的群体现在是和形状、线条、立体感和明暗等方面密切交织在一起而呈现出另一种质地，这种质地和同一树种的其它树木的质地是相类似的。<br>再对比另一种树种，则两种树的质地之间存在着鲜明的对比。<br>叶片的大小、叶丛的疏密、花朵、果实、错落相间的方式、以及光的折射率等，都对质地的感受有着影响。</p>
<p>无叶之树也具有一种质感。<br>请注意观察这种树的枝条构成的网状结构。</p>
<p>你继续研究下去，密切注视风化对下列物体的影响；<br>老树桩、落地枯枝、中空树木、树上和石头上的苔藓、地衣和真菌。<br>风化作用使人造物体受到损失，但实际上，它却给各种质地再添新状，这时摄影是一大乐事。<br>注意观察生锈的金属、剥落的油漆、变质的木板、腐朽的建筑、坍塌的船坞、倾倒的篱笆、遗弃的小船及撕破的广告画等。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-04/20240804092031.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>我们还要经常注意这一点：</p>
<blockquote>
<p>我们看到的各种质地并不都是亲身接触过的，因为有些是大型的群体，我们无法去触摸它们。</p>
</blockquote>
<p>这包括大股的人群、遍地的鲜花、成堆的家具、大片屋宇、整群绵羊、墙上和广场上的大型雕刻、山坡上的茂密树林、水面上的闪光和阴影以及云层等。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-04/20240804092133.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-04/20240804092146.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>自然存在的或人工制造的任何一种群体物质都是质感题材的最佳源泉。</p>
<p>除了偶然的情况，每一幅照片都回荡着摄影家的思想和感情。如果你在观察中对自己的观察对象产生数种感受，你的照片一定能反映出多种激情，这会使你的照片更有观赏价值。<br>因为质地常常是和触摸、声音和味道密切相关的，所以你把各种感觉综合得越多，你的创作想象力就越富于个人风格，你所反映的意图就越接近客观事物的真实性质。</p>
<p>不要只满足于客地再现主题，而要想方设法用夸张手法去反映你所认为最有意义的质地或其它方面的特征。</p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 直方图</title>
    <url>/2024/07/20/%E6%91%84%E5%BD%B1-%E7%9B%B4%E6%96%B9%E5%9B%BE/</url>
    <content><![CDATA[<p>摄影中的直方图是一种图形表示，用于展示图像的色调分布，特别是图像的亮度级别。直方图可以帮助摄影师和图像编辑者评估图像的曝光情况，确保高光和阴影部分的细节得到恰当的呈现。</p>
<p>简单来说，直方图就是科学的数据统计图，可以很直观的反映出片子的影调情况。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072000.jpg"
                      alt="-"
                ><figcaption>-</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072101.jpg"
                      alt="-"
                ><figcaption>-</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072101.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<blockquote>
<p>透过直方图看问题</p>
<p>直方图可以很方便的看出一张片子影调和色调上存在的问题，就类似于患者在医院拍的CT片，后期工作则通过直方图找到片子问题所在，对症下药，那么都有哪些常见的症状呢？</p>
</blockquote>
<h2 id="什么是直方图"><a href="#什么是直方图" class="headerlink" title="什么是直方图"></a>什么是直方图</h2><p>直方图表示的是图像的明暗程度。x轴从左到右依次代表从暗到亮，最左边为最暗的纯黑色，最右边为最亮的纯白色。Y轴则代表像素数量。</p>
<p>这是一张图片，有从黑到白四种不同亮度的颜色</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072102.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>我们依次将黑色标为1，深灰色标为2，浅灰色标为3，白色标为4，如下图：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072102.jpg"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>而这张图片的直方图，长这样：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072103.jpg"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这个直方图分为4列，按照上面所说的，X轴从左到右代表从暗到明。在上面的直方图中，最左列代表的是纯黑色的1号，第二列代表的是深灰色的2号，第三列代表的是浅灰色的3号，而最右列代表的是纯白色的4号。</p>
<p>再来看Y轴，Y轴代表的是像素数量。我们可以看到，1号纯黑一共有7格，7个像素，2号深灰有5个像素，3号浅灰有4个像素，4号纯白有4个像素。可以看到其在上面直方图的Y轴都一一对应。</p>
<p>这样看的话就很直观了。直方图左边代表照片的暗部，中间部分代表是照片的中间调，右边代表亮部。X轴以0-255的数值表示。0代表最暗的纯黑，255代表最亮的纯白。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072106.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="直方图的组成部分"><a href="#直方图的组成部分" class="headerlink" title="直方图的组成部分"></a>直方图的组成部分</h2><ol>
<li><strong>X轴（水平轴）</strong>：通常表示图像的亮度级别，从最左边的黑色（0）到最右边的白色（255）。</li>
<li><strong>Y轴（垂直轴）</strong>：表示在每个亮度级别上的像素数量。直方图的高度越高，表示该亮度级别的像素越多。</li>
</ol>
<h2 id="直方图的类型"><a href="#直方图的类型" class="headerlink" title="直方图的类型"></a>直方图的类型</h2><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072001.jpg"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>直方图的类型根据通道不同分很多种，常用的主要是判断影调的 明度，和判断色调的 颜色。明度模式和颜色模式有相应的转换关系——</p>

  <div class="note p-4 mb-4 rounded-small markdown-body primary">
    <p><code>L = R*0.30 + G*0.59 + B*0.11</code></p>

  </div>

<ul>
<li><strong>亮度直方图</strong>：显示从黑到白的像素分布。</li>
</ul>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072101.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<ul>
<li><strong>红蓝绿直方图</strong>: 分别代表的是红、绿、蓝三个通道的直方图。显示像素分布，有助于检查颜色平衡。</li>
</ul>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072103.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<ul>
<li><strong>RGB直方图</strong>：通常我们说直方图，一般指的就是RGB直方图。RGB直方图，实际上就是红绿蓝直方图的总和。</li>
</ul>
<p>举个简单的例子帮助大家理解：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072101.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这是一张1像素、颜色为（255, 0, 0）的纯红色方格。根据上一篇文章的RGB理论，其实这一个像素是由1个255度的红色像素，1个0度的绿色像素，1个0度的蓝色像素叠加而成：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072104.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>所以它的红绿蓝直方图长这样：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072105.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>而RGB直方图则长这样：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072102.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>我们可以发现，绿直方图在0的位置有1个像素，蓝直方图在0的位置有一个像素，合起来RGB直方图在0的位置就有2个像素；红直方图在255的位置有1个像素，相应的在RGB直方图255的位置就有1个像素。</p>
<p>所以RGB直方图实际上就是红绿蓝直方图的总和，它将红绿蓝三个直方图的数据加在一起。</p>
<ul>
<li><strong>颜色直方图</strong>：</li>
</ul>
<p>颜色直方图长这样：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-21/2024072101.jpg"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>颜色直方图其实就是将红绿蓝三个直方图如同图层一般叠在一起看，并在直方图里涂上相应的颜色。其中重叠在一起的部分还会呈现出对应的颜色：红直方图和绿直方图重叠的部分是黄色，蓝直方图和绿直方图重叠的部分是青色，红直方图和蓝直方图重叠的部分是品红。灰绿色则是三个直方图都重叠在一起的部分。</p>
<h2 id="直方图的应用"><a href="#直方图的应用" class="headerlink" title="直方图的应用"></a>直方图的应用</h2><ul>
<li><strong>评估曝光</strong>：如果直方图的峰值集中在右侧，图像可能过曝；如果集中在左侧，则可能欠曝。</li>
<li><strong>调整对比度</strong>：如果直方图显示像素集中在中间范围，图像可能缺乏对比度。</li>
<li><strong>防止细节丢失</strong>：确保直方图两端没有像素溢出，这表示高光和阴影的细节得到了保留。</li>
</ul>
<h3 id="亮度-影调相关"><a href="#亮度-影调相关" class="headerlink" title="亮度 影调相关"></a>亮度 影调相关</h3><h4 id="正常曝光"><a href="#正常曝光" class="headerlink" title="正常曝光"></a>正常曝光</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072002.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h4 id="过曝"><a href="#过曝" class="headerlink" title="过曝"></a>过曝</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072003.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h4 id="欠曝"><a href="#欠曝" class="headerlink" title="欠曝"></a>欠曝</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072004.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h4 id="发灰-缺乏对比度"><a href="#发灰-缺乏对比度" class="headerlink" title="发灰 缺乏对比度"></a>发灰 缺乏对比度</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072005.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h3 id="RGB-色调相关"><a href="#RGB-色调相关" class="headerlink" title="RGB 色调相关"></a>RGB 色调相关</h3><p>颜色模式的直方图也可以提供片子一定的色调信息，那么又该如何分析呢？直方图的颜色通道由R&#x2F;G&#x2F;B三色通道组成，分析之前先来研究研究简单案例，从简单到复杂。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072001.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>仔细观察这些纯色图片，你会发现一个规律——单色在直方图上显示的是其颜色和其互补色，其颜色分布在右，互补色分布在左。另外如果R&#x2F;G&#x2F;B完全一致，直方图将不显示颜色，片子转化为黑白，关于颜色直方图了解这些就够用了。</p>
<h4 id="偏色"><a href="#偏色" class="headerlink" title="偏色"></a>偏色</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072010.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这里的“偏色”并非指白平衡不准确造成的，所以打上引号，主要用来分析画面颜色。</p>
<p>直方图最右边和最左边分别代表片子高光和阴影，是需要分析的重点。直方图右边红色溢出，对应片子中红色的天空；左边红色溢出，则表示片子阴影偏其补色青色，对应片子中的地面。</p>
<p>由白平衡不准确造成的偏色也可以通过直方图来解决，由于片子的高光多半是纯白，通过调整白平衡，直到直方图右边没有颜色溢出即可，但是如果高光部分不是纯白，显然就不适用了。</p>
<h4 id="不通透"><a href="#不通透" class="headerlink" title="不通透"></a>不通透</h4><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072011.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>片子不通透是多方面的，这里换成低饱和度更为合适，直方图上表现为灰色多，颜色少。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072012.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h3 id="相机内置"><a href="#相机内置" class="headerlink" title="相机内置"></a>相机内置</h3><p>使用相机时，每次按下快门，片子会在液晶屏中预览两秒，看到片子觉得还不错，就急着开始拍下一张。其实液晶屏显示是会有误导的，往往与电脑显示效果有所偏差。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072007.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>仔细观察片子，有没有发现液晶屏中显示的片子比较亮，也可能是手机拍照的原因，但是偏差肯定是会有的，只有直方图才会完全一致。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072008.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>通过直方图判断片子影调是最保险的手段，每次拍完照片，如果不确定是否曝光正常，可以回头查看照片，然后通过【INFO.】键切换到有直方图的看图模式，一般明度直方图就够用了。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-07-20/2024072009.webp"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>甚至拍照时为避免过曝，可以开启高光警告，这样每拍完一张照片，在之后两秒的预览时间内，过曝导致缺失图像信息的高光区域会以黑色显示，可以非常直观的判断片子是否过曝。</p>
<blockquote>
<p>现场环境复杂多样，直方图毕竟是数据统计的表现形式，难免有局限性。</p>
</blockquote>
<h2 id="直方图常见解读"><a href="#直方图常见解读" class="headerlink" title="直方图常见解读"></a>直方图常见解读</h2><ul>
<li><strong>左倾</strong>：图像可能欠曝，需要增加曝光。</li>
<li><strong>右倾</strong>：图像可能过曝，需要减少曝光。</li>
<li><strong>高耸</strong>：图像可能对比度过高，需要调整。</li>
<li><strong>平坦</strong>：图像可能对比度低，需要增加对比度。</li>
</ul>
<h2 id="使用直方图拍摄照片"><a href="#使用直方图拍摄照片" class="headerlink" title="使用直方图拍摄照片"></a>使用直方图拍摄照片</h2><ul>
<li>在拍摄时，使用相机的直方图功能来检查曝光。</li>
<li>调整光圈、快门速度和ISO，以获得理想的直方图分布。</li>
<li>使用曝光补偿功能来微调曝光。</li>
</ul>
<h2 id="后期处理中的直方图"><a href="#后期处理中的直方图" class="headerlink" title="后期处理中的直方图"></a>后期处理中的直方图</h2><ul>
<li>在图像编辑软件中，使用直方图来调整曝光、对比度和色彩平衡。</li>
<li>确保直方图显示图像的色调分布符合创作意图。</li>
</ul>
<p>直方图是摄影和图像编辑中的重要工具，它提供了一种量化的方式来评估和调整图像的亮度和色彩分布。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/114534593" >关于直方图，你必须知道的几点 - 摄影狗的咸鱼日常<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>摄影</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影 构图 趣味中心</title>
    <url>/2024/08/10/%E6%91%84%E5%BD%B1-%E6%9E%84%E5%9B%BE-%E8%B6%A3%E5%91%B3%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<p>专业摄影者往往能比业余摄影者拍出更好的照片来，原因之一是专业摄影者一般是接受了一个任务才开始工作的。<br>为了一个特定的目的，拍摄一张表现特定思想内容的照片。<br>他可能是给一则新闻报道选配插图，或者是拍摄一个使用中的产品，甚至是为了编写或支持一个社会问题的声明而拍照。<br>照片的最后用途是在摄影家形始工作之前就讲清楚了的。</p>
<p>有时候任务十分明确，得事先作出全面设计以保证照片能够不折不扣地满足用户的要求。<br>但是大多数情况下，用户十分信任摄影家处理细节的能力，双方只需要对作品的预期效果充分协商达成谅解就行了。</p>
<p>无论如何，当摄影家准备拍照的时候，这个特定的主题内容和被摄物在他心目中是压倒一切的，在拍摄过程中和最后印片时都是如此。<br>他对成果的评价，首先看对指定任务完成得好不好，其次才是艺术才能发挥得如何；<br>这种艺术才能可以使作品不但满足了基本要求，还富有感染力。</p>
<h2 id="树立单一的主要概念"><a href="#树立单一的主要概念" class="headerlink" title="树立单一的主要概念"></a>树立单一的主要概念</h2><p>每张照片只能有一个主要的思想内容即主题。<br>照片中所有其它景物都必须是从属的。<br>这些从属景物要尽可能地配合主体，烘托主体，以达到突出主体的目的。<br>从属景物应当作为背景处理。</p>
<p>一张照片如果没有明显的占压倒优势的趣味中心，观众看了就会迷惑不解。<br>如果不是故意的话，他们也会下意识地问：</p>
<blockquote>
<p>“你要我看什么？这里有什么可看的？”</p>
</blockquote>
<p>必须让观众尽快地理解照片，立刻看出重点之所在。</p>
<p>当主体是一个单一的物体并且几乎充满画面时，或者由于明暗对比和质感强烈而十分醒目的话，并不存在什么问题。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-10/20240810202239.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-10/20240810202258.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>主体不一定必须是一个人、一个地方或一件东西。<br>它可以是一个形状、一个线条、一个物体局部的质感，或者是相互联系着的若干物体。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-10/20240810202313.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>摄影者没有作出努力去确定趣味中心，因而根本就没有趣味中心。<br>许多有意义的影物看不到了，以致于画面缺乏内在情趣，难以形成优势地位。<br>这样处理的结果，画面各部分只配作为从属景物。<br>此外，也没有什么醒目的形状和线条来弥补这个缺陷。<br>因而，观众除了浏览一下之外，在照片中找不到什么值得看的东西。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-10/20240810202326.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>当然，不必过多地强调摄影家在拍每张照片之前，心中都得先有一个主体。<br>如果不是受人委托而拍照，摄影家就可以自选主体。<br>但在他未作出决定之前，他的工作目的是不很明确的。<br>如果开头就没有一个明确的决心，那么，成品就很难表达一个明确的思想内容。</p>
<h2 id="视觉的选择性"><a href="#视觉的选择性" class="headerlink" title="视觉的选择性"></a>视觉的选择性</h2><p>作为趣味中心的主体，在取景器里或磨砂玻璃聚焦屏上必须是一目了然。<br>当我们发现了一个拍摄题材，随之心情十分兴奋的时候，我们往往会忽略那些分散注意力的因素；<br>而这些因素足以破坏主体的感染力。<br>这就是视觉选择性造成的结果。</p>
<p>我们都吃过“视觉选择性”的苦。<br>我们主观上想把注意力集中在引起我们兴趣的部分，同时排除实际存在于周围的那些细节。<br>我们仿佛在盼望它们自行消失或变得不那么明显。<br>因为它们在我们心目中的印象不深，总以为它们不会出现在照片上。<br>可是哪位摄影家没有经历过：</p>
<blockquote>
<p>曝光时并不觉察的物体，照片出来以后才被发现而大吃一惊呢？</p>
</blockquote>
<h2 id="从属景物"><a href="#从属景物" class="headerlink" title="从属景物"></a>从属景物</h2><p>每种题材，不论是复杂还是简单的，都包含着若干内容和物体，其中的每一个都有可拍之处。<br>应该选哪一个——只能选一个——作为照片中的主体来拍呢？一个通病是，看见一个题材，就以为其中每件东西都有价值的，并且把它们通统拍下来。<br>这种“包罗万象”的处理题材的方法是造成视觉混乱的根本原因，其实，有些东西必须割爱！</p>
<p>割爱，是艺术手法的一个组成部分，要做到是不容易的，如果只有一件事，一个东西或一种思想要加以强调而使之居于优势地位的话，那么，画面中所有其它东西都应当排除，或者降低到次要地位。<br>如果容许那些可能引起强烈兴趣的影物很清楚地保留在画面上，它们就会同选定的主体分庭抗礼。<br>即使画面中只有两个同样具有吸引力的景物，也能分散观众的注意力，从而破坏了这幅作品的效果。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-10/20240810202347.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>如果无法使两者之一处于从属地位，解决问题的唯一办法是分别拍成两张照片。</p>
<h2 id="突出表现一个景物"><a href="#突出表现一个景物" class="headerlink" title="突出表现一个景物"></a>突出表现一个景物</h2><p>关于要避免“包罗万象”的劝告，经常被误解为：</p>
<blockquote>
<p>有趣的构图只能来自特写。</p>
</blockquote>
<p>完全不是！趣味中心只要求具有一个清晰而鲜明的事物或思想内容。<br>它可以是整个物体或者物体的一部分。<br>也可以是以某种方式结合在一起的若干物体的组合。<br>它可以是一个抽象的构图要素，也可以是几个要素的组合。</p>
<p>统一感，是由一个联结因素把画面的各个部分联结为一个有机体系并和周围的环境分离开来而产生的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-10/20240810202403.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这个有机体系还可以通过明暗对比或质感差别从周围环境之中被突出出来。</p>
<p>趣味中心也是可以是一个有趣的线条，例如一根树枝，路面上的一条裂缝或涂在公路上的交通指示线。</p>
<p>有时候也可以是某种奇特的动作或思想内容。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-10/20240810202417.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-10/20240810202427.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="背景的作用"><a href="#背景的作用" class="headerlink" title="背景的作用"></a>背景的作用</h2><p>各种大场面的景物，例如山腰的一个城镇，一群建筑物，一群人，一群牛等等，都能成为而且早已成为优秀照片的主体。<br>如果它们通过一定的形式、影调、线条或某种概念而结为一体，并且能从背景中分离出来，那它们就是很合格的趣味中心。<br>处于次要地位而足以表明所处环境的背景，是必不可少的：<br>有了它，才能显示出主体的优势；<br>否则，趣味中心就失去了它的地位。<br>如果没有足够的背景来衬托主体，那么，就选择一个本来无意突出的部分作为趣味中心，而把其余部分当作背影。</p>
<p>房子，铁塔和灯塔合在一起构成了趣味中心。</p>
<p>它们当中任何一个也没有由于单独突出而吸引观众注意力；<br>因而，全组景物成了一个整体。<br>主体被围绕着它的不显眼的大片空间所突出。<br>虽然这个空间不乏细部层次，也有一定的趣味，但它终究是作为背景而存在的。</p>
<p>用同一张底片剪裁的，周围的空间没有了，从而突出的感觉也就不存在了。<br>现在，灯塔处于画面中心，高度突出，形状醒目，色调鲜明，于是成了趣味中心。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-12/20240812122831.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>让我们回头看看。从画面上说，它之所以失败，就在于没有趣味中心。<br>现在再来看看。从较远距离上拍的那所房子，由于它的形状、细部影纹和明暗对比而显示了它的重要性。<br>前景中三只小船朝向着它，从每只船上伸出的线条有一种视觉动感，吸引了观众的视线并把它们引向房子的明显部位。<br>一幅照片既有一个明确的主体，又有次要景物来烘托它，这幅照片就必定能紧紧地抓住观众的注意力。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-12/20240812122847.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>从较近的距离上，有可能把山麓的景物拍得一清二楚。<br>船坞里的楼群，一棵对，或者一簇树，由于它们姿态动人，又有明暗对比强烈的背景衬托，都能给人很大的视觉快感。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-12/20240812122900.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>从另一方面说，一群树干形成的节奏也可能把人吸引住。<br>暗调的垂直形状不断重复出现，形成一个线条的节奏。<br>而树干之间的间隔，又形成略微不同的图案。<br>于是在物体和间隔之间建立起一种对位的和谐关系。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-12/20240812122912.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>凑近一些，仔细观察一个物体，譬如观察一块树皮，一株香蕈，一片苔藓时，人们可能会发现它的形状和质感结合起来十分动人。<br>当一根树技呈线型运动，弯曲盘绕，不断分出细嫩的枒杈和枝条时，它的图案是相当动人的。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-12/20240812122921.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>在有些地方，人们会发现一个多层石阶或废弃多年的建筑物的遗迹，现在它们上面已是杂草丛生，面貌皆非了。<br>拍下这样诗一般的画面，足以说明大自然是在多么迅速地改变着大地的面貌。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-12/20240812122931.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>无论远摄还是近摄，对选择趣味中心都无关紧要。<br>重要的是要养成一种习惯：<br>去思考，去设法树立一个主体并围绕这个主体创作你的作品。<br>正像先有思想后有语言一样，趣味中心必须在着手拍照之前就确定下来。<br>缺乏思想的语言是空洞的，缺乏思想的照片只能是一个毫无意义的物体的乱七八糟的影像。<br>在视觉形象中和在语言文字中一样，意义含糊会使人不得要领。</p>
<p>必须学会在任何特定的全体景物之中把值得特别宣扬的那个物体突出出来。<br>在一幅肖像作品里，要突出的也许是眼睛、鼻子、嘴巴或头形。<br>我们能够很容易地把发型、鼻梁的阴影、面部轮廓的明亮线条作为特征来处理。<br>一个生动的表情、头颈之间的曲线以及老人皮肤的质感等，所有这些都值得作为趣味中心加以考虑。<br>一幅人像作品能把人物最生动的表情特征集中表现出来，这比大量文字描写更能揭示他对人生的态度。</p>
<p>可以充当照片趣味中心的题材是无限的，这话已成老生常谈。<br>但这句老生常谈却是千真万确的。<br>一旦在你的心目中有了一个明确的思想，你就能找到方法把它表达出来，即使在有些被摄物从相对体积来说不利于充当趣味中心的时候，你也能设法达到目的。</p>
<p>正在钉到板上的钉子虽然是照片中最小的物体，但毫无疑问它是趣味中心。<br>所有其它东西，不是处于从属地位，就是帮助注意力引向那个钉子。<br>技术人员的头、拿着钉子的手臂以及握在一起的大拇指和食指，甚至另一只手和锤子，都指向那根钉子，但它们并未分散人们的注意力，而是向人们指出这个趣味中心正被用来设计曲线上定位。<br>一个特别有利的因素是钉子的明亮的影调，衬在手指和阴影构成的暗调背景上显得很突出。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-12/20240812122948.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<h2 id="复合趣味中心"><a href="#复合趣味中心" class="headerlink" title="复合趣味中心"></a>复合趣味中心</h2><p>我们经常会碰到一个题材里有两个或两个以上的物体需要同时加以强调。<br>如果这两个物体通过十分相似的要素而互相联系，问题并不难解决。<br>可以把它们当作相互联系的内容或者一个联合体来处理。</p>
<p>很明显，共同有关的内容是帆船工比赛。<br>两只船的桅杆和主帆的方向、鼓着风的三角帆和船工体的形状看来都很相似。<br>在构图上，两船之中没有一只占据完全优势。<br>尽管左边一只在体积和位置上略胜一筹，但它还是组成一个整体占据着画面。<br>背景确定处于次要地位，所以这一复合体在画面上占据着无可争议的优势。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-12/20240812123004.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>这种优势并不牢靠，为了充分理解这一点，可以轮流遮住某一个船的一小部分。<br>注意趣味中心是怎样移到未被遮住的那条船上的。<br>对背景的任何剪裁、缩小，都会使趣味中心从两只船组成的复合体转移到画面正中间鼓满风的三角帆上去。<br>你会发现，为了使两个或更多的景物联结成一个趣味中心，必须用比较宽阔的背景去突出它。<br>背景越宽阔，多个景物结成一个趣味中心的机会就越多。<br>当然，它们互相靠得越近，结成一个整体的可能性就越大。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/photography/2024-08-12/20240812123022.png"
                      alt="-"
                ><figcaption>-</figcaption></figure></p>
<p>选好作为趣味中心的主体以后，用什么方法加强它，使它真正占据优势呢？<br>可以求助于三个因素——布局、大小和对比。<br>这三个因素偶尔单独发挥作用，但经常是共同发挥作用的。</p>
]]></content>
      <categories>
        <category>摄影</category>
        <category>构图</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-Apriori</title>
    <url>/2017/03/16/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-Apriori/</url>
    <content><![CDATA[<blockquote>
<p>从海量数据中挖掘可信频繁项集</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">易编码实现</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">大数据集运行缓慢</td>
</tr>
<tr>
<td align="center">适用</td>
<td align="center">数值型，标称型</td>
</tr>
</tbody></table>
<h1 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h1><table>
<thead>
<tr>
<th align="center">名词</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">association analysis</td>
<td align="center">关联分析</td>
</tr>
<tr>
<td align="center">association rule learning</td>
<td align="center">关联规则学习</td>
</tr>
<tr>
<td align="center">frequent item set</td>
<td align="center">频繁项集</td>
</tr>
<tr>
<td align="center">association rule</td>
<td align="center">关联规则</td>
</tr>
<tr>
<td align="center">frequent</td>
<td align="center">频繁</td>
</tr>
<tr>
<td align="center">support</td>
<td align="center">支持度</td>
</tr>
<tr>
<td align="center">confidence</td>
<td align="center">可信度</td>
</tr>
</tbody></table>
<pre><code>a priori 一个先验 使用知识作为条件进行推断
a postriori 一个后验 使用结果作为条件检测
</code></pre>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>如果某个项集是频繁项集，那么他的子项集也是频繁项集。反之，如果一个项集是非频繁项集，那么他的所有超集也是非频繁项集。</p>
<ol>
<li>收集数据</li>
<li>准备数据</li>
<li>分析数据</li>
<li>训练算法</li>
<li>测试算法</li>
<li>使用算法</li>
</ol>
<hr>
<ul>
<li>首先发现频繁项集</li>
<li>然后计算出关联规则</li>
</ul>
<h3 id="生成候选项集"><a href="#生成候选项集" class="headerlink" title="生成候选项集"></a>生成候选项集</h3><ul>
<li>记录训练数据集中每一条数据为候选项集</li>
<li>检查每一个候选项集属于数据集子集的个数</li>
<li>对于候选项集如果最小值不小于支持度，则保留该项集</li>
<li>返回所有频繁项集</li>
</ul>
]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-K-Means</title>
    <url>/2017/03/21/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-K-Means/</url>
    <content><![CDATA[<blockquote>
<p>类内数据点越近越好，类间数据点越远越好。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">容易实现</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">可能收敛到局部最小值，在大规模数据集上收敛较慢</td>
</tr>
<tr>
<td align="center">适用</td>
<td align="center">数值型</td>
</tr>
</tbody></table>
<p>输入：分类个数k，包含在n个数据对象的数据集</p>
<p>输出：k个聚类</p>
<p>步骤：</p>
<ol>
<li>从n个数据对象中任意选取k个对象作为初始聚类中心</li>
<li>分别计算每个对象到各个聚类中心距离，把对象分配到距离最近的聚类中</li>
<li>所有对象分配后，重新计算k个聚类的中心</li>
<li>与前一次计算得到k个聚类中心比较，如果聚类中心发生变化，转步骤2，否则转步骤</li>
<li>得出结果</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_05_1.jpg"
                     
                ></p>
]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-KNN</title>
    <url>/2017/03/06/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-KNN/</url>
    <content><![CDATA[<blockquote>
<p>KNN 近邻算法：测量不同特征值之间距离进行分类</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">精度高，对异常值不敏感，无数据输入假定</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">计算复杂度高，空间复杂度高</td>
</tr>
<tr>
<td align="center">适用</td>
<td align="center">数值型，标称型</td>
</tr>
</tbody></table>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li><p>存在一个训练集，并且每个数据都存在标签</p>
</li>
<li><p>输入没有标签的新数据</p>
</li>
<li><p>将新数据与训练集特征进行比较</p>
</li>
<li><p>提取训练集中特征最相似的分类标签分类</p>
<p> 一般只选择训练集中的前 K 个最相似数据</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-MapReduce</title>
    <url>/2017/03/14/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-MapReduce/</url>
    <content><![CDATA[<blockquote>
<p>可以通过分布式进行大数据量的计算的软件框架</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">短时间内完成大量工作</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">算法必须经过重写，需要对系统工程有一定理解</td>
</tr>
<tr>
<td align="center">适用</td>
<td align="center">数值型，标称型</td>
</tr>
</tbody></table>
<p>MapReduce 在大量节点组成的集群上运行（分布式计算）。</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol>
<li>map阶段 : 单个作业被分成很多小分，输入数据也被切片分发到每个节点，各个节点只在本地数据上运算 对应运算代码称为mapper</li>
<li>sort&#x2F;combine阶段 ： 对mapper进行排序或组合</li>
<li>shuffle阶段：将map的输出作为reduce的输入的过程，MapReduce主要在这个地方优化</li>
<li>reduce阶段 : 每个mapper的输出通过某种方式组合（一般包括排序），排序后再被分成小份分发到各个节点进行下一步处理工作。对应运算代码称为reducer</li>
</ol>
<hr>
<ul>
<li>主节点控制 <strong>MapReduce</strong> 的作业流程</li>
<li><strong>MapReduce</strong> 的作业可以分成 <strong>map</strong> 任务和 <strong>reduce</strong> 任务</li>
<li><strong>map</strong> 任务之间不做数据交流，<strong>reduce</strong> 任务也一样（每个节点只处理自己的事务）</li>
<li>在 <strong>map</strong> 和  <strong>reduce</strong> 阶段之间，有一个 <strong>sort</strong> 或 <strong>combine</strong> 阶段</li>
<li>数据被重复存放在不同的机器上，以防某个机器失效</li>
<li><strong>mapper</strong> 和 <strong>reducer</strong> 传输的数据形式为 <strong>key&#x2F;value</strong> 对</li>
</ul>
]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-SVM</title>
    <url>/2017/03/09/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-SVM/</url>
    <content><![CDATA[<blockquote>
<p>SVM：寻找一条最优的分界线使得它到两边的距离 <strong>margin</strong> 都最大。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">泛化错误率低，计算开销不大，易于理解</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">对参数调节和核函数选择敏感，原始分类器不参加修改适合处理二类问题</td>
</tr>
<tr>
<td align="center">适用</td>
<td align="center">数值型，标称型</td>
</tr>
</tbody></table>
<h1 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h1><table>
<thead>
<tr>
<th align="center">名词</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">data</td>
<td align="center">数据</td>
</tr>
<tr>
<td align="center">classifier</td>
<td align="center">分类器</td>
</tr>
<tr>
<td align="center">optimization</td>
<td align="center">最优解</td>
</tr>
<tr>
<td align="center">kernel</td>
<td align="center">核函数</td>
</tr>
<tr>
<td align="center">hyperplane</td>
<td align="center">超平面</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>SVM - Support Vector Machine 支持向量机</strong>，为一种有监督机器（<strong>supervised</strong> learning）算法，属于分类（<strong>classification</strong>）的范畴。在数据挖掘的应用中，与无监督（<strong>unsupervised</strong>）的聚类（<strong>Clustering</strong>）相对应和区别。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_07_1.jpg"
                     
                ></p>
<p>在这种情况下边缘加粗的几个数据点就叫做 <strong>Support Vector</strong>。</p>
<h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><pre><code>在二维平面上可用一个线性函数可以将两类样本完全分开叫做线性可分。
</code></pre>
<p>事实上，大部分数据并不是线性可分的，这个时候满足这样条件的超平面就根本不存在。对于非线性的情况，SVM 的处理方法是选择一个核函数（<strong>Kernel</strong>） ，通过将数据映射到高维空间，<br>拓展至任意n维乃至无限维空间，来解决在原始空间中线性不可分的问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_07_3.gif"
                     
                ></p>
<p>核函数的价值在于它虽然也是将特征进行从低维到高维的转换，但核函数事先在低维上进行计算，而将实质上的分类效果表现在了高维上，避免了直接在高维空间中的复杂计算。</p>
<h1 id="常见分类模型"><a href="#常见分类模型" class="headerlink" title="常见分类模型"></a>常见分类模型</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_07_2.png"
                     
                ></p>
]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-PCA降维</title>
    <url>/2017/03/13/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-PCA%E9%99%8D%E7%BB%B4/</url>
    <content><![CDATA[<blockquote>
<p>若存在N个M维的训练集，N与M不小于百万级，该如何处理？</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">降低数据的复杂性，识别最重要的多个特征</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">不一定需要，有一定损失有用信息的可能</td>
</tr>
<tr>
<td align="center">适用</td>
<td align="center">数值型</td>
</tr>
</tbody></table>
<h1 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h1><table>
<thead>
<tr>
<th align="center">名词</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">dimensionality reduction</td>
<td align="center">降维</td>
</tr>
<tr>
<td align="center">principal component analysis</td>
<td align="center">PCA主元分析</td>
</tr>
<tr>
<td align="center">factor analysis</td>
<td align="center">FA因子分析</td>
</tr>
<tr>
<td align="center">latent variable</td>
<td align="center">隐变量</td>
</tr>
<tr>
<td align="center">independent component analysis</td>
<td align="center">ICA独立成分分析</td>
</tr>
</tbody></table>
<hr>
<h1 id="降维方式"><a href="#降维方式" class="headerlink" title="降维方式"></a>降维方式</h1><ol>
<li>PCA （ Principal Component Analysis ）主元分析。是一种掌握事物主要矛盾的统计分析方法，它可以从多元事物中解析出主要影响因素，揭示事物的本质，简化复杂的问题。计算主成分的目的是将高维数据投影到较低维空间。给定 n 个变量的 m 个观察值，形成一个 n ′ m 的数据矩阵， n 通常比较大。</li>
<li>FA（Factor Analysis）因子分析。从观察数据中找出观察不到的隐变量（观察数据 &#x3D; （隐变量 + 某些噪声）线性组合）</li>
<li>ICA（Independent Component Analysis）独立成分分析。假设数据从N个数据源获取，数据源之间统计上相互独立，如果数据源的数目少于观察数据的数目，则可以实现降维过程。</li>
</ol>
<p>对于一个由多个变量描述的复杂事物，人们难以认识，那么PCA降维就是用来减少不确定干扰变量或者对分析结果影响较小的变量，以此达到降低训练集维度的效果。这样做的优势是分解难度以及提高效率。</p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><ul>
<li>使数据集更易使用</li>
<li>降低很多算法开销</li>
<li>去除噪声</li>
<li>使结果易懂</li>
</ul>
<h5 id="个人的一点浅见，之所以降维是因为高纬度的可视化人类或许无法有共识的理解，人是三维生物，低维度生物无法理解高维度，因为他们无法感知，但是高维度生物却轻松掌握低纬度，就像我们看一维度的坐标，与二维度的横竖坐标，所以每一个人对与四维度以及以上都会有自己想象的模型，或许是一种超矩阵立方体，或许是蠕虫形状的无限切面，所以将维度降低到一个普遍可以接受并且符合客观的标准，更有助于人类消化与学习。"><a href="#个人的一点浅见，之所以降维是因为高纬度的可视化人类或许无法有共识的理解，人是三维生物，低维度生物无法理解高维度，因为他们无法感知，但是高维度生物却轻松掌握低纬度，就像我们看一维度的坐标，与二维度的横竖坐标，所以每一个人对与四维度以及以上都会有自己想象的模型，或许是一种超矩阵立方体，或许是蠕虫形状的无限切面，所以将维度降低到一个普遍可以接受并且符合客观的标准，更有助于人类消化与学习。" class="headerlink" title="个人的一点浅见，之所以降维是因为高纬度的可视化人类或许无法有共识的理解，人是三维生物，低维度生物无法理解高维度，因为他们无法感知，但是高维度生物却轻松掌握低纬度，就像我们看一维度的坐标，与二维度的横竖坐标，所以每一个人对与四维度以及以上都会有自己想象的模型，或许是一种超矩阵立方体，或许是蠕虫形状的无限切面，所以将维度降低到一个普遍可以接受并且符合客观的标准，更有助于人类消化与学习。"></a>个人的一点浅见，之所以降维是因为高纬度的可视化人类或许无法有共识的理解，人是三维生物，低维度生物无法理解高维度，因为他们无法感知，但是高维度生物却轻松掌握低纬度，就像我们看一维度的坐标，与二维度的横竖坐标，所以每一个人对与四维度以及以上都会有自己想象的模型，或许是一种超矩阵立方体，或许是蠕虫形状的无限切面，所以将维度降低到一个普遍可以接受并且符合客观的标准，更有助于人类消化与学习。</h5><blockquote>
<p>有效的降维可以达到预期效果，但是降维往往是不可逆的，若选取了错误的维度消除，训练出的规则也必将偏离。</p>
</blockquote>
]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-Spark</title>
    <url>/2017/03/28/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-Spark/</url>
    <content><![CDATA[<blockquote>
<p>Spark : 借鉴了MapReduce之上发展而来的，继承了其分布式并行计算的优点并改进了MapReduce明显的缺陷</p>
</blockquote>
<h1 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h1><table>
<thead>
<tr>
<th align="center">环境</th>
<th align="center">描述</th>
<th align="center">模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>local</strong></td>
<td align="center">本地单进程模式</td>
<td align="center">本地模式</td>
</tr>
<tr>
<td align="center"><strong>standalone</strong></td>
<td align="center">分布式集群,Master-Worker架构（或者Master-Slave），<br>Master负责调度，Worker负责具体Task的执行</td>
<td align="center">集群模式</td>
</tr>
<tr>
<td align="center"><strong>on yarn&#x2F;mesos</strong></td>
<td align="center">通过YARN或Mesos作为资源管理，Spark作为调度控制</td>
<td align="center">集群模式</td>
</tr>
<tr>
<td align="center"><strong>on cloud</strong></td>
<td align="center">AWS（Amazom Web Services）的EC2（Elastic Compute Cloud）<br>服务</td>
<td align="center">集群模式</td>
</tr>
</tbody></table>
<h1 id="Spark生态系统"><a href="#Spark生态系统" class="headerlink" title="Spark生态系统"></a>Spark生态系统</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_21_1.bmp"
                     
                ></p>
<ol>
<li>Spark SQL : 允许直接处理RDD，也可查询Hive、HBase等外部数据源。</li>
<li>Spark Streaming ： 实时数据流处理组件（Storm）。</li>
<li>MLlib : 机器学习算法，含聚类、分类、回归、协同过滤。</li>
<li>GraphX : 用于图计算API。</li>
<li>Spark Core : Spark的基本功能，内存计算、任务调度、部署模式、故障恢复、存储管理等</li>
<li>Standalone Scheduler : 分布式独立运行。</li>
<li>YARN : Apache Hadoop YARN （Yet Another Resource Negotiator，另一种资源协调者）是一种新的 Hadoop 资源管理器。</li>
<li>Mesos : Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。</li>
</ol>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><table>
<thead>
<tr>
<th align="center">概念</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RDDs</td>
<td align="center">Resillient Distributed DataSets，弹性分布式数据集，是分布式内存的一个抽象概念，提供一种高度受限的共享内存模型</td>
</tr>
<tr>
<td align="center">DAG</td>
<td align="center">Directed Acyclic Graph，有向无环图，反映RDD之间的依赖关系</td>
</tr>
<tr>
<td align="center">Application</td>
<td align="center">Spark的应用程序，包含一个Driver program和若干Executor</td>
</tr>
<tr>
<td align="center">Driver Program</td>
<td align="center">运行Application的main()函数并且创建SparkContext</td>
</tr>
<tr>
<td align="center">Cluster Manager</td>
<td align="center">在集群上获取资源的外部服务(例如：Standalone、Mesos、Yarn)</td>
</tr>
<tr>
<td align="center">Worker Node</td>
<td align="center">集群中任何可以运行Application代码的节点，运行一个或多个Executor进程</td>
</tr>
<tr>
<td align="center">Executor</td>
<td align="center">是为Application运行在工作节点（Worker Node）上的一个进程，该进程负责运行Task，并且负责将数据存在内存或者磁盘上。每个Application都会申请各自的Executor来处理任务</td>
</tr>
<tr>
<td align="center">SparkContext</td>
<td align="center">Spark应用程序的入口，负责调度各个运算资源，协调各个Worker Node上的Executor</td>
</tr>
<tr>
<td align="center">Job</td>
<td align="center">一个Job含多个RDD及作用于RDD上的各种操作，SparkContext提交的具体Action操作，常和Action对应</td>
</tr>
<tr>
<td align="center">Stage</td>
<td align="center">是Job的基本调度单位，一个Job分为多组Task，每组Task被称为Stage，或者称为TaskSet，代表了一组关联的、相互之间没有Shuffle依赖关系的任务组成的任务集</td>
</tr>
<tr>
<td align="center">Task</td>
<td align="center">运行在Executor上的工作单元</td>
</tr>
<tr>
<td align="center">DAGScheduler</td>
<td align="center">根据Job构建基于Stage的DAG，并提交Stage给TaskScheduler</td>
</tr>
<tr>
<td align="center">TaskScheduler</td>
<td align="center">将Taskset提交给Worker node集群运行并返回结果</td>
</tr>
<tr>
<td align="center">Transformations</td>
<td align="center">是Spark API的一种类型，Transformation返回值还是一个RDD，所有的Transformation采用的都是懒策略，如果只是将Transformation提交是不会执行计算的</td>
</tr>
<tr>
<td align="center">Action</td>
<td align="center">是Spark API的一种类型，Action返回值不是一个RDD，而是一个scala集合；计算只有在Action被提交的时候计算才被触发</td>
</tr>
</tbody></table>
<h1 id="Spark运行流程"><a href="#Spark运行流程" class="headerlink" title="Spark运行流程"></a>Spark运行流程</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_21_2.bmp"
                     
                ></p>
<ol>
<li>提交一个Application后，首先构建基本运行环境，即由Driver创建一个SparkContext，由SparkContext负责和资源管理器（Cluster Manager）的通信，以及资源的申请、任务的分配和监控等。SparkContext会向资源管理器注册并申请运行Executor的资源；</li>
<li>资源管理器为Executor分配资源，启动Executor进程，Executor运行情况随着“心跳”发送到资源管理器上；</li>
<li>SparkContext根据RDD的依赖关系构建DAG图，DAG图提交给DAGScheduler进行解析，将DAG图分解成Stage，并计算Stage间的依赖关系，然后将一个个TaskSet（即Stage）提交给底层调度器TaskScheduler进行处理；Executor向SparkContext申请Task，TaskScheduler将Task发放给Executor运行，同时，SparkContext将应用程序代码发送给Executor；</li>
<li>Task在Executor上运行，结果反馈给TaskScheduler，然后反馈给DAGScheduler，运行完毕后写入数据，并释放资源。</li>
</ol>
<h1 id="Spark架构特点"><a href="#Spark架构特点" class="headerlink" title="Spark架构特点"></a>Spark架构特点</h1><ul>
<li>每个Application都有专属的Executor进程，并且在Application运行期间一直驻留。Executor进程以多线程的方式运行Task；</li>
<li>Spark运行过程与资源管理器无关，只要能获取Executor进程并保存通信即可；</li>
<li>Task采用数据本地性和推测执行等优化机制。数据本地性，即计算向数据靠拢，移动计算比移动数据占得网络资源要少。Spark采用延时调度机制，可在更大程度上实现执行过程优化。</li>
</ul>
]]></content>
      <tags>
        <tag>Tools</tag>
        <tag>DataMining</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-决策树</title>
    <url>/2017/03/05/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>决策树：从属性相同的一类别事例推理树状规则分类方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">计算复杂度不高，输出易于理解，中间值缺失不敏感，可以处理不相关特征数据</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">可能产生过拟合</td>
</tr>
<tr>
<td align="center">适用</td>
<td align="center">数值型，标称型</td>
</tr>
</tbody></table>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li>生成决策树：关键&#x3D;&gt; 选择适合的属性作为判别依据</li>
<li>修剪决策树：生成决策树时未考虑的噪声影响，容易出现过拟合，预测效果差，预先剪枝，后剪枝</li>
<li>识别叶子节点：差异较大，为规则</li>
</ol>
<h1 id="ID3不足"><a href="#ID3不足" class="headerlink" title="ID3不足"></a>ID3不足</h1><ol>
<li>无法回溯，不一定是全局最优解</li>
<li>信息增益，信息熵偏向属性取值较多的属性</li>
<li>仅处理离散，不能处理连续属性</li>
<li>样本过小或包含噪声时，容易过拟合（Overfitting）</li>
</ol>
]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-欠拟合与过拟合</title>
    <url>/2017/03/08/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-%E6%AC%A0%E6%8B%9F%E5%90%88%E4%B8%8E%E8%BF%87%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>以MATLAB 模拟离散点</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_04_1.png"
                     
                ></p>
<blockquote>
<p>以下为欠拟合与过拟合图示：</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_04_2.png"
                     
                ></p>
<h1 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h1><blockquote>
<p>模型没有很好地捕捉到数据特征，不能够很好地拟合数据。</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>添加其他特征项，有时候我们模型出现欠拟合的时候是因为特征项不够导致的，可以添加其他特征项来很好地解决。</li>
<li>添加多项式特征，这个在机器学习算法里面用的很普遍，例如将线性模型通过添加二次项或者三次项使模型泛化能力更强。</li>
<li>减少正则化参数，正则化的目的是用来防止过拟合的，但是现在模型出现了欠拟合，则需要减少正则化参数。</li>
</ol>
<h1 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h1><blockquote>
<p>模型数据学习过于彻底，噪声数据特征也学习了，后期测试无法很好地识别数据，不能正确的分类，模型泛化能力太差。</p>
</blockquote>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li><p>重新清洗数据，导致过拟合的一个原因也有可能是数据不纯导致的，如果出现了过拟合就需要我们重新清洗数据。</p>
</li>
<li><p>增大数据的训练量，还有一个原因就是我们用于训练的数据量太小导致的，训练数据占总数据的比例过小。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘 序</title>
    <url>/2024/07/15/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-%E5%BA%8F/</url>
    <content><![CDATA[<video id="video" style="width= 100%; height=100%; object-fit: fill" controls="" loop="loop" autoplay="autoplay" src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program//datamining/datamining.mp4"/>]]></content>
      <categories>
        <category>DataMining</category>
      </categories>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-朴素贝叶斯</title>
    <url>/2017/03/04/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    <content><![CDATA[<blockquote>
<p>朴素贝叶斯 (<strong>Naive Bayesian</strong>) : 通过随机事件A和B的条件概率（或边缘概率）判断规则是否可信</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="center">数据较少仍然有效，可以处理多类别问题</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">对于输入数据敏感</td>
</tr>
<tr>
<td align="center">适用</td>
<td align="center">标称型</td>
</tr>
</tbody></table>
<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://61.91.161.217/chart?cht=tx&chl=\Large p(y|x)=\frac{p(x|y)p(y)}{p(x)}"
                      style="border:none;"
                >

<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算每个类别特征数目</span><br><span class="line">对每个训练集：</span><br><span class="line">	对每个特征：</span><br><span class="line">		如果特征出现在集合中-&gt;增加该特征计数值</span><br><span class="line">		增加所有特征计数值</span><br><span class="line">	对每个特征：</span><br><span class="line">		对每条数据：</span><br><span class="line">			将该数据的数目除以总数据数目得到条件概率</span><br><span class="line">	返回每个特征的条件概率	</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-回归分析</title>
    <url>/2017/03/07/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>原文<br><a class="link"   href="https://www.analyticsvidhya.com/blog/2015/08/comprehensive-guide-regression/" >https://www.analyticsvidhya.com/blog/2015/08/comprehensive-guide-regression/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>译文<br><a class="link"   href="http://blog.csdn.net/lynnucas/article/details/47948639" >http://blog.csdn.net/lynnucas/article/details/47948639<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<hr>
<blockquote>
<p>回归分析 : 是一种预测性的建模技术,使用曲线拟合数据点，最终获取到数据点的距离差异最小的曲线</p>
</blockquote>
<pre><code>回归主要三个度量：自变量的个数，因变量的类型以及回归线的形状
</code></pre>
<h1 id="线性回归-（Linear-Regression）"><a href="#线性回归-（Linear-Regression）" class="headerlink" title="线性回归 （Linear Regression）"></a>线性回归 （Linear Regression）</h1><blockquote>
<p>因变量是连续的，自变量可以是连续的也可以是离散的，回归线的性质是线性的。</p>
</blockquote>
<p>线性回归使用最佳的拟合直线（也就是回归线）在因变量（Y）和一个或多个自变量（X）之间建立一种关系。</p>
<p>用一个方程式来表示它，即Y&#x3D;a+b*X + e，其中a表示截距，b表示直线的斜率，e是误差项。这个方程可以根据给定的预测变量（s）来预测目标变量的值。</p>
<p>一元线性回归和多元线性回归的区别在于，多元线性回归有（&gt;1）个自变量，而一元线性回归通常只有1个自变量。</p>
<ul>
<li>自变量与因变量之间必须有线性关系</li>
<li>多元回归存在多重共线性，自相关性和异方差性。</li>
<li>线性回归对异常值非常敏感。它会严重影响回归线，最终影响预测值。</li>
<li>多重共线性会增加系数估计值的方差，使得在模型轻微变化下，估计非常敏感。结果就是系数估计值不稳定</li>
<li>在多个自变量的情况下，我们可以使用向前选择法，向后剔除法和逐步筛选法来选择最重要的自变量。</li>
</ul>
<h1 id="逻辑回归-（Logistic-Regression）"><a href="#逻辑回归-（Logistic-Regression）" class="headerlink" title="逻辑回归 （Logistic Regression）"></a>逻辑回归 （Logistic Regression）</h1><blockquote>
<p>逻辑回归是用来计算“事件&#x3D;Success”和“事件&#x3D;Failure”的概率。当因变量的类型属于二元（1 &#x2F; 0，真&#x2F;假，是&#x2F;否）变量时，我们就应该使用逻辑回归。</p>
</blockquote>
<p>因为在这里我们使用的是的二项分布（因变量），我们需要选择一个对于这个分布最佳的连结函数。它就是Logit函数。在上述方程中，通过观测样本的极大似然估计值来选择参数，而不是最小化平方和误差（如在普通回归使用的）。</p>
<ul>
<li>它广泛的用于分类问题。</li>
<li>逻辑回归不要求自变量和因变量是线性关系。它可以处理各种类型的关系，因为它对预测的相对风险指数OR使用了一个非线性的log转换。</li>
<li>为了避免过拟合和欠拟合，我们应该包括所有重要的变量。有一个很好的方法来确保这种情况，就是使用逐步筛选方法来估计逻辑回归。</li>
<li>它需要大的样本量，因为在样本数量较少的情况下，极大似然估计的效果比普通的最小二乘法差。</li>
<li>自变量不应该相互关联的，即不具有多重共线性。然而，在分析和建模中，我们可以选择包含分类变量相互作用的影响。</li>
<li>如果因变量的值是定序变量，则称它为序逻辑回归。</li>
<li>如果因变量是多类的话，则称它为多元逻辑回归。</li>
</ul>
<h1 id="多项式回归-（Polynomial-Regression）"><a href="#多项式回归-（Polynomial-Regression）" class="headerlink" title="多项式回归 （Polynomial Regression）"></a>多项式回归 （Polynomial Regression）</h1><blockquote>
<p>对于一个回归方程，如果自变量的指数大于1，那么它就是多项式回归方程。</p>
</blockquote>
<p>在这种回归模型中，最佳拟合线不是直线。而是一个用于拟合数据点的曲线。</p>
<ul>
<li>虽然会有一个诱导可以拟合一个高次多项式并得到较低的错误，但这可能会导致过拟合。你需要经常画出关系图来查看拟合情况，并且专注于保证拟合合理，既没有过拟合又没有欠拟合。</li>
<li>明显地向两端寻找曲线点，看看这些形状和趋势是否有意义。更高次的多项式最后可能产生怪异的推断结果。</li>
</ul>
<h1 id="逐步回归-（Stepwise-Regression）"><a href="#逐步回归-（Stepwise-Regression）" class="headerlink" title="逐步回归 （Stepwise Regression）"></a>逐步回归 （Stepwise Regression）</h1><blockquote>
<p>在处理多个自变量时，我们可以使用这种形式的回归。</p>
</blockquote>
<p>这一壮举是通过观察统计的值，如R-square，t-stats和AIC指标，来识别重要的变量。逐步回归通过同时添加&#x2F;删除基于指定标准的协变量来拟合模型。下面列出了一些最常用的逐步回归方法：</p>
<ul>
<li>标准逐步回归法做两件事情。即增加和删除每个步骤所需的预测。</li>
<li>向前选择法从模型中最显著的预测开始，然后为每一步添加变量。</li>
<li>向后剔除法与模型的所有预测同时开始，然后在每一步消除最小显着性的变量。</li>
</ul>
<p>这种建模技术的目的是使用最少的预测变量数来最大化预测能力。这也是处理高维数据集的方法之一。</p>
<h1 id="岭回归-（Ridge-Regression）"><a href="#岭回归-（Ridge-Regression）" class="headerlink" title="岭回归 （Ridge Regression）"></a>岭回归 （Ridge Regression）</h1><blockquote>
<p>岭回归分析是一种用于存在多重共线性（自变量高度相关）数据的技术。</p>
</blockquote>
<p>在多重共线性情况下，尽管最小二乘法（OLS）对每个变量很公平，但它们的差异很大，使得观测值偏移并远离真实值。岭回归通过给回归估计上增加一个偏差度，来降低标准误差。</p>
<p>在一个线性方程中，预测误差可以分解为2个子分量。一个是偏差，一个是方差。预测错误可能会由这两个分量或者这两个中的任何一个造成。</p>
<ul>
<li>除常数项以外，这种回归的假设与最小二乘回归类似；</li>
<li>它收缩了相关系数的值，但没有达到零，这表明它没有特征选择功能</li>
<li>这是一个正则化方法，并且使用的是L2正则化。</li>
</ul>
<h1 id="套索回归-（Lasso-Regression）"><a href="#套索回归-（Lasso-Regression）" class="headerlink" title="套索回归 （Lasso Regression）"></a>套索回归 （Lasso Regression）</h1><blockquote>
<p>它类似于岭回归，Lasso （Least Absolute Shrinkage and Selection Operator）也会惩罚回归系数的绝对值大小。</p>
</blockquote>
<p>此外，它能够减少变化程度并提高线性回归模型的精度。</p>
<p>Lasso 回归与Ridge回归有一点不同，它使用的惩罚函数是绝对值，而不是平方。这导致惩罚（或等于约束估计的绝对值之和）值使一些参数估计结果等于零。使用惩罚值越大，进一步估计会使得缩小值趋近于零。这将导致我们要从给定的n个变量中选择变量。</p>
<ul>
<li>除常数项以外，这种回归的假设与最小二乘回归类似；</li>
<li>它收缩系数接近零（等于零），这确实有助于特征选择；</li>
<li>这是一个正则化方法，使用的是L1正则化；</li>
</ul>
<p>如果预测的一组变量是高度相关的，Lasso 会选出其中一个变量并且将其它的收缩为零。</p>
<h1 id="弹性网络回归（ElasticNet-Regression）"><a href="#弹性网络回归（ElasticNet-Regression）" class="headerlink" title="弹性网络回归（ElasticNet Regression）"></a>弹性网络回归（ElasticNet Regression）</h1><blockquote>
<p>ElasticNet是Lasso和Ridge回归技术的混合体。</p>
</blockquote>
<p>它使用L1来训练并且L2优先作为正则化矩阵。当有多个相关的特征时，ElasticNet是很有用的。Lasso 会随机挑选他们其中的一个，而ElasticNet则会选择两个。</p>
<p>Lasso和Ridge之间的实际的优点是，它允许ElasticNet继承循环状态下Ridge的一些稳定性。</p>
<ul>
<li>在高度相关变量的情况下，它会产生群体效应；</li>
<li>选择变量的数目没有限制；</li>
<li>它可以承受双重收缩。</li>
</ul>
]]></content>
      <tags>
        <tag>转载</tag>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘-距离计算</title>
    <url>/2017/03/03/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<blockquote>
<p>计算样本间的“距离”(Distance) ，估算分类时不同样本之间的相似性度量(Similarity Measurement)。</p>
</blockquote>
<ol>
<li>欧氏距离</li>
<li>曼哈顿距离</li>
<li>切比雪夫距离</li>
<li>闵可夫斯基距离</li>
<li>标准化欧氏距离</li>
<li>马氏距离</li>
<li>夹角余弦</li>
<li>汉明距离</li>
<li>杰卡德距离&amp; 杰卡德相似系数</li>
<li>相关系数&amp; 相关距离</li>
<li>信息熵</li>
</ol>
]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>熵</title>
    <url>/2017/03/01/%E7%86%B5/</url>
    <content><![CDATA[<blockquote>
<p>熵 （Entropy）: 热力学第二定律，熵反映了状态的无序程度。范围（0~1）值越大越混乱。</p>
</blockquote>
<p>物体从一种有序转变为另一种有序状态，必经过一个无序状态。无序状态程度即为熵。而为了消除这种无序使其有序，需要额外的能量。在信息中则是变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。 </p>
<p>一个系统越是有序，信息熵就越低；反之，一个系统越是混乱，信息熵就越高。所以，信息熵也可以说是系统有序化程度的一个度量。</p>
<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://61.91.161.217/chart?cht=tx&chl={H_s={\sum^{n}+_{i=1}p_iI_e}={-\sum^{n}+_{i=1}{p_ilogp_i}"
                      style="border:none;"
                >

<p>而我们也可能是宇宙由起点至终点两个有序状态中的熵。（热寂宇宙末日假说，也是在熵的概念上提出的）</p>
<pre><code>熵的概念也被广泛应用到各个领域（热力学、统计学、信息学、天文学）
</code></pre>
]]></content>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>概率学-随机变量</title>
    <url>/2017/03/02/%E6%A6%82%E7%8E%87%E5%AD%A6-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>作者：Vamei 出处：<a class="link"   href="http://www.cnblogs.com/vamei" >http://www.cnblogs.com/vamei<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 欢迎转载，也请保留这段声明。谢谢！</p>
</blockquote>
<blockquote>
<p>提示：若无法正确显示 LaTeX 公式<br>在hosts 文件中添加</p>
</blockquote>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">61.91.161.217	chart.googleapis.com</span><br></pre></td></tr></table></figure></div>

<p>我们了解了“样本空间”，“事件”，“概率”。样本空间中包含了一次实验所有可能的结果，事件是样本空间的一个子集，每个事件可以有一个发生的概率。概率是集合的一个“测度”。</p>
<p>这一讲，我们将讨论随机变量。	<strong>随机变量(random variable)</strong>	的本质是一个函数，是从样本空间的子集到实数的映射，将事件转换成一个数值。根据样本空间中的元素不同(即不同的实验结果)，随机变量的值也将随机产生。可以说，随机变量是“数值化”的实验结果。在现实生活中，实验结果可以是很“叙述性”，比如“男孩”，“女孩”。在数学家眼里，这些文字化的叙述太过繁琐，我们为什么不能拿数字来代表它们呢？</p>
<p>(数学家恐怕是很难成为文学家吧？)</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_01_1.jpg"
                     
                ></p>
<h1 id="离散随机变量"><a href="#离散随机变量" class="headerlink" title="离散随机变量"></a>离散随机变量</h1><p>在连续掷两次硬币的例子中，样本空间为:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= \Omega = \{ HH, HT, TH, TT \}"
                      style="border:none;"
                >


<p>这样的实验结果可以有很多数值化的方法，比如定义HH为400， HT为30， TH为0.2，TT为1。要注意的是，这里是用某个数字来代表样本空间的某个元素，这个数字并不是概率值。</p>
<p>如何对样本空间的元素数值化是根据现实需求的。比如说，根据出现正面的次数，我们将赢取不同的奖励。那么在分析时，可以取“结果中正面的次数”为随机变量。这样一个随机变量将有2, 1, 0三种可能的取值。该随机变量只能取离散的几个孤立值，这样一种随机变量称为	<strong>离散随机变量</strong>	。</p>
<p>映射关系如下:</p>
<table>
<thead>
<tr>
<th align="center">实验结果</th>
<th align="center">随机变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HH</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">HT</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">TH</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">TT</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>我们通常用一个大写字母来表示一个随机变量，比如X。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_01_2.png"
                     
                ></p>
<p>如果样本空间中的每个结果等概率，那么随机变量取值可能性为:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= P(X=2) = 0.25"
                      style="border:none;"
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= P(X=1) = 0.5"
                      style="border:none;"
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= P(X=0) = 0.25"
                      style="border:none;"
                >

<p>当X取 0 , 1 , 2 之外的值时，概率为 0 。注意到， X&#x3D;1 这个事件，实际上包含了两个元素，HT, TH。因此， X&#x3D;1 出现的概率较高。所有可能取值的概率和为 1 。</p>
<p>表示了随机变量在不同取值下的概率，称为	<strong>概率质量函数(PMF, probability mass function)</strong>	。我们将看到其他的表示概率分布的方式。</p>
<h1 id="累积分布函数"><a href="#累积分布函数" class="headerlink" title="累积分布函数"></a>累积分布函数</h1><p>上面的函数列出了每个取值的对应概率。等价的，我们可以用	<strong>累积分布函数(CDF, cumulative distribution function)</strong>	来表示随机变量的概率分布状况。在累积分布函数，我们列出的，总是随机变量X，在小于x的这个区间的概率和。当x增大时，X &lt; x包含的结果增加，概率和也相应增加。当x为正无穷时，实际上是所有情况的概率和，那么累积分布函数为1。</p>
<p>严格的定义为:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= F(x) = P(X \le x), -\infty < x < \infty"
                      style="border:none;"
                >

<p>我们可以绘制上面例子的CDF。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_01_3.png"
                     
                ></p>
<p>这样的累积分布函数似乎并不比概率质量函数来得方便。但在后面，我们会很快看到它的优势。即它可以同时用于离散随机变量和连续随机变量。</p>
<p>上面的图片可以用如下代码生成:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># By Vamei</span></span><br><span class="line"><span class="comment"># Plot the CDF of total number of heads in two flips</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.75</span>, <span class="number">0.75</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax  = plt.subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(x, y)</span><br><span class="line">ax.set_ylim([-<span class="number">0.1</span>, <span class="number">1.1</span>])</span><br><span class="line">ax.set_title(<span class="string">&quot;CDF, total number of heads&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>
<h1 id="连续随机变量"><a href="#连续随机变量" class="headerlink" title="连续随机变量"></a>连续随机变量</h1><p>随机变量还可以是连续取值，这样的随机变量称为	**连续随机变量(continuous random variable)**。比如，一个随机变量，可以随机的取0到1的任意数值。</p>
<p>当这样取值时，任意区间能实际上都有无穷多个结果。比如，我们测量温度，可以有1度和2度，但两者之间，还可以有1.1度，1.003度，1.658度等等无穷种结果。这样的话，每个结果的可能性都是无穷小。我们讨论的是某个区间内的概率，即<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= P(a<X<b)"
                      style="border:none;"
                >，而不是具体某一数值的概率。在这样的情况下，分到各个结果的概率都无限趋近于0。显然，我们无法用概率质量函数来描述连续随机变量的分布。</p>
<p>我们这里遇到的困境是现代数学的一个相当的困扰。考虑一个线段，它是点的集合，并且有“长度”这样的测度。然而，线段上有无穷个多个点。讨论“每个点的长度”是完全没有意义的。将线段换成区间，将点换成取值，将长度换成概率，我们发现这两个问题异常相似。另一方面，我们知道，可以从线段上截取某一小段，而这一小段是可以有“长度”的。连续随机变量的概率定义，正依赖于此：对于连续随机变量，我们只讨论某个区间，比如从1.2到1.4这一区间的概率，而不讨论具体某个点，比如1.3的概率。 </p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_01_4.jpg"
                     
                ></p>
<p> 观察一个很简单的连续随机分布。假设我们有一个随机数生成器，产生一个从0到1的实数，每个实数出现的概率相等。这样的一个分布被称为	**均匀分布(uniform distribution)**。直觉告诉我们，相同长度的每一段区间，对应的概率都相同。由此，[0, 0.5]是整个区间的一半，概率为1&#x2F;2。对于均匀分布来说，概率正好和区间长度这一测度等同。</p>
<p>我们尝试用更正式的方式来描述分布。累积分布函数本身就表示随机变量在一个区间概率，所以可以直接用于连续随机变量。即</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= F(x) = P(X \le x), - \infty < x < \infty"
                      style="border:none;"
                >

<p>对于均匀分布来说，它的累积分布函数是:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= F(x) = F(x) = 0, x < 0"
                      style="border:none;"
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= F(x) = F(x) = x, 0 \le x \le 1"
                      style="border:none;"
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= F(x) = F(x) = 1, x > 1"
                      style="border:none;"
                >

<p>它类似从线段的一头到某一点的“长度”。这样，我们就知道了从起点到每一点的长度。如果我们想知道某个特定区间[a, b]的概率，它就是F(b) - F(a)。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_01_5.png"
                     
                ></p>
<p>借用“无穷小”的概念，我们可以构建	<strong>概率密度函数(PDF，probability density function)</strong>	。粗糙的讲，我们在某个点附近取一个“无穷小”段，该小段的区间长度为dx，而这个“无穷小”段对应的概率为dF，那么该点的概率密度为dF&#x2F;dx。这实际上是微积分的领域。</p>
<p>概率密度函数可以代替累积分布函数，来表示一个连续随机变量的概率分布:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= f(x) = \frac{dF(x)}{dx}"
                      style="border:none;"
                >

<p>即密度函数是累积分布函数的微分，或者说，</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= F(x) = \int_{-\infty}^x f(u)du"
                      style="border:none;"
                >

<p>即累积分布函数是密度函数从负无穷到x的积分。</p>
<p>密度函数满足:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= \int_{-\infty}^{+\infty} f(u)du = 1"
                      style="border:none;"
                >

<p>均匀分布的密度函数可以写成:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://chart.googleapis.com/chart?cht=tx&chl= f(x) = \left\{ \begin{array}{l} 1, 0 \leq x \leq 1 \\ 0, x<0 \, or \, x>1 \end{array}\right."
                      style="border:none;"
                >

<p>可以画出该密度函数</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/2017/2017_03_01_6.png"
                     
                ></p>
<p>对一个函数的积分，获得的是该函数曲线下的面积。因此，<strong>密度曲线下某个区间的面积</strong>，就是密度概率函数的积分，代表了随机变量在该区间的概率。概率密度函数就可以非常直观的通过“面积”，来表示概率的大小。</p>
<p>从负无穷到正无穷积分，就代表了所有可能结果的概率和，即为1。</p>
<p>上面的图片可以利用下面代码生成:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># By Vamei</span></span><br><span class="line"><span class="comment"># Density function for uniform distribution</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(x, y)</span><br><span class="line">ax.set_xlim([-<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">ax.set_ylim([-<span class="number">0.1</span>, <span class="number">1.1</span>])</span><br><span class="line">ax.set_title(<span class="string">&quot;density function for uniform distribution&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随机变量，随机变量的概率分布</p>
<p>累积分布函数</p>
<p>密度函数</p>
]]></content>
      <tags>
        <tag>转载</tag>
        <tag>概率学</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 拜占庭将军问题</title>
    <url>/2026/01/14/%E7%AE%97%E6%B3%95-%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>拜占庭将军问题(Byzantine Generals Problem)</strong> 是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。</p>
<p>在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>莱斯利·兰波特在其论文中描述了如下问题：</p>
<blockquote>
<p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/ChaoSBYNN/image-hosting/main/program/algorithm/Byzantine_Generals.png"
                     
                ></p>
<p>若假设所有六名将军协同进攻，则战斗获胜（左）；有两名将军（叛徒）谎称打算进攻，但实际上撤退，则战斗失败（右）。</p>
<p>系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。</p>
<p>由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。</p>
<p>假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。</p>
<p>上述的故事映射到计算机系统里，将军便成了计算机，而信差就是通信系统。虽然上述的问题涉及了电子化的决策支持与信息安全，却没办法单纯的用密码学与数字签名来解决。因为电路错误仍可能影响整个加密过程，这不是密码学与数字签名算法在解决的问题。因此计算机就有可能将错误的结果提交去，亦可能导致错误的决策。</p>
<h2 id="早期的解决方案"><a href="#早期的解决方案" class="headerlink" title="早期的解决方案"></a>早期的解决方案</h2><p>在1982年的论文中提过几个解决方案。方案中把问题往下拆解，认为在“拜占庭将军”的问题可以在“军官与士官的问题”里解决，以降低将军问题的发生。而所谓的“军官与士官的问题”，就是探讨军官与他的士官是否能忠实实行命令。</p>
<ul>
<li>其中一个解决方案认为即使出现了伪造或错误的消息。只要有问题的将军的数量不到三分之一，仍可以达到“拜占庭容错”。原因是把同样的标准下放到“军官与士官的问题”时，在背叛的军士官不足三分之一的情况下，有问题的军士官可以很容易的被纠出来。比如有军官A，士官B与士官C。当A要求B进攻，却要求C撤退时。就算B与C交换所收到的命令，B与C仍不能确定是否A有问题，因为B或C可能将窜改了的消息传给对方。以函数来表示，将军的总数为n，n里面背叛者的数量为t，则只要n &gt; 3t就可以容错。</li>
<li>另一个解决方案需要有无法消去的签名。在现今许多高度信息安全要求的关键系统里，数字签名就经常被用来实现拜占庭容错，找出有问题的将军。然而，在生命攸关系统里，使用错误侦测码就可以大幅降低问题的发生。无论系统是否存在拜占庭将军问题。所以需要做密码运算的数字签名也不一定适合这类系统。[</li>
<li>假如上述两个解决方案里，将军们无法直接通信时，该论文亦有进一步的解决方案。</li>
</ul>
<p>此外，1980年代还有其他用来达到拜占庭容错的架构被提出，如：FTMP、MMFCS 与 SIFT。</p>
<h2 id="实用拜占庭容错"><a href="#实用拜占庭容错" class="headerlink" title="实用拜占庭容错"></a>实用拜占庭容错</h2><p><strong>实用拜占庭容错(Practical Byzantine Fault Tolerance, PBFT)</strong> 是由Miguel Castro和Barbara Liskov在2002年提出的一种分布式系统容错协议。</p>
<p>1999年，卡斯托（Miguel Castro）与利斯科夫（Barbara Liskov）提出了实用拜占庭容错（PBFT）算法。该算法能提供高性能的运算，使得系统可以每秒处理成千的请求，比起旧式系统快了一些。</p>
<p>而在PBFT之后，许多用于拜占庭容错（BFT）的通信协议也被提出来改善其通信的强健性与效率。比如Q&#x2F;U、HQ、Zyzzyva与ABsTRACTs …，用来提升效率。而Aardvark与RBFT是用来加强强健性。另外，Adapt则使用原有的BFT协议做调适，以强化其效率与强健性。BFT协议更可以借由加入可任务的单元，以减少发出副本的次数。比如：A2M-PBFT-EA与MinBFT。</p>
<h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><p>在点对点式数字货币系统比特币里，比特币网络的运作是平行的（parallel）。各节点与终端都运算著区块链来达成工作量证明（PoW）。工作量证明的链接是解决比特币系统中拜占庭问题的关键，避免有问题的节点（即前文提到的“反叛的将军”）破坏数字货币系统里交易帐的正确性，是对整个系统的运行状态有着重要的意义。</p>
<p>在一些飞行器（如波音777）的系统中也有使用拜占庭容错。而且由于是即时系统，容错的功能也要能尽快回复，比如即使系统中有错误发生，容错系统也只能做出一微秒以内的延迟。</p>
<p>一些航天飞机的飞行系统甚至将容错功能放到整个系统的设计之中。</p>
<p>拜占庭容错机制是将收到的消息（或是收到的消息的签名）转交到其他的接收者。这类机制都假设它们转交的消息都可能含有拜占庭问题。在高度安全要求的系统中，这些假设甚至要求证明错误能在一个合理的等级下被排除。当然，要证明这点，首先遇到的问题就是如何有效的找出所有可能的、应能被容错的错误。这时候会试着在系统中加入错误插入器。</p>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Program</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义DNS拦截</title>
    <url>/2024/07/07/%E8%87%AA%E5%AE%9A%E4%B9%89DNS%E6%8B%A6%E6%88%AA/</url>
    <content><![CDATA[<blockquote>
<p>在本机上自定义DNS拦截通常涉及到修改系统的DNS设置，以使用自定义的DNS服务器或应用程序来拦截和修改DNS查询请求。以下是一些常见的方法来实现本机DNS拦截：</p>
</blockquote>
<ol>
<li><p><strong>修改系统DNS设置</strong>：</p>
<ul>
<li>对于Windows系统，可以在网络适配器的属性中修改DNS服务器地址。</li>
<li>对于macOS，可以在系统偏好设置中的网络部分修改DNS设置。</li>
</ul>
</li>
<li><p><strong>使用本地DNS服务</strong>：</p>
<ul>
<li>运行一个本地DNS服务器，如BIND、dnsmasq或Unbound，然后配置系统使用该服务器作为DNS解析的首选服务器。</li>
</ul>
</li>
<li><p><strong>使用代理软件</strong>：</p>
<ul>
<li>使用如Squid、Shadowsocks或V2Ray等代理软件，它们可以配置为拦截DNS请求并将其转发到指定的DNS服务器。</li>
</ul>
</li>
<li><p><strong>修改<code>/etc/hosts</code>文件</strong>：</p>
<ul>
<li>在Linux或macOS上，可以在<code>/etc/hosts</code>文件中添加自定义的域名和IP映射，以拦截特定的域名解析。</li>
</ul>
</li>
<li><p><strong>使用操作系统的网络策略</strong>：</p>
<ul>
<li>在Windows上，可以使用组策略编辑器或注册表来设置特定的DNS拦截规则。</li>
<li>在macOS上，可以使用Network Configuration Profiles来设置DNS拦截。</li>
</ul>
</li>
<li><p><strong>使用第三方DNS拦截工具</strong>：</p>
<ul>
<li>有些第三方应用程序专门用于DNS拦截，如AdGuard、Pi-hole等。</li>
</ul>
</li>
<li><p><strong>使用防火墙规则</strong>：</p>
<ul>
<li>配置防火墙规则来拦截DNS查询请求，并将其重定向到自定义的DNS服务器。</li>
</ul>
</li>
<li><p><strong>使用VPN</strong>：</p>
<ul>
<li>通过VPN连接，可以强制所有流量通过VPN服务器，该服务器可以配置为使用自定义的DNS设置。</li>
</ul>
</li>
<li><p><strong>编程实现拦截</strong>：</p>
<ul>
<li>对于高级用户，可以通过编写脚本或程序来拦截系统发出的DNS查询，并根据需要进行处理。</li>
</ul>
</li>
</ol>
<blockquote>
<p>修改DNS设置可能会影响网络连接的稳定性和安全性，因此在实施任何更改之前，请确保了解可能的后果，并始终从可信的来源获取DNS服务器地址。此外，一些方法可能需要管理员权限或特定的技术知识。</p>
</blockquote>
]]></content>
      <categories>
        <category>Program</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>[译]如何用人类的方式进行 Code Review</title>
    <url>/2024/06/22/%E8%AF%91-%E5%A6%82%E4%BD%95%E7%94%A8%E4%BA%BA%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C-Code-Review/</url>
    <content><![CDATA[<h1 id="【译】如何用人类的方式进行-Code-Review"><a href="#【译】如何用人类的方式进行-Code-Review" class="headerlink" title="【译】如何用人类的方式进行 Code Review"></a>【译】如何用人类的方式进行 Code Review</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文是 Google 工程师 Michael Lynch 的个人博客文章：</p>
<ul>
<li><a class="link"   href="https://mtlynch.io/human-code-reviews-1/" >https://mtlynch.io/human-code-reviews-1/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://mtlynch.io/human-code-reviews-2/" >https://mtlynch.io/human-code-reviews-2/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>读了之后深有感触，目前国内大多数公司对于 Code review 的重视程度还远远不够，大多数人都把它视为一件麻烦事。即使在有 Code review 流程的团队，也缺乏相关经验，而且目前中文技术圈关于 Code review 的文章真的太少了，所以在这里翻译这篇个人认为很不错的文章给大家看。</p>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近，我读了很多关于 code review 最佳实践的文章。但我发现大多数文章都着重于教你如何找到代码中的 bug，而几乎完全忽略了 code review 的其他部分。比如你沟通的方式是否足够建设性及专业呢？无所谓！只要找到所有 bug，剩下的就自生自灭去吧。</p>
<p>所以我获得了一个启示：如果这些跟代码相关，为什么不能以一种更浪漫的形式呢？于是，我想把我的新书介绍给开发者们，以帮助他们以及他们热爱的生活。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-fe43e2fe9e616f34835d8e5decf35051_720w.jpg"
                      alt="封面"
                ><figcaption>封面</figcaption></figure></p>
<p>我这本革命性的书将会教你一些<em>实用的技巧</em>，以帮助你最大限度地找到你同伴身上的所有缺点。但它不会包括以下内容：</p>
<ul>
<li>如何与你的同伴沟通，让你们相互理解、产生共鸣</li>
<li>如何帮助你的同伴找到他们的不足之处</li>
</ul>
<p>这本书适合你吗？我仿佛听到了你喊“不不不不！”</p>
<p>所以，为什么我们一定要用那种（没人性的）方式来讨论 code review 呢？</p>
<p>唯一的回答就是，我是在遥远的未来读这本书的，那个时代所有的开发者都是机器人。在那个世界里，你的团队小伙伴很喜欢冰冷的、生硬的、无情的评论，因为它们都是机器人，阅读这些评论能温暖它们的机械之心。</p>
<p>但我想做一个大胆的假设，你现在就想改善你们团队的 code review，而你们的团队成员都是活生生的人类。我还想做一个更大胆的假设，那就是 “与同事建立积极的关系” 本身就是一个目的，而不是简单地调整某个变量，以减少 bug。在这种情况下，你的 code review 会发生怎样的变化呢？</p>
<p>我的这篇文章会介绍一些技巧，让 code review 不再仅仅是一种技术上的流程，更是一种社交性的流程。</p>
<hr>
<h2 id="什么是-Code-Review？"><a href="#什么是-Code-Review？" class="headerlink" title="什么是 Code Review？"></a>什么是 Code Review？</h2><p>“Code Review” 这个术语实际上包含了一个很大范围内的活动，从最简单的读同伴的代码，到 20 个人正襟危坐在会议室里一行一行地剖析代码，都可以称为 “Code Review”。在后文里，我用这个术语来指代一个正式且书面化的过程，但不是像内部 Code Review 会议那样重量级。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-3a5ef146bc70233b01c11210fbaffc42_720w.jpg"
                      alt="What"
                ><figcaption>What</figcaption></figure></p>
<p>参与 review 的人有两种，一种是<em>作者（author）</em>，也就是代码的编写者和 review 的发起者；另一种是<em>评审者（reviewer）</em>，也就是阅读代码，并且决定代码是否可以合并进入团队代码库的人。评审者可以有多个人，但后文里我会假设你是唯一的评审者。<br>在 review 开始之前，作者必须创建一个<em>变更列表（changelist）</em>。它含有一系列的修改，而作者想要把这些修改合并进入代码库。<br>当作者把变更列表交给评审者之后，review 就开始了。review 是一种轮转的方式进行的，每一轮都是一次作者和评审者之间的往返：作者提交变更列表，评审者对这些变更作出反馈。每个 review 都会有一轮或多轮。<br>当评审者<em>同意（approve）</em>这些更改之后，code review 就结束了。这个时候一般会评论一句 “LGTM”，也就是 “looks good to me” 的缩写。</p>
<h2 id="这有哪些难点？"><a href="#这有哪些难点？" class="headerlink" title="这有哪些难点？"></a>这有哪些难点？</h2><p>设想一下，如果一名程序员给你递交了一份他们自认为很赞的变更列表，而你回复了一大堆问题，告诉他这份变更列表并不好，这里就很容易让人感到冒犯。</p>
<blockquote>
<p>这就是为啥我从来不怀念 IT 行业的原因，程序员都是些很不讨人喜欢的人… 要是放在航天行业，这些高估自己能力的人坟头草都已经一米多高了.<br>— Philip Greenspun，ArsDigita 联合创始人</p>
</blockquote>
<p>对于代码的作者来说，评论或者批评他们的代码，很容易被视为一种暗示，即他们不是一名称职的程序员。虽然 code review 是一个很好的机会来分享知识、做一些工程上的抉择，但如果 code review 被视为人身攻击，那么这些好处都不会发生。<br>就算上面这种情况不会发生，你也会遇到沟通的问题，把你脑子里的想法用文字准确地表述下来是很具有挑战性的，因为别人很容易产生误解。代码的作者听不到你的语音语调，也看不到你的肢体语言，所以清楚的写下你的反馈是一件很重要的事情。对于戒备心理很强的代码作者而言，一句无意的 “你忘了关掉 file handle”，可以被理解为，“你竟然忘了关闭 file handle？你这个蠢猪。”</p>
<hr>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p><em>让电脑做重复的事情</em></p>
<p>在会议和邮件的交替轰炸中，你能专注于代码的时间实际上是很稀有的，你的精神耐受力甚至更短。读团队小伙伴的代码需要大量的精力和高度的精神集中，所以不要把精力花在计算机可以代替我们做的事情上，特别是那些计算机做得更好的事情。<br>空格问题就是一个明显的例子。比较一下，评审者靠肉眼找到一处缩进错误，然后协助代码作者修正它，和直接使用一个代码格式化工具，哪一个耗费的时间更少？</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-76d895dcd60cf89202e4e8058f415be6_720w.jpg"
                      alt="review"
                ><figcaption>review</figcaption></figure></p>
<p>表格的右边之所以啥都不需要干，是因为作者已经使用了一个自动格式化工具，在每次保存代码时，都会自动执行。最坏的情况下，作者没检查代码就提交 review 了，持续集成系统也会报错，这样作者就可以在评审者发现之前就修复这个问题。<br>在你的 code review 中找到可以被自动化的地方，下面是一些常见的点：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-ae0880384bd53cbad9e6000b36b43c2c_720w.jpg"
                      alt="way"
                ><figcaption>way</figcaption></figure></p>
<p>自动化可以让作为评审者的你做更多有意义的事情。当你可以不需要在意某大类问题（例如 imports 的顺序、源文件的命名约定），你就可以有更多的精力关注其他更有趣的问题，例如函数错误或者可读性差的问题。<br>自动化同样可以让代码的作者受益，它可以让作者快速地在几秒钟（而不是几小时）内找到一些粗心产生的低级错误。快速的错误反馈产生的修复成本也很低，因为代码作者的脑中依然有这段代码的上下文。另外，来自电脑的报错相比于来自评审者的纠错，从自尊心上讲，更容易让人接受。<br>你的团队应该立刻把这样一套自动化工具加入到 code review 的工作流中（比如 Git 的 pre-commit hook，还有 Github 的 webhook）。如果 review 需要评审者手工去做这些事情，那就丧失了很多益处。代码的作者总是会忘记遵守某些东西，以至于你必须重复地检查很多简单又低级的问题，而这些问题本应是自动化工具代替你做的。</p>
<hr>
<h2 id="用代码风格规范来解决代码风格的争议"><a href="#用代码风格规范来解决代码风格的争议" class="headerlink" title="用代码风格规范来解决代码风格的争议"></a>用代码风格规范来解决代码风格的争议</h2><p>关于代码风格的争吵在 code review 中是非常浪费时间的。一致的代码风格当然是非常重要的，但 code review 的时间并不该浪费在讨论圆括号该放在哪里。最好的做法是通过维护一份代码风格规范来避免这里的争吵。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic2.zhimg.com/80/v2-275261322f32c3e0dce033e76a7b9d11_720w.jpg"
                      alt="争吵"
                ><figcaption>争吵</figcaption></figure></p>
<p>一份优秀的代码风格规范，不仅仅定义了诸如命名规范、空格规范这些表面上的东西，同样也应该定义如何使用语言的某些特性。例如 JavaScript 和 Perl，它们具有函数式编程的特性 —— 也就是说它们提供了多种方式来完成同一件事情。代码规范里应该只定义<em>一种正确的方式</em>，这样的话才能让你的团队不会一半的人用某些语言特性，而另一半的人用完全不同的其它特性。<br>当你有了一份风格规范后，你就再也不需要把时间浪费在讨论谁的命名规范最好这种问题上了，只要按照规范来就可以。如果你的风格指南没有针对某个特殊问题作出规定，那么它在 review 过程中不应该被讨论。如果遇到规范中没有涵盖的问题，并且这个问题足够重要，那么可以与团队成员进行讨论，然后将讨论结果记录在代码风格规范中，这样你们以后就不用再讨论了。</p>
<h3 id="选项一：使用一份已有的代码规范"><a href="#选项一：使用一份已有的代码规范" class="headerlink" title="选项一：使用一份已有的代码规范"></a>选项一：使用一份已有的代码规范</h3><p>在网上搜一搜，就能找到不少已有的代码规范，其中 Google Style Guide 是最广为人知的。当然，如果它不适合你的话，你也可以用别的规范。使用已有的规范，你可以直接获得收益，而不需要从零开始创建一份规范。</p>
<p>直接复用一份现成的规范，缺点在于，这些规范可能是为了原团队中某些特殊需求而优化的。比如 Google 的代码规范，对于新的语言特性十分保守，因为他们有一个巨大无比的代码库，这些代码可能会运行在很多地方，从家庭路由器，到最新款的 iPhone 上。如果你所在的是只有四个人和一款产品的小型初创公司，那么你可能会更喜欢使用最尖端的语言特性或者扩展。</p>
<h3 id="选项二：渐进式地建立你自己的代码规范"><a href="#选项二：渐进式地建立你自己的代码规范" class="headerlink" title="选项二：渐进式地建立你自己的代码规范"></a>选项二：渐进式地建立你自己的代码规范</h3><p>如果不想直接使用现成的代码规范，当然可以自己创建一份。每当 code review 时产生了关于代码风格的争议，就把这个问题提给团队所有成员，来决定正式的标准。达成一致后，把这个标准写入你的代码规范中。</p>
<p>我一般喜欢把我团队的代码风格规范以 Markdown 的格式托管在版本控制软件之下（比如 Github pages）。这样，对规范的任何修改都会经过一个正式的 review 流程 —— 必须有某人明确地批准修改，团队中的任何人都有机会提出疑虑。用 Wiki 和 Google Docs 当然也是可以的。</p>
<h3 id="选项三：混合式的方法"><a href="#选项三：混合式的方法" class="headerlink" title="选项三：混合式的方法"></a>选项三：混合式的方法</h3><p>结合选项一和选项二，你可以用一份现成的代码规范，在它的基础上，建立你自己的代码格式规范。比如 Chromium C++ style guide 就是个很好的例子，它建立在 Google C++ style 的基础之上，但有它自己修改或添加的一些规则。</p>
<hr>
<h2 id="立刻开始-Review"><a href="#立刻开始-Review" class="headerlink" title="立刻开始 Review"></a>立刻开始 Review</h2><p>code review 应该被视作高优先级的事情。你阅读代码并提供反馈意见时，花点时间无所谓，但 review 必须要立刻开始 —— 最好是在几分钟内。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-6af6e2929dd5ab99294226aaffebcc27_720w.jpg"
                      alt="How"
                ><figcaption>How</figcaption></figure></p>
<h2 id="Code-Review-的接力赛"><a href="#Code-Review-的接力赛" class="headerlink" title="Code Review 的接力赛"></a>Code Review 的接力赛</h2><p>一旦团队成员提交给了你一份变更列表，这可能意味着在你的 review 完成之前，他们的工作会被阻塞住。虽然在理论上，版本控制系统可以让代码的作者切换到新的分支，然后把审核中的提交合并到新的分支，继续工作。但实际上，只有很少的人能高效率地做这些事情，因为这需要同时同步三个分支（译者注：master、review 中的分支、新分支）的变动。</p>
<p>当你立即开始 code review，你就创造了一个良性循环。你一轮 review 所需要花的时间，和变更列表的大小及复杂度成正相关。这就鼓励了代码的作者提交小范围的变更列表，这也让你的 review 变得更轻松愉悦，你的 review 也会更快，形成一个正向循环。</p>
<p>想象一下，你的小伙伴实现了一个新功能，需要改变 1000 行代码。 如果他们知道你可以在大约 2 小时内查看 200 行的更改列表，则可以将其功能分解为多个变更，每个约 200 行，于是你就可以在一两天内 review 完毕。 但是，如果你每个 review 都是拖了一天之后才开始 ，那么就需要花费几乎一周的时间才能做完 review。你的小伙伴当然不想就呆坐在那里一周，因此他们就会偏向于提交更大体积的 review，比如500-600行。 这些大的 review 要花的时间更多，而且会产生质量更差的反馈意见（因为你要在脑内记住 600 行的变化而不是 200 行）。</p>
<p>一轮 review 的最大周期应该限于一个工作日，如果你因为某些优先级更高的事情忙成狗了，那么请你告诉你的小伙伴，让他们把 review 的任务交给别人。如果每个月都有几次这样的情况发生，那就说明你的团队需要减速了，这样才能保证团队的开发不会失去控制（译者注：在中国就别想了）</p>
<hr>
<h2 id="自顶向下的方法"><a href="#自顶向下的方法" class="headerlink" title="自顶向下的方法"></a>自顶向下的方法</h2><p>你在一轮 review 中提出的问题越多，代码作者感到的压力就会越大。具体数量的限制因人而异，但一般一轮 review 提出的问题应该限制在 20 - 50 个之内。</p>
<p>如果你担心评论太多，把代码原作者淹没在茫茫的问题之中，那么建议你在早期的 review 中先关注一些高层次的问题，例如重新设计类的接口，以及分解复杂函数等。直到这些问题得到解决，再去关注低层次的问题，比如变量命名，或者代码注释的清晰程度。</p>
<p>代码原作者关注高层次问题时，一些低层次的问题可能会被忽视。把这些低层次问题暂时延后到下一轮 review，就可以避免重复检查这些低级问题，也可以节省代码原作者的时间。这个小技巧可以让你在 review 过程中对应该关注的层面进行细分，帮助你和原作者以一种更加清晰、系统的方式处理更改列表。</p>
<hr>
<h2 id="多写代码示例"><a href="#多写代码示例" class="headerlink" title="多写代码示例"></a>多写代码示例</h2><p>在理想的世界里，代码作者应该会很感谢他们收到的每一个 review，因为这是一个很好的学习机会，并且让他们纠正了错误。但在现实中，有诸多因素可能会导致作者负面地看待这些 review，并且反感你对他们代码的评论。也许他们正面临着压力，要在最后期限之前完成任务，所以除了即刻批准以外的任何事情都会被视为一种阻碍。 也许你们之间没有太多的合作经验，所以他们不相信你的反馈是好意的。</p>
<p>这有一个好方法，可以在 review 过程中舒缓作者的心情，那就是在 review 期间找机会送给他们礼物。所有开发者都喜欢接受的礼物是什么？那当然是，代码示例。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-a375be6b9b62daa8b708b5854ee6be76_720w.jpg"
                      alt="Good"
                ><figcaption>Good</figcaption></figure></p>
<p>你可以通过写一些示例代码来减轻作者的负担，以展现出你作为评审者的慷慨大度。</p>
<p>比如说，你有一个同事并不是很熟悉 Python 的列表推导特性，他给你发了如下的代码：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">urls = []</span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">  url = <span class="string">&#x27;https://&#x27;</span></span><br><span class="line">  url += domain</span><br><span class="line">  url += path</span><br><span class="line">  urls.append(url)</span><br></pre></td></tr></table></figure></div>

<p>作为回复，一句 “我们能不能用列表推导来简化这儿的代码？” 可能会让他们感到恼怒，因为他们或许需要花 20 分钟来搜索他们之前从没用过的东西。</p>
<p>但如果收到的评论是像下面这样，他们应该会很高兴：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">可以考虑这样简化代码：</span><br><span class="line">urls = [<span class="string">&#x27;https://&#x27;</span> + domain + path <span class="keyword">for</span> path <span class="keyword">in</span> paths]</span><br></pre></td></tr></table></figure></div>

<p>这个小技巧不仅限于单行代码。我会经常创建自己的分支来向原作者展示大量的概念，比如拆解一个大的函数，或者添加单元测试来覆盖额外的边界情况。</p>
<p>这个小技巧会让你得到明确的、无争议的改进。在上面的示例中，很少有人会反对将代码行数减少83％。相比之下，如果你写了个冗长的例子来展示你个人品味上觉得 “更好” 的示例（例如，代码风格），这会使你看起来更一意孤行，而不是开明大方。</p>
<p>当然示例代码也不能写得太多了，如果你为原作者写了几乎覆盖整个变更列表的示例代码，那就表示你不认为他们有能力编写自己的代码。</p>
<hr>
<h2 id="不要说“你”"><a href="#不要说“你”" class="headerlink" title="不要说“你”"></a>不要说“你”</h2><p>这听起来有些奇怪，但请相信我说的：在 code review 中，不要使用 “你” 这个词。</p>
<p>你在 review 中所做的评论应该是基于 “什么使得代码更好”，而不是 “谁提出了这个想法”。你的小伙伴在他们的变更列表上花费了大量的精力，他们当然会为他们所做的工作感到自豪，所以当收到批评时，自然会产生戒备心理。</p>
<p>你应该用一种最不会产生戒备心理的方式来评论代码。要记住你批评的是代码，而不是代码的作者。当代码的作者在评论里看到 “你” 这个词的时候，会把注意力从代码上转移到他们自己身上。这会加剧他们抗拒你的评论的可能性。</p>
<p>比如说下面这个无恶意的评论：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">你把 &#x27;successfully&#x27; 拼错了</span><br></pre></td></tr></table></figure></div>

<p>作者可能会把它读成两种意思：</p>
<ul>
<li>含义一：嘿，好兄弟！你把 ‘successfully’ 拼错了，但我认为你这么聪明，这应该只是一处小粗心吧！</li>
<li>含义二：你把 ‘successfully’ 拼错了！白痴！</li>
</ul>
<p>相比之下，如果你的评论里没有提及 “你” 这个词：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sucessfully -&gt; successfully</span><br></pre></td></tr></table></figure></div>

<p>这条评论就只是简单地纠正了拼写错误，没有包含任何对于作者的评价。<br>幸运的是，在评论中去掉 “你” 这个词非常容易。</p>
<h3 id="选项一：用-“我们”-代替-“你”"><a href="#选项一：用-“我们”-代替-“你”" class="headerlink" title="选项一：用 “我们” 代替 “你”"></a>选项一：用 “我们” 代替 “你”</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">你能不能把这个变量名写得更清晰一点？比如 seconds_remaining？</span><br></pre></td></tr></table></figure></div>

<p>修改之后：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们能不能把这个变量名写得更清晰一点？比如 seconds_remaining？</span><br></pre></td></tr></table></figure></div>

<p>“我们” 这个词强调了团队对于代码的责任。代码的作者可能未来会去别的公司，你也可能会，但这里的代码会被它所属的团队一直维护着。当然，用 “我们” 这个词听起来有些愚蠢，因为这显然是你作为一名评审者，要求作者做的事情，但愚蠢总比指责更好。</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-d2e1d4399a4df909b1b26c12b2b0b08e_720w.jpg"
                      alt="指责"
                ><figcaption>指责</figcaption></figure></p>
<h3 id="选项二：移除句子的主语"><a href="#选项二：移除句子的主语" class="headerlink" title="选项二：移除句子的主语"></a>选项二：移除句子的主语</h3><p>避免使用 “你” 的另一个方法是移除句子的主语：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">建议使用更清晰的变量名，比如 seconds_remaining。</span><br></pre></td></tr></table></figure></div>

<p>当然被动语态也是可以的。虽然我在写技术文章时尽量避免使用被动语态，但它在 “你” 这个词的问题上确实有用处：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个变量应该使用更清晰的名字，比如 seconds_remaining。</span><br></pre></td></tr></table></figure></div>

<p>还有一种方法是把它化为一个问题：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">要把这个变量名换成更清晰的吗？比如 seconds_remaining？</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="使用请求的语气，而不是命令"><a href="#使用请求的语气，而不是命令" class="headerlink" title="使用请求的语气，而不是命令"></a>使用请求的语气，而不是命令</h2><p>Code review 比日常的交流需要更多的精力，因为很容易把讨论变成个人观点的碰撞。你总是期望评审者能在评论中保持礼貌，但奇怪的是，他们总是和期望相反。日常工作中，大多数人都不会对同事说：“把订书机拿给我，然后给我倒一杯苏打水过来。” 但 review 过程中却经常看到类似这样的评论：“把这个 class 放到另一个文件里。”</p>
<p>这样的语句经常会让你的评论令人恼怒。你的评论应该使用请求或者建议的语气，而不是命令。</p>
<p>比较下面这两种语气的区别：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic4.zhimg.com/80/v2-296c9359d034869cb0f1c8b98441765b_720w.jpg"
                      alt="命令"
                ><figcaption>命令</figcaption></figure></p>
<p>大多数人都喜欢完全掌控他们的工作，使用请求的语气可以让他们有自主的感觉。</p>
<p>另外，请求的语气也让作者更容易礼貌地推辞你的评论，或许他们是出于某些原因，考虑过后才写下的代码。如果你的语气是命令式的，那么作者的任何推辞和解释都会变成直接的不服从行为。如果你用的是请求或者提问的语气，那么作者可以简单地回复你。</p>
<p>比较下面这两种情况：</p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-53438cd9bde57d30f293d4d1ef6bf126_720w.jpg"
                      alt="请求"
                ><figcaption>请求</figcaption></figure></p>
<p>看，当你的语气变成请求式之后，是不是交流少了很多火气呢？</p>
<hr>
<h2 id="评论应该基于原则，而不是观点"><a href="#评论应该基于原则，而不是观点" class="headerlink" title="评论应该基于原则，而不是观点"></a>评论应该基于原则，而不是观点</h2><p>当你写下一条评论，要记得同时写下<em>要做什么</em>以及<em>为什么要做</em>。说 “我们应该把这个 class 切分成两个” 是不太好的，更好的说法是 “现在这个 class 负责下载并且解析文件。根据单一职责原则，我们应该把它切分成两个 class，一个负责下载，一个负责解析。”</p>
<p>你的评论应该是基于原则的，这样才可以让 review 是建设性的。当你有一个明确的理由为什么要这样做时，比如 “我们应该把这个方法私有化，以减少公共方法的数量”，作者一般都不会简单地回复 “不，我更喜欢现在这样”。即使他们这样简单地回复了，这样的回复也会看起来很傻，因为你都已经说明理由了，而他们只是因为个人偏好而拒绝你的理由。</p>
<p>软件开发既是一门艺术，也是一门科学。有些时候，即使有了既定的原则，你也不能清楚地证明一段代码是错误，因为有时代码只是丑陋或不直观而已。在这些情况下，请详细解释一下为什么，并保持客观。比如如果你说 “我觉得这很难理解”，这就是一个客观的陈述。但如果你说 “这里写得乱七八糟”，这就是一种价值判断，是仁者见仁智者见智的。</p>
<p>另外，在提供支持性材料的时候，尽可能以链接的形式附在后面。团队的代码风格规范是最好的，当然你也可以发一个语言或库文档的链接，高赞数的 StackOverflow 答案也可以。但是要知道的是，离权威性文档越远，材料就越无力。</p>
<hr>
<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>如果你喜欢这篇文章，还可以去看它的第二部分，着重于介绍如何让 Code Review 顺利完成，而不是各种碰壁。第二篇文章会介绍以下技巧：</p>
<ul>
<li>如何处理超大的 Code review</li>
<li>恰当地称赞对方</li>
<li>限制 Review 的范围</li>
<li>如何缓解僵局</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>CodeReview</tag>
        <tag>代码质量</tag>
      </tags>
  </entry>
  <entry>
    <title>选择 www 或非 www URL 作为域名</title>
    <url>/2017/02/13/%E9%80%89%E6%8B%A9-www-%E6%88%96%E9%9D%9E-www-URL-%E4%BD%9C%E4%B8%BA%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<blockquote>
<p>选择非 www 或 www 作为网址，对于网站持有者是一个反复出现的问题。本页将会提供了一些有用的相关建议。</p>
</blockquote>
<h1 id="什么是域名？"><a href="#什么是域名？" class="headerlink" title="什么是域名？"></a>什么是域名？</h1><p>在 HTTP URL 中，跟在网址头部 http:&#x2F;&#x2F; 或 https:&#x2F;&#x2F; 后面的第一个子字符串称为域，它是网站文件资源所在的服务器的名称。</p>
<p>服务器不一定是物理机：几台服务器可以驻留在同一台物理机器上，或者一台服务器可以通过几台机器进行处理，协作处理并响应或负载均衡它们之间的请求。关键点在于语义上一个域名代表一个单独的服务器。</p>
<h1 id="所以，我只能选择其中一个做为我的网站的网址？"><a href="#所以，我只能选择其中一个做为我的网站的网址？" class="headerlink" title="所以，我只能选择其中一个做为我的网站的网址？"></a>所以，我只能选择其中一个做为我的网站的网址？</h1><p>是的，你必须选择其中之一，并坚持使用。选择并使用其中哪一个取决于你，但无论你选择那一个，保持下去。这将让你的网站在用户使用搜索引擎检索时更加准确与一致。这包括始终链接到所选域名（如果你在网站中使用相对网址，则不应该很难），也可以始终将链接（通过电子邮件&#x2F;社交网络等）共享使用同一个域名。<br>不，你不能有两个。最重要的是，你是保持的那一个官方的域名，这个官方域名被称为规范名称。你所有的绝对链接应该使用它。但即便如此，你仍然可以有其他域名使用：HTTP允许使用两种技术，以便它在使用规范域名的同时还允许非规范域名使用，使使用者或搜索引擎可以准确的访问到所预期的页面。<br>所以，选择其中一个作为你的域名的规范地址！下面有两种技术允许不规范的域名仍然起作用。</p>
<h1 id="规范网址方式"><a href="#规范网址方式" class="headerlink" title="规范网址方式"></a>规范网址方式</h1><p>选择下面有两种不同的方式使网站规范。</p>
<h3 id="使用HTTP301重定向"><a href="#使用HTTP301重定向" class="headerlink" title="使用HTTP301重定向"></a>使用HTTP301重定向</h3><p>在这种情况下，你需要配置服务器接收的HTTP请求（ 常见为 www 和非 www 网址相同）以及适当的HTTP响应 301 去响应所有非规范的域名请求。这会将尝试使访问非规范网址的浏览器重定向到其规范的等效网址。举例来说，如果您选择使用非 www 网址为规范类型，你的所有 www 网址都应该被重定向到对应的非 www 网址上。</p>
<p>例如：</p>
<ol>
<li>服务器收到 <a class="link"   href="http://www.example.org/whaddup" >http://www.example.org/whaddup<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 请求（当规范域名是 example.org 时）</li>
<li>服务器则以代码 301 与头 Location ：<a class="link"   href="http://example.org/whaddup" >http://example.org/whaddup<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>该客户端发出的规范的域名请求：<a class="link"   href="http://example.org/whatddup" >http://example.org/whatddup<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ol>
<p><a class="link"   href="https://github.com/h5bp/html5-boilerplate" >HTML5 boilerplate project<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>  有一个示例 <a class="link"   href="https://github.com/h5bp/html5-boilerplate/blob/7a22a33d4041c479d0962499e853501073811887/.htaccess#L219-L258" >how to configure an Apache server to redirect one domain to the other<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 。</p>
<h3 id="使用-HTML-标签元素"><a href="#使用-HTML-标签元素" class="headerlink" title="使用 HTML 标签元素"></a>使用 HTML 标签元素</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;canonical&quot;</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>它可以将一个特殊的 HTML <link> 元素添加到网页指示什么网页的标准地址，这对页面的访问者没有影响，但在搜索引擎检索时会告诉搜索引擎当页面实际的地址。通过这种方式，搜索引擎不需要索引同一页面多次，那样可能导致它被视为重复的内容或垃圾邮件，甚至从搜索引擎结果中删除或者降低你的页面显示排名。</p>
<p>当加入这样一个标签，会告诉搜索引擎，你提供相同内容的两个域名那一个是规范的。<br>以上方为例，</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.example.org/whaddup</span><br></pre></td></tr></table></figure></div>
<p>将提供与 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.org/whaddup</span><br></pre></td></tr></table></figure></div>
<p> 相同的内容，但有一个附加的 <link> 头部元素：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link href=<span class="string">&quot;http://example.org/whaddup&quot;</span> rel=<span class="string">&quot;canonical&quot;</span>&gt; </span><br></pre></td></tr></table></figure></div>

<p>不同于以往，浏览器历史记录将考虑非 www 和 www 的网址作为独立的条目。</p>
<h1 id="请使用两者中的一个为你的网页服务"><a href="#请使用两者中的一个为你的网页服务" class="headerlink" title="请使用两者中的一个为你的网页服务"></a>请使用两者中的一个为你的网页服务</h1><p>有了这些技术，您可以将服务器配置为两个正确响应， www 的前缀和非 www 前缀的域名，这是要做到这一点，因为你无法预测哪些 URL 用户输入他们的浏览器的 URL 好的建议酒吧，这是选择你要作为规范的位置使用，然后重定向其他类型的它哪种类型的问题。</p>
<h1 id="根据情况决定使用"><a href="#根据情况决定使用" class="headerlink" title="根据情况决定使用"></a>根据情况决定使用</h1><p>可以认为这是一个非常主观 <a class="link"   href="http://bikeshed.com/" >bikeshedding<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 问题。 如果你想更深入的阅读，请参阅  <a class="link"   href="http://www.hyperarts.com/blog/www-vs-non-www-for-your-canonical-domain-url-which-is-best-and-why/" >WWW vs non-WWW for your Canonical Domain URL – Which is Best and Why?<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> ，它可能提出进一步的见解。</p>
<h1 id="请参阅"><a href="#请参阅" class="headerlink" title="请参阅"></a>请参阅</h1><p><a class="link"   href="http://www.chrisfinke.com/2011/07/25/what-do-people-type-in-the-address-bar/" >Stats on what people type in the URL bar<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> (2011)</p>
<h1 id="源网页"><a href="#源网页" class="headerlink" title="源网页"></a>源网页</h1><ul>
<li>英文版 <a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Choosing_between_www_and_non-www_URLs" >Choosing between www and non-www URLs<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>中文版 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/%E9%80%89%E6%8B%A9_www_%E6%88%96%E9%9D%9E_www_URL_%E4%BD%9C%E4%B8%BA%E5%9F%9F%E5%90%8D" >选择 www 或非 www URL 作为域名<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 常用自带工具</title>
    <url>/2026/01/20/Spring-Boot-%E5%B8%B8%E7%94%A8%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<ul>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/1996605165302727229" >别再重复造轮子了！Spring Boot 自带的 49 个“宝藏”工具类<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="1-StringUtils"><a href="#1-StringUtils" class="headerlink" title="1. StringUtils"></a>1. StringUtils</h3><p>一个用于常见字符串操作的综合工具，包括检查空字符串或仅包含空白字符的字符串。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="comment">// 检查字符串是否为空或 null</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty1</span> <span class="operator">=</span> StringUtils.isEmpty(<span class="literal">null</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty2</span> <span class="operator">=</span> StringUtils.isEmpty(<span class="string">&quot;&quot;</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 检查字符串是否有实际文本内容（不仅仅是空格）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasText1</span> <span class="operator">=</span> StringUtils.hasText(<span class="string">&quot;   &quot;</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasText2</span> <span class="operator">=</span> StringUtils.hasText(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 将字符串标记化为数组</span></span><br><span class="line">String[] parts = StringUtils.tokenizeToStringArray(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="comment">// 去除开头和结尾的空格</span></span><br><span class="line"><span class="type">String</span> <span class="variable">trimmed</span> <span class="operator">=</span> StringUtils.trimWhitespace(<span class="string">&quot;  hello  &quot;</span>); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-AntPathMatcher"><a href="#2-AntPathMatcher" class="headerlink" title="2. AntPathMatcher"></a>2. AntPathMatcher</h3><p>一个强大的工具，用于根据 Ant 风格的路径模式匹配字符串，常用于 URL 路由和安全配置。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"></span><br><span class="line"><span class="type">AntPathMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">match1</span> <span class="operator">=</span> matcher.match(<span class="string">&quot;/users/*&quot;</span>, <span class="string">&quot;/users/123&quot;</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">match2</span> <span class="operator">=</span> matcher.match(<span class="string">&quot;/users/**&quot;</span>, <span class="string">&quot;/users/123/orders&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">match3</span> <span class="operator">=</span> matcher.match(<span class="string">&quot;/user?&quot;</span>, <span class="string">&quot;/user1&quot;</span>);             <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 提取路径变量</span></span><br><span class="line">Map&lt;String, String&gt; vars = matcher.extractUriTemplateVariables(</span><br><span class="line">    <span class="string">&quot;/users/&#123;id&#125;&quot;</span>, <span class="string">&quot;/users/42&quot;</span>); <span class="comment">// &#123;id=42&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-PatternMatchUtils"><a href="#3-PatternMatchUtils" class="headerlink" title="3. PatternMatchUtils"></a>3. PatternMatchUtils</h3><p>提供了一种更简单的方法来执行基本的通配符模式匹配。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.PatternMatchUtils;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">matches1</span> <span class="operator">=</span> PatternMatchUtils.simpleMatch(<span class="string">&quot;user*&quot;</span>, <span class="string">&quot;username&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">matches2</span> <span class="operator">=</span> PatternMatchUtils.simpleMatch(<span class="string">&quot;user?&quot;</span>, <span class="string">&quot;user1&quot;</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">matches3</span> <span class="operator">=</span> PatternMatchUtils.simpleMatch(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;user*&quot;</span>, <span class="string">&quot;admin*&quot;</span>&#125;, <span class="string">&quot;adminuser&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-PropertyPlaceholderHelper"><a href="#4-PropertyPlaceholderHelper" class="headerlink" title="4. PropertyPlaceholderHelper"></a>4. PropertyPlaceholderHelper</h3><p>使用给定的属性源解析字符串中的占位符（如 ${name}）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.PropertyPlaceholderHelper;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="type">PropertyPlaceholderHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyPlaceholderHelper</span>(<span class="string">&quot;$&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.setProperty(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;greeting&quot;</span>, <span class="string">&quot;Hello $&#123;name&#125;!&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> helper.replacePlaceholders(<span class="string">&quot;$&#123;greeting&#125;&quot;</span>, props::getProperty);</span><br><span class="line"><span class="comment">// result -&gt; &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="集合与数组处理"><a href="#集合与数组处理" class="headerlink" title="集合与数组处理"></a>集合与数组处理</h2><h3 id="5-CollectionUtils"><a href="#5-CollectionUtils" class="headerlink" title="5. CollectionUtils"></a>5. CollectionUtils</h3><p>提供广泛的集合操作工具，例如检查是否为空以及执行集合运算。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查集合是否为 null 或空</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty1</span> <span class="operator">=</span> CollectionUtils.isEmpty(<span class="literal">null</span>);                 <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty2</span> <span class="operator">=</span> CollectionUtils.isEmpty(Collections.emptyList()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 查找两个列表的交集</span></span><br><span class="line">List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; intersection = CollectionUtils.intersection(list1, list2); <span class="comment">// [b, c]</span></span><br></pre></td></tr></table></figure></div>

<h3 id="6-MultiValueMap"><a href="#6-MultiValueMap" class="headerlink" title="6. MultiValueMap"></a>6. MultiValueMap</h3><p>标准 Map接口的扩展，允许为一个键存储多个值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.LinkedMultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.MultiValueMap;</span><br><span class="line"></span><br><span class="line">MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">map.add(<span class="string">&quot;colors&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">map.add(<span class="string">&quot;colors&quot;</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">map.add(<span class="string">&quot;sizes&quot;</span>, <span class="string">&quot;large&quot;</span>);</span><br><span class="line">List&lt;String&gt; colors = map.get(<span class="string">&quot;colors&quot;</span>); <span class="comment">// [red, blue]</span></span><br></pre></td></tr></table></figure></div>

<h3 id="7-ConcurrentReferenceHashMap"><a href="#7-ConcurrentReferenceHashMap" class="headerlink" title="7. ConcurrentReferenceHashMap"></a>7. ConcurrentReferenceHashMap</h3><p>一个线程安全、基于软引用的 Map，非常适合缓存场景，允许垃圾收集器在需要时回收内存。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.ConcurrentReferenceHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为高并发缓存创建一个线程安全的 map</span></span><br><span class="line">Map&lt;String, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentReferenceHashMap</span>&lt;&gt;();</span><br><span class="line">cache.put(<span class="string">&quot;key1&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 如果内存不足，该值可以被垃圾回收</span></span><br></pre></td></tr></table></figure></div>

<h3 id="8-SystemPropertyUtils"><a href="#8-SystemPropertyUtils" class="headerlink" title="8. SystemPropertyUtils"></a>8. SystemPropertyUtils</h3><p>解析 JVM 系统属性中的占位符。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.SystemPropertyUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用系统属性解析占位符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> SystemPropertyUtils.resolvePlaceholders(<span class="string">&quot;$&#123;java.home&#125;&quot;</span>);</span><br><span class="line"><span class="comment">// 如果找不到属性，则提供默认值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathWithDefault</span> <span class="operator">=</span> SystemPropertyUtils.resolvePlaceholders(</span><br><span class="line">    <span class="string">&quot;$&#123;unknown.property:default_value&#125;&quot;</span>); <span class="comment">// &quot;default_value&quot;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="反射与类操作"><a href="#反射与类操作" class="headerlink" title="反射与类操作"></a>反射与类操作</h2><h3 id="9-ReflectionUtils"><a href="#9-ReflectionUtils" class="headerlink" title="9. ReflectionUtils"></a>9. ReflectionUtils</h3><p>一组用于低级反射任务（如查找字段或调用方法）的静态方法，并能优雅地处理异常。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.ReflectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找并设置字段值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ReflectionUtils.findField(MyClass.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">ReflectionUtils.makeAccessible(field);</span><br><span class="line">ReflectionUtils.setField(field, myObject, <span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="comment">// 查找并调用方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ReflectionUtils.findMethod(MyClass.class, <span class="string">&quot;setAge&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">ReflectionUtils.invokeMethod(method, myObject, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="10-ClassUtils"><a href="#10-ClassUtils" class="headerlink" title="10. ClassUtils"></a>10. ClassUtils</h3><p>提供处理 Class对象的广泛工具，例如获取短类名或查找接口。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.ClassUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的短名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">shortName</span> <span class="operator">=</span> ClassUtils.getShortName(<span class="string">&quot;org.example.MyClass&quot;</span>); <span class="comment">// &quot;MyClass&quot;</span></span><br><span class="line"><span class="comment">// 检查类路径上是否存在某个类</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> ClassUtils.isPresent(<span class="string">&quot;java.util.List&quot;</span>, <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 获取默认的类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassUtils.getDefaultClassLoader();</span><br></pre></td></tr></table></figure></div>

<h3 id="11-MethodInvoker"><a href="#11-MethodInvoker" class="headerlink" title="11. MethodInvoker"></a>11. MethodInvoker</h3><p>一种在目标对象上准备并调用带参数方法的便捷方式。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.MethodInvoker;</span><br><span class="line"></span><br><span class="line"><span class="type">MethodInvoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodInvoker</span>();</span><br><span class="line">invoker.setTargetObject(<span class="keyword">new</span> <span class="title class_">MyService</span>());</span><br><span class="line">invoker.setTargetMethod(<span class="string">&quot;calculateTotal&quot;</span>);</span><br><span class="line">invoker.setArguments(<span class="number">100</span>, <span class="number">0.2</span>);</span><br><span class="line">invoker.prepare();</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invoker.invoke();</span><br></pre></td></tr></table></figure></div>

<h3 id="12-BeanUtils"><a href="#12-BeanUtils" class="headerlink" title="12. BeanUtils"></a>12. BeanUtils</h3><p>一个强大的工具，用于常见的 Bean 相关操作，包括属性复制和实例化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性从源对象复制到目标对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">PersonDTO</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonDTO</span>();</span><br><span class="line">BeanUtils.copyProperties(source, target);</span><br><span class="line"><span class="comment">// 使用默认构造函数实例化一个类</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">newPerson</span> <span class="operator">=</span> BeanUtils.instantiateClass(Person.class);</span><br></pre></td></tr></table></figure></div>

<h3 id="I-O-操作"><a href="#I-O-操作" class="headerlink" title="I&#x2F;O 操作"></a>I&#x2F;O 操作</h3><h3 id="13-FileCopyUtils"><a href="#13-FileCopyUtils" class="headerlink" title="13. FileCopyUtils"></a>13. FileCopyUtils</h3><p>提供简单的静态方法，用于在文件、流、Reader 和 Writer 之间复制内容。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.FileCopyUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件内容复制到字节数组</span></span><br><span class="line"><span class="type">byte</span>[] bytes = FileCopyUtils.copyToByteArray(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line">FileCopyUtils.copy(bytes, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 将内容从 Reader 复制到 String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FileCopyUtils.copyToString(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 在流之间复制</span></span><br><span class="line">FileCopyUtils.copy(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<h3 id="14-ResourceUtils"><a href="#14-ResourceUtils" class="headerlink" title="14. ResourceUtils"></a>14. ResourceUtils</h3><p>用于将资源位置（如 classpath:或 file:）解析为 File或 URL对象的工具。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.ResourceUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从类路径获取文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> ResourceUtils.getFile(<span class="string">&quot;classpath:config.properties&quot;</span>);</span><br><span class="line"><span class="comment">// 检查字符串是否为 URL</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isUrl</span> <span class="operator">=</span> ResourceUtils.isUrl(<span class="string">&quot;http://example.com&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 从位置字符串获取 URL</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> ResourceUtils.getURL(<span class="string">&quot;classpath:data.json&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="15-StreamUtils"><a href="#15-StreamUtils" class="headerlink" title="15. StreamUtils"></a>15. StreamUtils</h3><p>包含处理 InputStream和 OutputStream的实用方法，防止常见的样板代码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.StreamUtils;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将流复制到字节数组</span></span><br><span class="line"><span class="type">byte</span>[] data = StreamUtils.copyToByteArray(inputStream);</span><br><span class="line"><span class="comment">// 将流复制到字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">// 将字符串复制到输出流</span></span><br><span class="line">StreamUtils.copy(<span class="string">&quot;Hello&quot;</span>, StandardCharsets.UTF_8, outputStream);</span><br></pre></td></tr></table></figure></div>

<h3 id="16-FileSystemUtils"><a href="#16-FileSystemUtils" class="headerlink" title="16. FileSystemUtils"></a>16. FileSystemUtils</h3><p>提供文件系统操作工具，最值得注意的是递归复制和删除目录。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.FileSystemUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归删除目录及其内容</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">deleted</span> <span class="operator">=</span> FileSystemUtils.deleteRecursively(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp/test&quot;</span>));</span><br><span class="line"><span class="comment">// 递归复制目录及其内容</span></span><br><span class="line">FileSystemUtils.copyRecursively(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;source&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;target&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<h3 id="17-ResourcePatternUtils"><a href="#17-ResourcePatternUtils" class="headerlink" title="17. ResourcePatternUtils"></a>17. ResourcePatternUtils</h3><p>将资源模式（如 classpath*:**&#x2F;*.xml）解析为 Resource对象数组。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.ResourcePatternUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在所有类路径位置的 META-INF 目录中查找所有 XML 文件</span></span><br><span class="line"><span class="type">ResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">Resource[] resources = resolver.getResources(<span class="string">&quot;classpath*:META-INF/*.xml&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="Web-相关"><a href="#Web-相关" class="headerlink" title="Web 相关"></a>Web 相关</h2><h3 id="18-WebUtils"><a href="#18-WebUtils" class="headerlink" title="18. WebUtils"></a>18. WebUtils</h3><p>各种 Web 实用程序的集合，适用于获取 Cookie 或请求参数等任务。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.util.WebUtils;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从请求中获取特定的 cookie</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> WebUtils.getCookie(request, <span class="string">&quot;sessionId&quot;</span>);</span><br><span class="line"><span class="comment">// 获取带有默认值的请求参数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> WebUtils.getIntParameter(request, <span class="string">&quot;pageSize&quot;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="19-UriUtils"><a href="#19-UriUtils" class="headerlink" title="19. UriUtils"></a>19. UriUtils</h3><p>根据 RFC 3986 对 URI 组件进行编码和解码的辅助工具。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.util.UriUtils;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码 URI 路径段</span></span><br><span class="line"><span class="type">String</span> <span class="variable">encoded</span> <span class="operator">=</span> UriUtils.encodePathSegment(<span class="string">&quot;path with spaces&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">// 解码回原始段</span></span><br><span class="line"><span class="type">String</span> <span class="variable">decoded</span> <span class="operator">=</span> UriUtils.decode(encoded, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure></div>

<h3 id="20-UriComponentsBuilder"><a href="#20-UriComponentsBuilder" class="headerlink" title="20. UriComponentsBuilder"></a>20. UriComponentsBuilder</h3><p>一个可变构建器，用于从头开始创建 UriComponents或通过修改现有 URI 来操作它。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.util.UriComponentsBuilder;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以流畅的方式构建复杂的 URI</span></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> UriComponentsBuilder.fromHttpUrl(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line">    .path(<span class="string">&quot;/products/&#123;id&#125;&quot;</span>)</span><br><span class="line">    .queryParam(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;books&quot;</span>)</span><br><span class="line">    .build(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="comment">// 结果: http://example.com/products/123?category=books</span></span><br></pre></td></tr></table></figure></div>

<h3 id="21-ContentCachingRequestWrapper"><a href="#21-ContentCachingRequestWrapper" class="headerlink" title="21. ContentCachingRequestWrapper"></a>21. ContentCachingRequestWrapper</h3><p>包装 HttpServletRequest以缓存其主体，允许读取多次请求负载。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.util.ContentCachingRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装请求，例如在过滤器中</span></span><br><span class="line"><span class="type">ContentCachingRequestWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentCachingRequestWrapper</span>(request);</span><br><span class="line"><span class="comment">// ... 稍后，在处理完请求之后</span></span><br><span class="line"><span class="type">byte</span>[] body = wrapper.getContentAsByteArray();</span><br><span class="line"><span class="type">String</span> <span class="variable">bodyAsString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body, wrapper.getCharacterEncoding());</span><br></pre></td></tr></table></figure></div>

<h3 id="22-HtmlUtils"><a href="#22-HtmlUtils" class="headerlink" title="22. HtmlUtils"></a>22. HtmlUtils</h3><p>用于 HTML 转义和反转义的工具，有助于防止跨站脚本 (XSS) 攻击。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.util.HtmlUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转义 HTML 以防止浏览器渲染它</span></span><br><span class="line"><span class="type">String</span> <span class="variable">escaped</span> <span class="operator">=</span> HtmlUtils.htmlEscape(<span class="string">&quot;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="comment">// &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span></span><br><span class="line"><span class="comment">// 将 HTML 实体反转义回字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">unescaped</span> <span class="operator">=</span> HtmlUtils.htmlUnescape(<span class="string">&quot;&lt;b&gt;Bold&lt;/b&gt;&quot;</span>);</span><br><span class="line"><span class="comment">// &lt;b&gt;Bold&lt;/b&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="验证与断言"><a href="#验证与断言" class="headerlink" title="验证与断言"></a>验证与断言</h2><h3 id="23-Assert"><a href="#23-Assert" class="headerlink" title="23. Assert"></a>23. Assert</h3><p>提供静态断言方法来检查前置条件。如果断言失败，它会抛出 IllegalArgumentException。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证参数的常用断言</span></span><br><span class="line">Assert.notNull(object, <span class="string">&quot;Object must not be null&quot;</span>);</span><br><span class="line">Assert.hasText(name, <span class="string">&quot;Name must not be empty&quot;</span>);</span><br><span class="line">Assert.isTrue(amount &gt; <span class="number">0</span>, <span class="string">&quot;Amount must be positive&quot;</span>);</span><br><span class="line">Assert.notEmpty(items, <span class="string">&quot;Items collection must not be empty&quot;</span>);</span><br><span class="line">Assert.state(isInitialized, <span class="string">&quot;Service is not initialized&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="24-ObjectUtils"><a href="#24-ObjectUtils" class="headerlink" title="24. ObjectUtils"></a>24. ObjectUtils</h3><p>用于处理对象的工具，特别是用于空安全操作和检查各种类型（数组、集合等）是否为空。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.ObjectUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查对象是否为空（null、空字符串、空数组或空集合）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty1</span> <span class="operator">=</span> ObjectUtils.isEmpty(<span class="literal">null</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty2</span> <span class="operator">=</span> ObjectUtils.isEmpty(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 空安全的 equals 比较</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">equals</span> <span class="operator">=</span> ObjectUtils.nullSafeEquals(obj1, obj2);</span><br><span class="line"><span class="comment">// 如果对象为 null，则获取默认值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> ObjectUtils.getOrDefault(<span class="literal">null</span>, <span class="string">&quot;default&quot;</span>); <span class="comment">// &quot;default&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="25-NumberUtils"><a href="#25-NumberUtils" class="headerlink" title="25. NumberUtils"></a>25. NumberUtils</h3><p>用于在不同数字类型之间转换并将字符串解析为数字的工具。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.NumberUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串解析为特定的数字类型</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">parsedInt</span> <span class="operator">=</span> NumberUtils.parseNumber(<span class="string">&quot;42&quot;</span>, Integer.class);</span><br><span class="line"><span class="comment">// 将一种数字类型转换为另一种</span></span><br><span class="line"><span class="type">Double</span> <span class="variable">convertedDouble</span> <span class="operator">=</span> NumberUtils.convertNumberToTargetClass(<span class="number">42</span>, Double.class);</span><br></pre></td></tr></table></figure></div>

<h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><h3 id="26-DateFormatter"><a href="#26-DateFormatter" class="headerlink" title="26. DateFormatter"></a>26. DateFormatter</h3><p>一个灵活的 java.util.Date对象格式化程序，用于日期和字符串之间的转换。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.format.datetime.DateFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：Spring 倾向于使用 formatters 而不是静态的 DateTimeUtils 类。</span></span><br><span class="line"><span class="type">DateFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateFormatter</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> formatter.print(<span class="keyword">new</span> <span class="title class_">Date</span>(), Locale.getDefault());</span><br></pre></td></tr></table></figure></div>

<h3 id="27-StopWatch"><a href="#27-StopWatch" class="headerlink" title="27. StopWatch"></a>27. StopWatch</h3><p>一个简单的任务计时工具，提供了一种方便的方法来测量不同代码块的执行时间。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的性能计时工具</span></span><br><span class="line"><span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>(<span class="string">&quot;MyTask&quot;</span>);</span><br><span class="line">watch.start(<span class="string">&quot;Phase 1: Data Loading&quot;</span>);</span><br><span class="line"><span class="comment">// ... 执行数据加载任务</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">watch.stop();</span><br><span class="line">watch.start(<span class="string">&quot;Phase 2: Data Processing&quot;</span>);</span><br><span class="line"><span class="comment">// ... 执行处理任务</span></span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">watch.stop();</span><br><span class="line"><span class="comment">// 打印格式化的计时摘要</span></span><br><span class="line">System.out.println(watch.prettyPrint());</span><br></pre></td></tr></table></figure></div>

<h2 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h2><h3 id="28-DigestUtils"><a href="#28-DigestUtils" class="headerlink" title="28. DigestUtils"></a>28. DigestUtils</h3><p>提供创建消息摘要（哈希）（如 MD5）的静态方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.DigestUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建字符串的 MD5 哈希</span></span><br><span class="line"><span class="type">String</span> <span class="variable">md5Hex</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(<span class="string">&quot;password&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 创建文件内容的 MD5 哈希</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileMd5</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="29-Base64Utils"><a href="#29-Base64Utils" class="headerlink" title="29. Base64Utils"></a>29. Base64Utils</h3><p>用于 Base64 编码和解码数据的工具。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.Base64Utils;</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] data = <span class="string">&quot;Hello World&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">// 将数据编码为 Base64 字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">encoded</span> <span class="operator">=</span> Base64Utils.encodeToString(data);</span><br><span class="line"><span class="comment">// 将 Base64 字符串解码回数据</span></span><br><span class="line"><span class="type">byte</span>[] decoded = Base64Utils.decodeFromString(encoded);</span><br></pre></td></tr></table></figure></div>

<h3 id="30-TextEncryptor"><a href="#30-TextEncryptor" class="headerlink" title="30. TextEncryptor"></a>30. TextEncryptor</h3><p>Spring Security 提供的接口，用于文本的双向加密和解密。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.encrypt.Encryptors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.encrypt.TextEncryptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：需要 spring-security-crypto 依赖</span></span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;my-secret-password&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> <span class="string">&quot;deadbeef&quot;</span>; <span class="comment">// hex-encoded</span></span><br><span class="line"><span class="type">TextEncryptor</span> <span class="variable">encryptor</span> <span class="operator">=</span> Encryptors.text(password, salt);</span><br><span class="line"><span class="type">String</span> <span class="variable">encryptedText</span> <span class="operator">=</span> encryptor.encrypt(<span class="string">&quot;This is a secret message&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">decryptedText</span> <span class="operator">=</span> encryptor.decrypt(encryptedText);</span><br></pre></td></tr></table></figure></div>

<h2 id="JSON-与数据转换"><a href="#JSON-与数据转换" class="headerlink" title="JSON 与数据转换"></a>JSON 与数据转换</h2><h3 id="31-JsonParserFactory"><a href="#31-JsonParserFactory" class="headerlink" title="31. JsonParserFactory"></a>31. JsonParserFactory</h3><p>用于获取 JsonParser实例的工厂，提供了一种简单的方法来解析 JSON 字符串，而无需完整的数据绑定库。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.json.JsonParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.json.JsonParserFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取默认的 JSON 解析器</span></span><br><span class="line"><span class="type">JsonParser</span> <span class="variable">parser</span> <span class="operator">=</span> JsonParserFactory.getJsonParser();</span><br><span class="line"><span class="comment">// 将 JSON 对象解析为 Map</span></span><br><span class="line">Map&lt;String, Object&gt; map = parser.parseMap(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;John\&quot;, \&quot;age\&quot;:30&#125;&quot;</span>);</span><br><span class="line"><span class="comment">// 将 JSON 数组解析为 List</span></span><br><span class="line">List&lt;Object&gt; list = parser.parseList(<span class="string">&quot;[1, 2, 3]&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="32-ResolvableType"><a href="#32-ResolvableType" class="headerlink" title="32. ResolvableType"></a>32. ResolvableType</h3><p>提供一种机制来在运行时处理 java.lang.Class无法单独处理的复杂泛型类型。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.ResolvableType;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取集合的泛型类型</span></span><br><span class="line"><span class="type">ResolvableType</span> <span class="variable">listType</span> <span class="operator">=</span> ResolvableType.forField(getClass().getDeclaredField(<span class="string">&quot;myList&quot;</span>));</span><br><span class="line"><span class="type">ResolvableType</span> <span class="variable">elementType</span> <span class="operator">=</span> listType.getGeneric(<span class="number">0</span>); <span class="comment">// 例如，对于 List&lt;String&gt; 是 String</span></span><br><span class="line"><span class="comment">// 为泛型类创建可解析类型</span></span><br><span class="line"><span class="type">ResolvableType</span> <span class="variable">mapType</span> <span class="operator">=</span> ResolvableType.forClassWithGenerics(Map.class, String.class, Integer.class);</span><br></pre></td></tr></table></figure></div>

<h3 id="33-MappingJackson2HttpMessageConverter"><a href="#33-MappingJackson2HttpMessageConverter" class="headerlink" title="33. MappingJackson2HttpMessageConverter"></a>33. MappingJackson2HttpMessageConverter</h3><p>Spring MVC 中用于在 Java 对象和 JSON 之间进行转换的核心组件，可以进行自定义。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并自定义 JSON 消息转换器</span></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">customMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="comment">// ... 配置 ObjectMapper 属性（例如，日期格式、特性）</span></span><br><span class="line"><span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(customMapper);</span><br></pre></td></tr></table></figure></div>

<h2 id="其他实用工具"><a href="#其他实用工具" class="headerlink" title="其他实用工具"></a>其他实用工具</h2><h3 id="34-RandomStringUtils-Apache-Commons"><a href="#34-RandomStringUtils-Apache-Commons" class="headerlink" title="34. RandomStringUtils (Apache Commons)"></a>34. RandomStringUtils (Apache Commons)</h3><p>虽然不是 Spring 类，但在 Spring 项目中经常使用（通常通过 spring-boot-starter包含），值得一提的是它用于生成随机字符串。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：来自 org.apache.commons.lang3 库</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.RandomStringUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">randomAlpha</span> <span class="operator">=</span> RandomStringUtils.randomAlphabetic(<span class="number">10</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">randomAlphanumeric</span> <span class="operator">=</span> RandomStringUtils.randomAlphanumeric(<span class="number">10</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">randomNumeric</span> <span class="operator">=</span> RandomStringUtils.randomNumeric(<span class="number">6</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="35-CompletableFuture"><a href="#35-CompletableFuture" class="headerlink" title="35. CompletableFuture"></a>35. CompletableFuture</h3><p>标准 Java 类，但在现代异步 Spring 应用程序中必不可少。使用其静态方法来组合结果。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合多个异步结果的常见模式</span></span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; futures = <span class="comment">/* 异步调用的 future 列表 */</span>;</span><br><span class="line">CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(</span><br><span class="line">    futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]));</span><br><span class="line">CompletableFuture&lt;List&lt;String&gt;&gt; allResults = allOf.thenApply(v -&gt;</span><br><span class="line">    futures.stream()</span><br><span class="line">           .map(CompletableFuture::join)</span><br><span class="line">           .collect(Collectors.toList()));</span><br></pre></td></tr></table></figure></div>

<h3 id="36-CacheControl"><a href="#36-CacheControl" class="headerlink" title="36. CacheControl"></a>36. CacheControl</h3><p>一个构建器，用于以类型安全的方式创建 HTTP Cache-Control标头值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.CacheControl;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 Cache-Control 标头值</span></span><br><span class="line"><span class="type">CacheControl</span> <span class="variable">cacheControl</span> <span class="operator">=</span> CacheControl.maxAge(<span class="number">1</span>, TimeUnit.HOURS)</span><br><span class="line">    .noTransform()</span><br><span class="line">    .mustRevalidate();</span><br><span class="line"><span class="type">String</span> <span class="variable">headerValue</span> <span class="operator">=</span> cacheControl.getHeaderValue(); <span class="comment">// &quot;max-age=3600, no-transform, must-revalidate&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="37-AnnotationUtils"><a href="#37-AnnotationUtils" class="headerlink" title="37. AnnotationUtils"></a>37. AnnotationUtils</h3><p>用于查找类、方法和字段上的注解的强大工具，包括支持元注解和合并注解属性。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotationUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找类上的注解，向上搜索层次结构</span></span><br><span class="line"><span class="type">Component</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(MyService.class, Component.class);</span><br><span class="line"><span class="comment">// 从注解中获取特定的属性值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) AnnotationUtils.getValue(annotation, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="38-DefaultConversionService"><a href="#38-DefaultConversionService" class="headerlink" title="38. DefaultConversionService"></a>38. DefaultConversionService</h3><p>Spring 对 ConversionService的默认实现，可以在许多标准类型之间进行转换（例如，字符串到整数）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.convert.support.DefaultConversionService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建转换服务实例</span></span><br><span class="line"><span class="type">DefaultConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConversionService</span>();</span><br><span class="line"><span class="comment">// 将字符串转换为整数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">intValue</span> <span class="operator">=</span> conversionService.convert(<span class="string">&quot;42&quot;</span>, Integer.class);</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">boolValue</span> <span class="operator">=</span> conversionService.convert(<span class="string">&quot;true&quot;</span>, Boolean.class);</span><br></pre></td></tr></table></figure></div>

<h3 id="39-HttpHeaders"><a href="#39-HttpHeaders" class="headerlink" title="39. HttpHeaders"></a>39. HttpHeaders</h3><p>一个专门用于处理 HTTP 标头的 MultiValueMap，提供方便的常量和方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 HTTP 标头的便捷方式</span></span><br><span class="line"><span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">headers.setContentLength(<span class="number">1024</span>);</span><br><span class="line">headers.setCacheControl(<span class="string">&quot;max-age=3600&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="40-MediaTypeFactory"><a href="#40-MediaTypeFactory" class="headerlink" title="40. MediaTypeFactory"></a>40. MediaTypeFactory</h3><p>提供一种根据文件名确定资源的 MediaType（MIME 类型）的方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaTypeFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据文件名猜测媒体类型</span></span><br><span class="line">Optional&lt;MediaType&gt; mediaType = MediaTypeFactory.getMediaType(<span class="string">&quot;document.pdf&quot;</span>);</span><br><span class="line"><span class="comment">// 返回 Optional[application/pdf]</span></span><br></pre></td></tr></table></figure></div>

<h3 id="41-MimeTypeUtils"><a href="#41-MimeTypeUtils" class="headerlink" title="41. MimeTypeUtils"></a>41. MimeTypeUtils</h3><p>包含常见 MIME 类型的常量，并提供处理它们的实用方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.MimeTypeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供常见的 MIME 类型常量和实用程序</span></span><br><span class="line"><span class="type">MimeType</span> <span class="variable">a</span> <span class="operator">=</span> MimeTypeUtils.APPLICATION_JSON;</span><br><span class="line"><span class="type">MimeType</span> <span class="variable">b</span> <span class="operator">=</span> MimeType.valueOf(<span class="string">&quot;application/*&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isCompatible</span> <span class="operator">=</span> a.isCompatibleWith(b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="42-WebClient-Builder"><a href="#42-WebClient-Builder" class="headerlink" title="42. WebClient.Builder"></a>42. WebClient.Builder</h3><p>创建 WebClient（Spring 的现代非阻塞 HTTP 客户端）实例的主要工具。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.client.WebClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构建器来配置和创建 WebClient 实例</span></span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.example.com&quot;</span>)</span><br><span class="line">    .defaultHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer my-token&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></div>

<h3 id="43-PropertySourceUtils"><a href="#43-PropertySourceUtils" class="headerlink" title="43. PropertySourceUtils"></a>43. PropertySourceUtils</h3><p>一个辅助工具，用于处理环境中所包含的 PropertySource对象中的属性值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.env.ConfigurableEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.MapPropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性源添加到环境的示例</span></span><br><span class="line">Map&lt;String, Object&gt; myProps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">myProps.put(<span class="string">&quot;app.name&quot;</span>, <span class="string">&quot;MyApp&quot;</span>);</span><br><span class="line">PropertySource&lt;?&gt; myPropertySource = <span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(<span class="string">&quot;my-properties&quot;</span>, myProps);</span><br><span class="line">environment.getPropertySources().addFirst(myPropertySource);</span><br></pre></td></tr></table></figure></div>

<h3 id="44-ApplicationEventPublisher"><a href="#44-ApplicationEventPublisher" class="headerlink" title="44. ApplicationEventPublisher"></a>44. ApplicationEventPublisher</h3><p>Spring 中用于在应用程序上下文中发布事件的核心接口，支持解耦的事件驱动架构。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEventPublisher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 逻辑 ...</span></span><br><span class="line">    <span class="type">MyCustomEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCustomEvent</span>(<span class="built_in">this</span>, <span class="string">&quot;Something important happened&quot;</span>);</span><br><span class="line">    eventPublisher.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="45-LocaleContextHolder"><a href="#45-LocaleContextHolder" class="headerlink" title="45. LocaleContextHolder"></a>45. LocaleContextHolder</h3><p>保存当前线程的 Locale，对于国际化 (i18n) 至关重要。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.i18n.LocaleContextHolder;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前请求/线程的 locale</span></span><br><span class="line"><span class="type">Locale</span> <span class="variable">currentLocale</span> <span class="operator">=</span> LocaleContextHolder.getLocale();</span><br><span class="line"><span class="comment">// 以编程方式设置 locale</span></span><br><span class="line">LocaleContextHolder.setLocale(Locale.FRENCH);</span><br></pre></td></tr></table></figure></div>

<h3 id="46-AopUtils"><a href="#46-AopUtils" class="headerlink" title="46. AopUtils"></a>46. AopUtils</h3><p>一组用于处理 AOP 代理的静态实用方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.support.AopUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查对象是否为 Spring AOP 代理</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isAopProxy</span> <span class="operator">=</span> AopUtils.isAopProxy(myBean);</span><br><span class="line"><span class="comment">// 检查是否为基于 CGLIB 的代理</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isCglibProxy</span> <span class="operator">=</span> AopUtils.isCglibProxy(myBean);</span><br><span class="line"><span class="comment">// 获取代理的底层目标类</span></span><br><span class="line">Class&lt;?&gt; targetClass = AopUtils.getTargetClass(myBean);</span><br></pre></td></tr></table></figure></div>

<h3 id="47-ProxyFactory"><a href="#47-ProxyFactory" class="headerlink" title="47. ProxyFactory"></a>47. ProxyFactory</h3><p>一种以编程方式创建 AOP 代理的方法，使你可以细粒度地控制应用哪些接口和建议。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.framework.ProxyFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以编程方式为目标对象创建代理</span></span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(myTargetObject);</span><br><span class="line">factory.addAdvice(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>()); <span class="comment">// 添加建议 (Advice)</span></span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (MyInterface) factory.getProxy();</span><br></pre></td></tr></table></figure></div>

<h3 id="48-ClassPathScanningCandidateComponentProvider"><a href="#48-ClassPathScanningCandidateComponentProvider" class="headerlink" title="48. ClassPathScanningCandidateComponentProvider"></a>48. ClassPathScanningCandidateComponentProvider</h3><p>一个强大的工具，用于扫描类路径以查找符合特定条件的组件（通常由过滤器定义）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.AnnotationTypeFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描类路径以查找带有 @Component 注解的类</span></span><br><span class="line"><span class="type">ClassPathScanningCandidateComponentProvider</span> <span class="variable">scanner</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ClassPathScanningCandidateComponentProvider</span>(<span class="literal">true</span>);</span><br><span class="line">scanner.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Component.class));</span><br><span class="line">Set&lt;BeanDefinition&gt; components = scanner.findCandidateComponents(<span class="string">&quot;com.example.myapp&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="49-YamlPropertiesFactoryBean"><a href="#49-YamlPropertiesFactoryBean" class="headerlink" title="49. YamlPropertiesFactoryBean"></a>49. YamlPropertiesFactoryBean</h3><p>一个工厂 Bean，可以加载 YAML 文件并将其转换为 Properties对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.YamlPropertiesFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 YAML 文件并将其视为 Properties 对象</span></span><br><span class="line"><span class="type">YamlPropertiesFactoryBean</span> <span class="variable">yamlFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YamlPropertiesFactoryBean</span>();</span><br><span class="line">yamlFactory.setResources(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;application.yml&quot;</span>));</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> yamlFactory.getObject();</span><br><span class="line"><span class="type">String</span> <span class="variable">appName</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;spring.application.name&quot;</span>);</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 一条SQL是如何运行的</title>
    <url>/2026/01/23/MySQL-%E4%B8%80%E6%9D%A1SQL%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>一条 SQL 在 MySQL 中的“旅程”可以拆成两大阶段： </p>
<ol>
<li>Server 层（连接、权限、解析、优化、执行）  </li>
<li>存储引擎层（InnoDB、MyISAM 等，真正读写磁盘）</li>
</ol>
<p>下面用一条最简单的 <code>UPDATE t SET c = c + 1 WHERE id = 10;</code> 带你走一遍完整流程，并给出每一步在源码&#x2F;日志中的落点，方便你实际跟踪。</p>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="一、连接与线程"><a href="#一、连接与线程" class="headerlink" title="一、连接与线程"></a>一、连接与线程</h2><ol>
<li>客户端通过 TCP&#x2F;Unix Socket 连到 3306 端口。  </li>
<li>MySQL 为每个连接分配一条<strong>系统线程</strong>（<code>sql/sql_connect.cc</code> 中的 <code>create_new_thread</code>）。  </li>
<li>线程先检查 <code>mysql.user</code> 表做身份认证，再把连接放进线程池（<code>thread_pool</code> 插件）或保持单线程模式。  </li>
<li>连接成功后，线程会分配一个 <code>THD</code> 对象（Thread Handler），它贯穿整条 SQL 的生命周期，保存了用户变量、临时表、诊断信息等。</li>
</ol>
<hr>
<h2 id="二、解析与预处理（Server-层）"><a href="#二、解析与预处理（Server-层）" class="headerlink" title="二、解析与预处理（Server 层）"></a>二、解析与预处理（Server 层）</h2><ol>
<li>接收网络包 → <code>my_net_read()</code> → 把原始文本放进 <code>THD::query_string</code>。  </li>
<li><strong>词法分析</strong> (<code>sql/sql_lex.cc</code>, <code>lex_one_token</code>)：拆成 token（UPDATE &#x2F; t &#x2F; SET …）。  </li>
<li><strong>语法分析</strong> (<code>sql/sql_yacc.yy</code>, bison 生成)：生成<strong>解析树</strong> <code>Parse_tree_root</code>。  </li>
<li><strong>预处理器</strong> (<code>sql/sql_resolver.cc</code>)：  <ul>
<li>检查表、列是否存在；  </li>
<li>把 <code>*</code> 展开成列列表；  </li>
<li>把视图替换成基表；  </li>
<li>权限预检（<code>check_access()</code>）。<br>结果得到一条“语句对象” <code>sql_cmd</code>（本例是 <code>Sql_cmd_update</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="三、查询优化器（Server-层）"><a href="#三、查询优化器（Server-层）" class="headerlink" title="三、查询优化器（Server 层）"></a>三、查询优化器（Server 层）</h2><ol>
<li>打开表 (<code>open_and_lock_tables</code>) → 加载 InnoDB 元数据，加 MDL（Metadata Lock）。  </li>
<li>优化器入口：<code>handle_query()</code> → <code>JOIN::optimize()</code>  <ul>
<li>规则优化：常量折叠、表达式简化、子查询转换（<code>IN→EXISTS</code> &#x2F; <code>derived table</code>）。  </li>
<li>代价优化：<br>– 选择索引（<code>range/index_merge</code> 分析，<code>sql/opt_range.cc</code>）；<br>– 估算行数（<code>records_per_key</code> 来自 InnoDB 的统计表）；<br>– 生成执行计划（<code>AccessPath</code>，8.0 的新框架）。<br>本例 WHERE 走主键 <code>id=10</code>，优化器决定用 <code>ref access</code>。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="四、执行器（Server-层）"><a href="#四、执行器（Server-层）" class="headerlink" title="四、执行器（Server 层）"></a>四、执行器（Server 层）</h2><ol>
<li>根据执行计划调用 <code>Sql_cmd_update::execute()</code> → <code>mysql_update()</code>。  </li>
<li>执行器先请求 InnoDB：“给我 id&#x3D;10 的行”<br>– <code>ha_innobase::index_read()</code> → 把主键 10 传给 InnoDB 层。  </li>
<li>InnoDB 返回行后，执行器把 c 字段加 1，再调用<br>– <code>ha_innobase::update_row()</code> 把新行写回去。  </li>
<li>每改一行，先写<strong>回滚段 undo</strong>、再写<strong>聚集索引</strong>、再写<strong>二级索引</strong>，同时把<strong>修改前的镜像</strong>记入 undo log，用于回滚与 MVCC。  </li>
<li>如果表上有触发器、外键、级联，执行器会递归调用相应逻辑。</li>
</ol>
<hr>
<h2 id="五、存储引擎层（InnoDB）"><a href="#五、存储引擎层（InnoDB）" class="headerlink" title="五、存储引擎层（InnoDB）"></a>五、存储引擎层（InnoDB）</h2><ol>
<li>Buffer Pool 查找  <ul>
<li>主键 10 所在的 16 KB 页在 BP 命中则直接返回；  </li>
<li>未命中则从 <code>.ibd</code> 文件读页，异步预读 (<code>read_ahead</code>)。</li>
</ul>
</li>
<li>加锁  <ul>
<li>先给聚簇索引记录加<strong>行锁</strong> (<code>lock_rec_lock</code>)，类型为 <code>LOCK_X | LOCK_REC_NOT_GAP</code>；  </li>
<li>如果隔离级别是 RR 且走范围，还会加 <strong>gap lock &#x2F; next-key lock</strong>。</li>
</ul>
</li>
<li>写 redo log（WAL）  <ul>
<li>修改页前先写 redo log buffer (<code>mlog_write_ulint</code>…)；  </li>
<li><code>trx_flush_log_later</code> 决定是否立即刷盘；  </li>
<li>commit 时 <code>fsync()</code> 保证持久化（参数 <code>innodb_flush_log_at_trx_commit</code>）。</li>
</ul>
</li>
<li>写 undo log  <ul>
<li>在系统回滚段表空间 (<code>ibdata1</code> 或独立 undo tablespace) 插入一条 undo record；  </li>
<li>undo 记录包含旧值和指向上一版本指针，用于一致性读与回滚。</li>
</ul>
</li>
<li>修改页  <ul>
<li>把 BP 页设为 dirty，加入 <code>flush_list</code>，由后台线程 <code>page_cleaner</code> 异步刷盘。</li>
</ul>
</li>
<li>Change Buffer（二级索引延迟写）  <ul>
<li>若二级索引页不在 BP，先写 insert buffer，后续读&#x2F;合并时再真正更新。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="六、二阶段提交（binlog-redo-一致性）"><a href="#六、二阶段提交（binlog-redo-一致性）" class="headerlink" title="六、二阶段提交（binlog &amp; redo 一致性）"></a>六、二阶段提交（binlog &amp; redo 一致性）</h2><ol>
<li>执行器在真正 commit 前，先调用 <code>ha_prepare_low()</code> 让 InnoDB 进入 prepare 状态：<br>– 把事务 XID 写到 redo log，并置 <code>TRX_PREPARED</code> 标志。  </li>
<li>Server 层把本次产生的 binlog 写入 binlog cache，并做一次 <code>fsync()</code>（<code>sync_binlog=1</code>）。  </li>
<li>再调用 <code>ha_commit_low()</code> 让 InnoDB 把事务状态从 <code>TRX_PREPARED</code> → <code>TRX_COMMITTED_IN_MEMORY</code>，释放行锁、清理 undo。  </li>
<li>若在第 2 步之后崩溃，重启时先扫 redo log 找到 prepared 事务，再扫 binlog：<br>– 如果 binlog 也存在该 XID → 提交；<br>– 如果 binlog 没有 → 回滚。<br>从而保证主从一致。</li>
</ol>
<hr>
<h2 id="七、返回客户端"><a href="#七、返回客户端" class="headerlink" title="七、返回客户端"></a>七、返回客户端</h2><ol>
<li>Server 层把受影响行数、warning 计数、last-insert-id 等写进协议包 → <code>my_net_write()</code></li>
<li>线程把 <code>THD</code> 放回连接池（线程池模式）或继续等待下一条命令。  </li>
<li>如果开启了 <code>general_log</code>，整条 SQL 文本和耗时会被记入 <code>mysql.general_log</code> 表；<br>如果 <code>slow_query_log</code> 打开且超过阈值，会写慢日志，并可通过 <code>mysqldumpslow</code> 分析。</li>
</ol>
<hr>
<h2 id="八、常用跟踪姿势"><a href="#八、常用跟踪姿势" class="headerlink" title="八、常用跟踪姿势"></a>八、常用跟踪姿势</h2><ol>
<li>看执行计划：<code>EXPLAIN FORMAT=JSON UPDATE t SET c=c+1 WHERE id=10;</code>  </li>
<li>看加锁：<code>SHOW ENGINE INNODB STATUS\G</code> —— 输出 <code>TRANSACTIONS</code> 段。  </li>
<li>看 redo&#x2F;undo 量：<code>SHOW GLOBAL STATUS LIKE &#39;Innodb_log_writes%&#39;;</code>  </li>
<li>看是否用到 change buffer：<code>SHOW STATUS LIKE &#39;Innodb_ibuf%&#39;;</code>  </li>
<li>跟踪源码断点：<br>– <code>Sql_cmd_update::execute()</code> → <code>mysql_update()</code> → <code>ha_innobase::update_row()</code><br>– <code>lock_rec_lock()</code> 看行锁；<br>– <code>log_write_up_to()</code> 看 redo 刷盘。</li>
</ol>
<hr>
<blockquote>
<p>一句话总结<br>Server 层负责“把 SQL 变成执行计划 + 协调各模块”，InnoDB 层负责“把行锁、redo、undo、buffer pool、索引”全部落地；二者通过二阶段提交让 binlog 与 redo log 永远同生共死，从而保证崩溃恢复和主从一致。</p>
</blockquote>
]]></content>
      <categories>
        <category>Program</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
